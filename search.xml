<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客搭建之在文章中插入图片</title>
      <link href="/2022/05/25/hexo-bo-ke-da-jian-zhi-zai-wen-zhang-zhong-cha-ru-tu-pian/"/>
      <url>/2022/05/25/hexo-bo-ke-da-jian-zhi-zai-wen-zhang-zhong-cha-ru-tu-pian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>]</p></blockquote><p>在写文章时，常常有配图说明的需求。Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p><h3 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h3><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>当Hexo项目中只用到少量图片时，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法访问它们。</p><pre class="line-numbers language-none"><code class="language-none">source&#x2F;images&#x2F;image.jpg![](&#x2F;images&#x2F;image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>图片除了可以放在统一的<code>images</code>文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置<code>_config.yml</code>来生成。</p><pre class="line-numbers language-none"><code class="language-none">_config.ymlpost_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为<code>true</code>后，执行命令<code>$ hexo new post_name</code>，在<code>source/_posts</code>中会生成文章<code>post_name.md</code>和同名文件夹<code>post_name</code>。将图片资源放在<code>post_name</code>中，文章就可以使用相对路径引用图片资源了。</p><pre class="line-numbers language-none"><code class="language-none">_posts&#x2F;post_name&#x2F;image.jpg![](image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><pre class="line-numbers language-none"><code class="language-none">_posts&#x2F;post_name&#x2F;image.jpg&#123;% asset_img image.jpg This is an image %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h3><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如<a href="http://cloudinary.com/">Cloudinary</a>提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>curl命令的转换</title>
      <link href="/2022/05/25/curl-ming-ling-de-zhuan-huan/"/>
      <url>/2022/05/25/curl-ming-ling-de-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://www.jianshu.com/p/84bf836ce1c1">https://www.jianshu.com/p/84bf836ce1c1</a>]</p></blockquote><h2 id="一、curl转不同语言代码"><a href="#一、curl转不同语言代码" class="headerlink" title="一、curl转不同语言代码"></a>一、curl转不同语言代码</h2><h2 id="二、Postman-导入导出-curl-命令详细步骤"><a href="#二、Postman-导入导出-curl-命令详细步骤" class="headerlink" title="二、Postman 导入导出 curl 命令详细步骤"></a>二、Postman 导入导出 curl 命令详细步骤</h2><h3 id="浏览器复制curl"><a href="#浏览器复制curl" class="headerlink" title="浏览器复制curl"></a>浏览器复制curl</h3><p><img src="/images/step-1.png" alt="img"></p><h3 id="一、直接上地址，网站有教程"><a href="#一、直接上地址，网站有教程" class="headerlink" title="一、直接上地址，网站有教程"></a>一、直接上地址，网站有教程</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcurl.trillworks.com%2F%23">https://curl.trillworks.com/#</a></p><h3 id="二、接口调试的时候经常会使用到。"><a href="#二、接口调试的时候经常会使用到。" class="headerlink" title="二、接口调试的时候经常会使用到。"></a>二、接口调试的时候经常会使用到。</h3><h4 id="1-postman导入curl"><a href="#1-postman导入curl" class="headerlink" title="1.postman导入curl"></a>1.postman导入curl</h4><p>1）打开 postman ， 点击左上角的 Import ， 选择 Raw Text ，点击 Continue</p><p><img src="/images/step-2.png" alt="img"><br>2）点击 Import<br>3）所有参数都已经配置好了，点击 send 发送请求</p><h4 id="2-postman导出curl"><a href="#2-postman导出curl" class="headerlink" title="2.postman导出curl"></a>2.postman导出curl</h4><p>1）在右侧 CODE 点击</p><p><img src="/images/step-3.png" alt="img"></p><p>2）选择 CURL（其他语言也可）</p>]]></content>
      
      
      <categories>
          
          <category> curl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED flows 操作</title>
      <link href="/2022/05/25/node-red-flows-cao-zuo/"/>
      <url>/2022/05/25/node-red-flows-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="POST-flows"><a href="#POST-flows" class="headerlink" title="POST /flows"></a>POST /flows</h1><blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://nodered.org/docs/api/admin/methods/post/flows/">https://nodered.org/docs/api/admin/methods/post/flows/</a>]</p></blockquote><p>Set the active flow configuration.</p><p>需要权限：<code>flows.write</code></p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><div class="table-container"><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:left">价值</th></tr></thead><tbody><tr><td style="text-align:left"><code>Authorization</code></td><td style="text-align:left"><code>Bearer [token]</code>- 如果启用了身份验证</td></tr><tr><td style="text-align:left"><code>Content-type</code></td><td style="text-align:left"><code>application/json</code></td></tr><tr><td style="text-align:left"><code>Node-RED-API-Version</code></td><td style="text-align:left">（<em>自 0.15.0 起</em>）正在使用的 api 版本。<code>v1</code>如果未设置，则默认为。</td></tr><tr><td style="text-align:left"><code>Node-RED-Deployment-Type</code></td><td style="text-align:left"><code>full</code>, <code>nodes</code>,<code>flows</code>或<code>reload</code></td></tr></tbody></table></div><p>标<code>Node-RED-Deployment-Type</code>头用于定义执行的部署类型。</p><ul><li><code>full</code>- 在新配置开始之前，所有现有节点都已停止。如果未提供标头，这是默认行为。</li><li><code>nodes</code>- 在应用新配置之前，仅停止已修改的节点。</li><li><code>flows</code>- 在应用新配置之前，仅停止包含修改节点的流。</li><li><code>reload</code>- 从存储中重新加载流并重新启动所有节点（从 Node-RED 0.12.2 开始）</li></ul><h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>请求正文的格式将取决于所使用的 Node-RED API 版本：</p><h4 id="v1-节点对象数组"><a href="#v1-节点对象数组" class="headerlink" title="v1- 节点对象数组"></a><code>v1</code>- 节点对象数组</h4><pre class="line-numbers language-none"><code class="language-none">[  &#123;    &quot;type&quot;: &quot;tab&quot;,    &quot;id&quot;: &quot;396c2376.c693dc&quot;,    &quot;label&quot;: &quot;Sheet 1&quot;  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v2-流响应对象"><a href="#v2-流响应对象" class="headerlink" title="v2- 流响应对象"></a><code>v2</code>- 流响应对象</h4><p>该<code>rev</code>属性（如果提供）应反映由 返回的流的修订<code>GET /flows</code>。</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置节点凭据"><a href="#设置节点凭据" class="headerlink" title="设置节点凭据"></a>设置节点凭据</h4><p>有两种方法可以通过此请求提供凭据。数组中的各个节点对象<code>flows</code>可以包含一个<code>credentials</code>属性，该属性包含该节点的凭据。</p><p>或者，顶级对象可以包括一个<code>credentials</code>属性，该属性具有各个节点的凭据，或者一个完整的加密集。</p><p><strong>内联节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;,        &quot;credentials&quot;: &#123;            &quot;user&quot;: &quot;my-username&quot;,            &quot;pass&quot;: &quot;my-password&quot;        &#125;      &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单独的节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ],    &quot;credentials&quot;: &#123;        &quot;396c2376.c693dc&quot;: &#123;            &quot;user&quot;: &quot;my-username&quot;,            &quot;pass&quot;: &quot;my-password&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加密节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ],    &quot;credentials&quot;: &#123;        &quot;$&quot;: &quot;beea417990012379ca6d4116bd1fda5bOWbwy7UnQvccxAEH1V1pSEETTfSNerYGvP4Aai6RT&#x2F;DNpnjCCP&#x2F;fdzildzlJhFjYcRKdO1Q&#x3D;&quot;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>}</p><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><div class="table-container"><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">原因</th><th style="text-align:left">回复</th></tr></thead><tbody><tr><td style="text-align:left"><code>200</code></td><td style="text-align:left"><code>v2</code>成功</td><td style="text-align:left"><code>rev</code>活动流的新特性。见下文。</td></tr><tr><td style="text-align:left"><code>204</code></td><td style="text-align:left"><code>v1</code>成功</td><td style="text-align:left"><em>没有任何</em></td></tr><tr><td style="text-align:left"><code>400</code></td><td style="text-align:left">API 版本无效</td><td style="text-align:left">错误<a href="https://nodered.org/docs/api/admin/errors">响应</a></td></tr><tr><td style="text-align:left"><code>401</code></td><td style="text-align:left">未经授权</td><td style="text-align:left"><em>没有任何</em></td></tr><tr><td style="text-align:left"><code>409</code></td><td style="text-align:left">版本不匹配</td><td style="text-align:left">错误<a href="https://nodered.org/docs/api/admin/errors">响应</a>。见下文。</td></tr></tbody></table></div><p>如果<code>v1</code>正在使用 API，则成功的请求不包含响应正文。</p><p>如果<code>v2</code>正在使用 API，则请求应包括<code>rev</code>设置为<code>rev</code>请求者已知的最新值的属性。如果此值与<code>rev</code>运行时中活动流的值匹配，则请求将成功。</p><p>如果不匹配，这表明运行时正在使用更新版本的流，并且请求被拒绝并带有<code>409</code>状态代码。这允许请求者解决任何差异并重新提交请求。</p><p>如果请求者希望强制部署，<code>rev</code>则应从请求中省略该属性。</p><p>请求成功时，响应会提供新<code>rev</code>值：</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;def-456&quot;,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>注意</em>：该<code>rev</code>属性是一个字符串，但不应对其格式做出其他假设。</p>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED api Authentication</title>
      <link href="/2022/05/25/node-red-api-authentication/"/>
      <url>/2022/05/25/node-red-api-authentication/</url>
      
        <content type="html"><![CDATA[<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p><code>adminAuth</code>使用文件中的属性保护 Node-RED 管理 API <code>settings.js</code> 。<a href="https://nodered.org/docs/user-guide/runtime/securing-node-red">安全</a>部分描述了应该如何配置该属性。</p><p>如果未设置该属性，则对 Node-RED 具有网络访问权限的任何人都可以访问 Node-RED 管理 API。</p><h3 id="Step-0-检查身份验证方案"><a href="#Step-0-检查身份验证方案" class="headerlink" title="Step 0 - 检查身份验证方案"></a>Step 0 - 检查身份验证方案</h3><p><code>/auth/login</code>用于返回活动身份验证方案的 HTTP GET 。</p><p><em>*curl example</em>:*：</p><pre class="line-numbers language-none"><code class="language-none">curl http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前版本的 API 中，有两种可能的结果：</p><h5 id="无主动身份验证"><a href="#无主动身份验证" class="headerlink" title="无主动身份验证"></a>无主动身份验证</h5><pre class="line-numbers language-none"><code class="language-none">&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无需提供任何进一步的身份验证信息即可发出所有 API 请求。</p><h5 id="基于凭据的身份验证"><a href="#基于凭据的身份验证" class="headerlink" title="基于凭据的身份验证"></a>基于凭据的身份验证</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;credentials&quot;,  &quot;prompts&quot;: [    &#123;      &quot;id&quot;: &quot;username&quot;,      &quot;type&quot;: &quot;text&quot;,      &quot;label&quot;: &quot;Username&quot;    &#125;,    &#123;      &quot;id&quot;: &quot;password&quot;,      &quot;type&quot;: &quot;password&quot;,      &quot;label&quot;: &quot;Password&quot;    &#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>API 由访问令牌保护。</p><h3 id="Step-1-获取访问令牌"><a href="#Step-1-获取访问令牌" class="headerlink" title="Step 1 - 获取访问令牌"></a>Step 1 - 获取访问令牌</h3><p>HTTP POST<code>/auth/token</code>用于交换用户凭据以获取访问令牌。</p><p>必须提供以下参数：</p><ul><li><code>client_id</code>- 识别客户。目前，必须是<code>node-red-admin</code>或<code>node-red-editor</code>。</li><li><code>grant_type</code>- 一定是<code>password</code></li><li><code>scope</code>- 请求的权限的空格分隔列表。目前，必须是<code>*</code>或<code>read</code>。</li><li><code>username</code>- 要验证的用户名</li><li><code>password</code>- 验证密码</li></ul><p><em>curl example</em>：</p><pre class="line-numbers language-curl" data-language="curl"><code class="language-curl">curl http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;token --data &#39;client_id&#x3D;node-red-admin&amp;grant_type&#x3D;password&amp;scope&#x3D;*&amp;username&#x3D;admin&amp;password&#x3D;password&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果成功，响应将包含访问令牌：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;access_token&quot;: &quot;A_SECRET_TOKEN&quot;,  &quot;expires_in&quot;:604800,  &quot;token_type&quot;: &quot;Bearer&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Step-2-使用访问令牌"><a href="#Step-2-使用访问令牌" class="headerlink" title="Step 2 - 使用访问令牌"></a>Step 2 - 使用访问令牌</h3><p>然后，所有后续 API 调用都应在标头中提供此令牌<code>Authorization</code> 。</p><p><em>curl example</em>：</p><pre class="line-numbers language-curl" data-language="curl"><code class="language-curl">curl -H &quot;Authorization: Bearer A_SECRET_TOKEN&quot; http:&#x2F;&#x2F;localhost:1880&#x2F;settings<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="撤销令牌"><a href="#撤销令牌" class="headerlink" title="撤销令牌"></a>撤销令牌</h3><p>要在不再需要令牌时撤销令牌，应通过 HTTP POST 将其发送到<code>/auth/revoke</code>：</p><p><em>卷曲示例</em>：</p><pre class="line-numbers language-none"><code class="language-none">curl --data &#39;token&#x3D;A_SECRET_TOKEN&#39; -H &quot;Authorization: Bearer A_SECRET_TOKEN&quot; http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;revoke<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bearer Token 的使用方法</title>
      <link href="/2022/05/25/bearer-token-de-shi-yong-fang-fa/"/>
      <url>/2022/05/25/bearer-token-de-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://blog.yorkxin.org/posts/oauth2-6-bearer-token.html">https://blog.yorkxin.org/posts/oauth2-6-bearer-token.html</a>]</p></blockquote><p>這篇不屬於 OAuth 2.0 規格書（RFC 6749）本身，而是屬於另一份 spec <em><a href="https://tools.ietf.org/html/rfc6750">RFC 6750: The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></em> 。我認為它存在的目的是「示範一下 Token 的用法，並且定義下來，讓大家可以參考」，因為 OAuth 2.0 規格書沒有明確規定「Token 長什麼樣子」，甚至「Resource Server 如何拒絕非法的 Token」（指 API）都沒定義，只規定了怎麼拿取、怎麼撤銷、怎麼流通。</p><p>實際上，即使有定義這個 Bearer Token ，各大網站的 API 也並非都使用這種 Token ，我看到有明確說明使用 Bearer Token 的像是 Twitter API，其他的要不是非使用 “Bearer” 關鍵字，就是沒有明確指出何種 Token （其實也不需要，因為在那些網站 Token 只有一種用途）。</p><p>不過即使如此，對於我打算實作的 API ，我也是準備使用 Bearer Token 的，因為夠 naïve 。如果你跟我一樣沒有自己刻 Token 的能力，就用 Bearer Token 就好了。</p><p>當然， RFC 6750 我也有轉成 <a href="https://gist.github.com/yorkxin/6591290">Markdown 好讀版</a>。</p><h2 id="Bearer-Token-的用途"><a href="#Bearer-Token-的用途" class="headerlink" title="Bearer Token 的用途"></a>Bearer Token 的用途</h2><p>OAuth 2.0 (<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>) 定義了 Client 如何取得 Access Token 的方法。Client 可以用 Access Token 以 Resource Owner 的名義來向 Resource Server 取得 Protected Resource ，例如我 (Resource Owner) 授權一個手機 App (Client) 以我 (Resource Owner) 的名義去 Facebook (Resource Server) 取得我的朋友名單 (Protected Resource)。OAuth 2.0 定義 Access Token 是 Resource Server 用來認證的唯一方式，有了這個， Resource Server 就不需要再提供其他認證方式，例如帳號密碼。</p><p>然而在 RFC 6749 裡面只定義抽象的概念，細節如 Access Token 格式、怎麼傳到 Resource Server ，以及 Access Token 無效時， Resource Server 怎麼處理，都沒有定義。所以在 RFC 6750 另外定義了 Bearer Token 的用法。Bearer Token 是一種 Access Token ，由 Authorization Server 在 Resource Owner 的允許下核發給 Client ，Resource Server 只要認這個 Token 就可以認定 Client 已經經由 Resource Owner 的許可，不需要用密碼學的方式來驗證這個 Token 的真偽。關於 Token 被偷走的安全性問題，此 Spec 裡面也有提到。</p><p><em>本段參考 Abstract 及 Section 1</em></p><h2 id="Bearer-Token-的格式"><a href="#Bearer-Token-的格式" class="headerlink" title="Bearer Token 的格式"></a>Bearer Token 的格式</h2><pre class="line-numbers language-none"><code class="language-none">Bearer XXXXXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>XXXXXXXX</code> 的格式為 b64token ，ABNF 的定義：</p><pre class="line-numbers language-none"><code class="language-none">b64token &#x3D; 1*( ALPHA &#x2F; DIGIT &#x2F; &quot;-&quot; &#x2F; &quot;.&quot; &#x2F; &quot;_&quot; &#x2F; &quot;~&quot; &#x2F; &quot;+&quot; &#x2F; &quot;&#x2F;&quot; ) *&quot;&#x3D;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>寫成 Regular Expression 即是：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;[A-Za-z0-9\-\._~\+\&#x2F;]+&#x3D;*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>本段參考 Section 2.1</em></p><h2 id="Client-向-Resource-Server-出示-Access-Token-的方式"><a href="#Client-向-Resource-Server-出示-Access-Token-的方式" class="headerlink" title="Client 向 Resource Server 出示 Access Token 的方式"></a>Client 向 Resource Server 出示 Access Token 的方式</h2><p>三種</p><h3 id="1-放在-HTTP-Header-裡面"><a href="#1-放在-HTTP-Header-裡面" class="headerlink" title="(1) 放在 HTTP Header 裡面"></a>(1) 放在 HTTP Header 裡面</h3><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;resource HTTP&#x2F;1.1Host: server.example.comAuthorization: Bearer mF_9.B5f-4.1JqM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Resource Server 必須支援這個方式。</p><p><em>本段參考 Section 2.2</em></p><h3 id="2-放在-Request-Body-裡面（Form-之類的）"><a href="#2-放在-Request-Body-裡面（Form-之類的）" class="headerlink" title="(2) 放在 Request Body 裡面（Form 之類的）"></a>(2) 放在 Request Body 裡面（Form 之類的）</h3><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;resource HTTP&#x2F;1.1Host: server.example.comContent-Type: application&#x2F;x-www-form-urlencodedaccess_token&#x3D;mF_9.B5f-4.1JqM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前提：</p><ul><li>Header 要有 <code>Content-Type: application/x-www-form-urlencoded</code>。</li><li>Body 格式要符合 <a href="https://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#h-17.13.4.1">W3C HTML 4.01 定義 application/x-www-form-urlencoded</a>。</li><li>Body 要只有一個 part （不可以是 multipart）。</li><li>Body 要編碼成只有 ASCII chars 的內容。</li><li>Request method 必須是一種有使用 request-body 的，也就是說不能用 <code>GET</code> 。</li></ul><p>就是送表單嘛，但不可以是 <code>multipart/form-data</code> 這種（通常用來上傳檔案）。</p><p>Resource Server 可以但不一定要支援這個方式。</p><p><em>本段參考 Section 2.3</em></p><h3 id="3-放在-URI-裡面的一個-Query-Parameter-（不建議）"><a href="#3-放在-URI-裡面的一個-Query-Parameter-（不建議）" class="headerlink" title="(3) 放在 URI 裡面的一個 Query Parameter （不建議）"></a>(3) 放在 URI 裡面的一個 Query Parameter （不建議）</h3><p>規定要使用 <code>access_token</code> 這個 parameter ，例：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;resource?access_token&#x3D;mF_9.B5f-4.1JqM HTTP&#x2F;1.1Host: server.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然而因為 URL 可以被 proxy 抄走（如 log）或存在瀏覽器的歷史記錄裡面，為了防 replay ，最好這樣做：</p><ul><li>Client 送 <code>Cache-Control: no-store</code> header</li><li>Server 回 <code>2xx</code> 的時候，送 <code>Cache-Control: private</code> header</li></ul><p><strong>Spec 不建議使用這種方法</strong>，如果真的沒辦法送 header 也沒辦法透過 request-body 送，再來考慮這種。</p><p>Resource Server 可以但不一定要支援這個方式。</p><p><em>本段參考 Section 2.4</em></p><h2 id="Resource-Server-向-Client-提示「認證不過，拒絕存取」的方式"><a href="#Resource-Server-向-Client-提示「認證不過，拒絕存取」的方式" class="headerlink" title="Resource Server 向 Client 提示「認證不過，拒絕存取」的方式"></a>Resource Server 向 Client 提示「認證不過，拒絕存取」的方式</h2><p>拒絕存取的情況，例如沒給 Access Token 或是給了但不合法（如空號、過期、Resource Owner 沒許可 Client 拿取此資料），則 Resource Server 必須在回應裡包含 <code>WWW-Authenticate</code> 的 header 來提示錯誤。這個 header 定義在 <a href="https://tools.ietf.org/html/rfc2617#section-3.2.1">RFC 2617 Section 3.2.1</a>。<code>WWW-Authenticate</code> 的值，使用的 auth-scheme 是 <code>Bearer</code> ，隨後一個空格，接著要有至少一個 auth-param 。</p><p>範例：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 401 UnauthorizedWWW-Authenticate: Bearer realm&#x3D;&quot;example&quot;,                  error&#x3D;&quot;invalid_token&quot;,                  error_description&#x3D;&quot;The access token expired&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下這些 auth-params 是 <code>WWW-Authenticate</code> 會用到的：</p><div class="table-container"><table><thead><tr><th>參數名</th><th>必/選</th><th>填什麼/意義</th></tr></thead><tbody><tr><td>realm</td><td>選用</td><td>見下文</td></tr><tr><td>scope</td><td>選用</td><td>提示所需權限，見下文</td></tr><tr><td>error</td><td>選用</td><td>有出示 Access Token 則最好有這個</td></tr></tbody></table></div><h3 id="realm"><a href="#realm" class="headerlink" title="realm"></a><code>realm</code></h3><p>用 <code>realm</code> 來指出需要授權才能存取的範圍，意義跟 <a href="https://tools.ietf.org/html/rfc2617">HTTP Authentication</a> 的 <code>realm</code> 一樣。<code>realm</code> 只能出現一次。</p><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a><code>scope</code></h3><p>用 <code>scope</code> 來指出「要拿這個 Resource 需要出示具有哪些 scope 的 Access Token 」：</p><ul><li>要區分大小寫。</li><li>要以空白分隔。</li><li>可以用哪些 scope ，是看 Authorization Server 怎麼定義，Spec 不定義，也沒有登錄中心。</li><li>順序不重要。</li><li>是給程式看的，不是設計給使用者看的。</li></ul><p><code>scope</code> 還可以在向 Authorization Server 索取新 Access Token 的時候使用。</p><p><code>scope</code> 值只能出現一次。實際寫在 <code>scope</code> 裡面的單一個 scope 必須只能用以下的字元，定義在 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.4">RFC 6749 附錄 A.4</a> ：</p><pre class="line-numbers language-none"><code class="language-none">\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。空格當然也不能用，因為是用來區分不同 scopes 的。</p><h3 id="error"><a href="#error" class="headerlink" title="error"></a><code>error</code></h3><p>如果 Client 出示了 Access Token 但認證失敗，則最好加上 <code>error</code> 這個 auth-param ，用來告訴 Client 為何認證失敗。此外還可以加上 <code>error_description</code> 用自然語言來告訴開發者為什麼錯誤，但這個不該給使用者看到。此外也可以加上 <code>error_uri</code> 用來提供一個網址，裡面用自然語言解釋錯誤訊息。這三個 auth-param 都只能最多出現一次。</p><p>如果 request 沒有出示 Access Token （例如 Client 不知道需要認證，或是使用了不支援的認證方式（例如不支援 URI parameter）），則 response 不應該帶 <code>error</code> 或任何錯誤訊息。</p><p><code>error</code> 的值的意義以及推薦使用的 HTTP response code 如下：</p><div class="table-container"><table><thead><tr><th>值</th><th>Status Code</th><th>意義/用途</th></tr></thead><tbody><tr><td>invalid_request</td><td>400 Bad Request</td><td>沒提供必要的參數、提供了不支援的參數、提供了錯誤的參數值、同樣的參數出現多次、使用一種以上的方法來出示 Access Token （如放在 header 裡又放在 form 裡）、或是其他無法解讀 request 的情況。</td></tr><tr><td>invalid_token</td><td>401 Unauthorized</td><td>Access Token 過期、被收回授權、無法解讀、或其他 Access Token 不合法的情況。這種情況下， Client 可以重新申請一個 Access Token 並且用新的 Access Token 來重試 request 。</td></tr><tr><td>insufficient_scope</td><td>403 Forbidden</td><td>這個 request 需要出示比 Client 出示的 Access Token 代表的 scopes 還要更多的 scopes 。這種情況下，可以另外提供 <code>scope</code> auth-param 來具體指出需要哪些 scopes 。</td></tr></tbody></table></div><p><code>error</code> 和 <code>error_description</code> 的值必須只能用以下的字元，定義在 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.7">RFC 6749 附錄 A.7</a> 和 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.8">RFC 6749 附錄 A.8</a>：</p><pre class="line-numbers language-none"><code class="language-none">\x20-\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即空格 (\x20) 再加上可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。</p><p><code>error_uri</code> 的值必須符合 <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a> 的定義，即是只能用以下的字元（同 <code>scope</code> 裡面的單一 scope）：</p><pre class="line-numbers language-none"><code class="language-none">\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。</p><p><em>本段參考 Section 3 及 Section 3.1</em></p><h2 id="Authorization-Server-給-Client-核發-Access-Token-的範例"><a href="#Authorization-Server-給-Client-核發-Access-Token-的範例" class="headerlink" title="Authorization Server 給 Client 核發 Access Token 的範例"></a>Authorization Server 給 Client 核發 Access Token 的範例</h2><p>既然是 OAuth 2.0 的 access token ，就通常是循 <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 的 spec</a> 來核發，範例如下：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OKContent-Type: application&#x2F;json;charset&#x3D;UTF-8Cache-Control: no-storePragma: no-cache&#123;  &quot;access_token&quot;:&quot;mF_9.B5f-4.1JqM&quot;,  &quot;token_type&quot;:&quot;Bearer&quot;,  &quot;expires_in&quot;:3600,  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>本段參考 Section 4</em></p><h2 id="安全性問題與對策"><a href="#安全性問題與對策" class="headerlink" title="安全性問題與對策"></a>安全性問題與對策</h2><p>RFC 6750 是基於 OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 來寫的，所以在該 spec 裡面提過的安全性問題就不再提及。</p><p>原文將問題與問題對策分開成 Section 5.1 和 Section 5.2 ，我為了方便筆記，所以合併在一起。以下「壞人」的原文是 <em>attacker</em>。</p><h3 id="一般對策"><a href="#一般對策" class="headerlink" title="一般對策"></a>一般對策</h3><p>大部份的安全性問題可以透過數位簽章或是 MAC (Message Authentication Code) 來防護。</p><p>Authorization Server 必須有實作 TLS，版本則隨時間推移而不同。 spec 作成的時候， TLS 最新版是 1.2 ，但實務上很少使用，1.0 才是最為廣泛利用的。</p><h3 id="偽造或竄改-Access-Token-的問題"><a href="#偽造或竄改-Access-Token-的問題" class="headerlink" title="偽造或竄改 Access Token 的問題"></a>偽造或竄改 Access Token 的問題</h3><p>壞人可能會偽造或竄改既有的 Access Token （竄改指的是修改授權範圍或授權參數），讓 Resource Server 給予 Client 不適當的存取權。例如，壞人可能會延長 Token 的過期時間。或是惡意的 Client 變造聲明來看到它不應該看到的東西，例如，告訴使用者只拿取公開的個人資料，卻在取得授權時，另外拿了朋友名單。</p><p><em>Section 5.1 &gt; Token manufacture/modification</em></p><h4 id="對策"><a href="#對策" class="headerlink" title="對策"></a>對策</h4><p>對於 Bearer Token ，可以只加一個參照用的 id 來間接指到真正的授權資訊，而不是直接燒在 Token 裡面。這種間接參照用的 id ，必須要難以被猜到；但使用間接參照，因為要間接檢查授權資訊，所以可能會導致 Resource Server 和 Authorization Server 之間有額外的動作※。這種機制的細節，spec 裡面沒有定義。</p><p>Spec 沒有定義 token 的編碼方式，所以不提及保護 Token 的完整性 (integrity) 的詳細建議。若要實作保護完整性的措施，則該實作方式必須要可以防止 Token 被竄改。</p><p>※：原文是 <em>“between a server and the token issuer”</em></p><h3 id="Access-Token-傳輸過程外洩、曝露敏感資料的問題"><a href="#Access-Token-傳輸過程外洩、曝露敏感資料的問題" class="headerlink" title="Access Token 傳輸過程外洩、曝露敏感資料的問題"></a>Access Token 傳輸過程外洩、曝露敏感資料的問題</h3><p>Token 傳輸過程可能被監聽而外洩，或 Token 本身可能會包含敏感資料※。</p><p>※在 Section 5.1 原文提及 “token disclosure” 的時候，僅提及曝露敏感資料，沒提及傳輸過程的外洩，然而 5.2 裡面關於 “token disclosure” 的對策，有一併提及傳輸過程外洩（中間人攻擊、監聽等），所以我寫這一段時，同時提及傳輸外洩以及曝露敏感資料。</p><p><em>Section 5.1 &gt; Token disclosure</em></p><h4 id="對策-1"><a href="#對策-1" class="headerlink" title="對策"></a>對策</h4><p>為了防範 Token 在傳輸過程外洩，必須用 TLS 來實作機密防護，且該實作方式必須要使用有提供機密防護和完整性防護的加密方式，如此就能要求 Client 與 Authorization Server 和 Client 與 Resource Server 之間的通訊要有機密防護和完整性防護。因為 TLS 是這份 spec 裡面規定一定要實作的，所以利用 TLS 來達成通訊過程的機密防護和完整性防護，是比較偏好的做法。</p><p>如果要防止 Client 取得 Token 的內容，那麼除了 TLS 之外，還必須實作 Token 加密。</p><p>要進一步防範 Token 外洩，則 Client 在發 request 的時候，還必須要驗證 TLS 的憑證鏈 (certificate chain) ，包括檢查憑證有沒有被撤銷（Certificate Revocation List, RFC 5280）。</p><p>Cookie 通常是明文傳輸的 (in the clear)，所以任何寫在裡面的資訊都有外洩的風險。所以， Bearer Token 絕對不可以存放在明文傳輸 cookie 裡面。詳見 RFC 6265 (HTTP State Management Mechanism) 裡面關於 cookie 的安全性問題。</p><p>某些部署方式，好比說利用 Load Balancer 的，TLS 傳輸在抵達 Resource Server 之前就結束了。這樣子會導致 Token 在前端 Load Balaner 和後端實體 Resrouce Server 之間，沒有加密保護。這種情況下，必須實作足夠的手段※，來確保前端和後端 server 之間的資料保密。Token 加密也是一種方式。</p><p>※ 原文為 <em>sufficient measures</em>，我不會翻譯…</p><h3 id="挪用-Access-Token-的問題"><a href="#挪用-Access-Token-的問題" class="headerlink" title="挪用 Access Token 的問題"></a>挪用 Access Token 的問題</h3><p>壞人可能會把某個專門給 Resource Server A 的 Access Token ，挪用到 Resource Server B ，使得 B 誤信該 Access Token 可以拿來存取 B 的資料。</p><p><em>Section 5.1 &gt; Token redirect</em></p><h4 id="對策-2"><a href="#對策-2" class="headerlink" title="對策"></a>對策</h4><p>要防止 Token 被挪用，則這件事很重要：Authorization Server 核發的 Token 裡面要附上被核發人的資訊（通常是一或多部 Resource Server）。同時，也建議限制 Token 可以使用的 scope 範圍。</p><h3 id="二度利用-Access-Token-的問題"><a href="#二度利用-Access-Token-的問題" class="headerlink" title="二度利用 Access Token 的問題"></a>二度利用 Access Token 的問題</h3><p>壞人使用之前就存在的 Access Token 來存取 Reseouce Server （即：Token 被偷去用）。</p><p><em>Section 5.1 &gt; Token replay</em></p><h3 id="對策-3"><a href="#對策-3" class="headerlink" title="對策"></a>對策</h3><p>要防止 Token 被偷走並且拿來二度利用，建議採用以下方案：</p><ol><li>Token 的存活時間必須被限制住。一種手段是在 Token 受保護的區段裡面，設一個合法期間。使用短時效的 Token （如一小時以下）可以降低 Token 外洩的風險。</li></ol><ul><li>Token 在 Client ↔ Authorization Server 、 Client ↔ Resource Server 之間交換的時候，必須要實作機密防護。如此一來，就算在傳輸途徑上監聽，也無法獲得 Token ，也就無法二度利用。</li><li>Client 要向 Resource Server 出示 Token 的時候，Client 必須驗證 Resource Server 的真實身份，如 RFC 2818 (TLS) 的 Section 3.1 裡面所述。注意，Client 必須要驗證 TLS 憑證的憑證鏈 (certificate chain)。若 Resource Server 未經授權且未通過認證，或是憑證鏈驗證失敗，這時候向它出示 Token ，會導致敵手取得 Token 並且得到未經授權的權限來存取受保護的 resource。</li></ul><h2 id="安全性建議的總結"><a href="#安全性建議的總結" class="headerlink" title="安全性建議的總結"></a>安全性建議的總結</h2><p><em>Section 5.3 Summary of Recommendations</em></p><h3 id="要藏好-Bearer-Token"><a href="#要藏好-Bearer-Token" class="headerlink" title="要藏好 Bearer Token"></a>要藏好 Bearer Token</h3><p>Client 實作必須確保 Bearer Token 不會外洩給無關人士，因為他們可以以此來存取受保護的 resources。利用 Bearer Token 時，這是首要的安全性考量，且優先於其他更細節的建議。</p><h3 id="要驗證-TLS-的憑證鏈"><a href="#要驗證-TLS-的憑證鏈" class="headerlink" title="要驗證 TLS 的憑證鏈"></a>要驗證 TLS 的憑證鏈</h3><p>當 Client 發 request 索取受保護的 resources 的時候，Client 必須驗證 TLS 的憑證鏈。若做不到的話，可能會引發 DNS 劫持，導致 Token 被壞人偷走。</p><h3 id="全程使用-TLS-https"><a href="#全程使用-TLS-https" class="headerlink" title="全程使用 TLS (https)"></a>全程使用 TLS (https)</h3><p>當 Clients 利用 Bearer Token 發 request 時，Client 必須一直使用 TLS (RFC5246) (https) 或同等的安全傳輸。若做不到的話， Token 會曝露在各種攻擊方式，讓壞人可以得到意料之外的存取權。</p><h3 id="不要把-Bearer-Token-存在-Cookie"><a href="#不要把-Bearer-Token-存在-Cookie" class="headerlink" title="不要把 Bearer Token 存在 Cookie"></a>不要把 Bearer Token 存在 Cookie</h3><p>絕對不可以把 Bearer Token 存在可以明文傳輸 (sent in the clear) 的 Cookie 裡面（明文傳輸是 cookie 傳輸的預設方式）。若存在 Cookie 裡面，必須要小心 Cross-Site Request Forgery 。</p><h3 id="要核發短時效的-Bearer-Token"><a href="#要核發短時效的-Bearer-Token" class="headerlink" title="要核發短時效的 Bearer Token"></a>要核發短時效的 Bearer Token</h3><p>核發 Token 的伺服器最好是核發短時效的 Bearer Token （一小時以內），尤其是發給跑在瀏覽器裡面的 Client ，或是其他容易發生資訊外洩的場合。利用短時效的 Bearer Token 可以降低 Token 外洩時的衝擊。</p><h3 id="要核發有區分使用範圍的-Bearer-Token"><a href="#要核發有區分使用範圍的-Bearer-Token" class="headerlink" title="要核發有區分使用範圍的 Bearer Token"></a>要核發有區分使用範圍的 Bearer Token</h3><p>Token 伺服器最好要核發包含 audience restriction, scoping their use to the intended replying party, or set of relying party 的 Token 。</p><h3 id="不要用-Page-URL-來傳送-Bearer-Token"><a href="#不要用-Page-URL-來傳送-Bearer-Token" class="headerlink" title="不要用 Page URL 來傳送 Bearer Token"></a>不要用 Page URL 來傳送 Bearer Token</h3><p>Bearer Token 最好不要從 URL 來傳送（例如 query parameter），而最好是從有保密措施的 HTTP header 或是 body 來傳輸※。瀏覽器、伺服器等軟體可能不會把歷史記錄或資料結構給妥善加密。如果 Bearer Token 透過 URL 傳輸，則壞人就有可能可以從歷史記錄取得之。</p><p>※ <em>“be passed in HTTP message headers or message bodies for which confidentiality measures are taken”</em></p><hr><h2 id="OAuth-2-0-系列文目錄"><a href="#OAuth-2-0-系列文目錄" class="headerlink" title="OAuth 2.0 系列文目錄"></a>OAuth 2.0 系列文目錄</h2><ul><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/">(1) 世界觀</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-2-cilent-registration/">(2) Client 的註冊與認證</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-3-endpoints/">(3) Endpoints 的規格</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-1-auth-code-grant-flow/">(4.1) Authorization Code Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-2-implicit-grant-flow/">(4.2) Implicit Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-3-resource-owner-credentials-grant-flow/">(4.3) Resource Owner Credentials Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-4-client-credentials-grant-flow/">(4.4) Client Credentials Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-5-issuing-tokens/">(5) 核發與換發 Access Token</a></li><li><strong><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-6-bearer-token/">(6) Bearer Token 的使用方法</a> ← You Are Here</strong></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-7-security-considerations/">(7) 安全性問題</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-implementation-differences-among-famous-sites/">各大網站 OAuth 2.0 實作差異</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OAuth </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法速查表</title>
      <link href="/2022/05/25/markdown-yu-fa-su-cha-biao/"/>
      <url>/2022/05/25/markdown-yu-fa-su-cha-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法速查表"><a href="#Markdown-语法速查表" class="headerlink" title="Markdown 语法速查表"></a>Markdown 语法速查表</h1><p>Markdown 语法参考手册 / 速查表。</p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>此 Markdown 语法速查表提供了所有 Markdown 语法元素的快速参考。但是此速查表无法涵盖所有极限用法，因此，如果您需要某些语法元素的详细信息，请参阅我们的 <a href="https://www.markdown.xyz/basic-syntax">基本语法</a> 和 <a href="https://www.markdown.xyz/extended-syntax">扩展语法</a> 手册。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。</p><div class="table-container"><table><thead><tr><th>元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><a href="https://www.markdown.xyz/basic-syntax/#headings">标题（Heading）</a></td><td><code># H1## H2### H3</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#bold">粗体（Bold）</a></td><td><code>**bold text**</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#italic">斜体（Italic）</a></td><td><code>*italicized text*</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#blockquotes-1">引用块（Blockquote）</a></td><td><code>&gt; blockquote</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#ordered-lists">有序列表（Ordered List）</a></td><td><code>1. First item2. Second item3. Third item</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#unordered-lists">无序列表（Unordered List）</a></td><td><code>- First item- Second item- Third item</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#code">代码（Code）</a></td><td><code>code</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#horizontal-rules">分隔线（Horizontal Rule）</a></td><td><code>---</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#links">链接（Link）</a></td><td><code>[title](https://www.example.com)</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#images">图片（Image）</a></td><td><code>![alt text](image.jpg)</code></td></tr></tbody></table></div><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。</p><div class="table-container"><table><thead><tr><th>元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><a href="https://www.markdown.xyz/extended-syntax/#tables">表格（Table）</a></td><td>&#124; Syntax &#124; Description &#124;<br>&#124; —————- &#124; —————- &#124;<br>&#124; Header &#124; Title &#124;<br>&#124; Paragraph &#124; Text &#124;</td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#fenced-code-blocks">代码块（Fenced Code Block）</a></td><td><code>&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;</code></td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#footnotes">脚注（Footnote）</a></td><td><code>Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote.</code></td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#heading-ids">标题编号（Heading ID）</a></td><td>`### My Great Heading </td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 扩展语法</title>
      <link href="/2022/05/25/markdown-kuo-zhan-yu-fa/"/>
      <url>/2022/05/25/markdown-kuo-zhan-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-扩展语法"><a href="#Markdown-扩展语法" class="headerlink" title="Markdown 扩展语法"></a>Markdown 扩展语法</h1><p>构建在 Markdown 基本语法上的扩展功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>即便 John Gruber 的原始设计文档中所列出的 <a href="https://www.markdown.xyz/basic-syntax">Markdown 基本语法</a> 已经囊括了许多满足日常所需的元素，但对于某些人来说仍然不够。这就是 Markdown 扩展语法出现的缘由。</p><p>一些个人和组织通过添加表格（tables）、代码块（code blocks）、语法高亮、将 URL 自动转换为链接和脚注（footnotes）等额外的元素来扩展 Markdown 的基本语法。这些额外添加的元素可以通过使用构建于 Markdown 之上的轻量级标记语言或通过向兼容的 Markdown 解析器添加扩展来启用这些新元素。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>并非所有的 Markdown 应用程序都支持扩展语法。你需要确认你所使用的应用程序是否支持你所需要使用的扩展语法。如果不支持，则有可能是需要开启相应的扩展模块。</p><h3 id="轻量级标记语言"><a href="#轻量级标记语言" class="headerlink" title="轻量级标记语言"></a>轻量级标记语言</h3><p>目前有几种轻量级标记语言是 Markdown 的 <em>超集</em> 。它们支持 Gruber 的基本语法，并在其基础上添加了一些额外的元素，例如表格（tables）、代码块（code blocks）、语法高亮、将 URL 自动转换为链接和脚注（footnotes）。许多流行的 Markdown 应用程序能够支持以下列出的某个轻量级标记语言：</p><ul><li><a href="https://commonmark.org/">CommonMark</a></li><li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown (GFM)</a></li><li><a href="https://michelf.ca/projects/php-markdown/extra/">Markdown Extra</a></li><li><a href="https://fletcherpenney.net/multimarkdown/">MultiMarkdown</a></li><li><a href="https://rmarkdown.rstudio.com/">R Markdown</a></li></ul><h3 id="Markdown-解析器"><a href="#Markdown-解析器" class="headerlink" title="Markdown 解析器"></a>Markdown 解析器</h3><p>目前可用的 <a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">Markdown 解析器有数十个</a> 。其中许多都可以通过添加扩展模块的方式来支持 Markdown 扩展语法。请查看你所使用的 Markdown 解析器的文档以了解更多信息。</p><h2 id="表格（Tables）"><a href="#表格（Tables）" class="headerlink" title="表格（Tables）"></a>表格（Tables）</h2><p>如需添加表格，请使用三个或更多个连字符（<code>---</code>）来为每个列创建表头，并使用管道符（<code>|</code>）来分隔每个列。为兼容考虑，你还应该在行的两侧添加管道符。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>单元格（cell）宽度是可变的，如下所示。渲染效果相同。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong> 使用连字符（hyphens）和管道符（pipes）创建表格会很乏味。若要加快进度，请试一试 <a href="https://www.tablesgenerator.com/markdown_tables">Markdown 表格生成器</a>。使用图形界面生成表格，然后将生成的 Markdown 格式的文本复制粘贴到文件中即可。</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>通过在标题行中的连字符（hyphens）的左侧或右侧或两侧添加冒号（<code>:</code>），可以将对应列中的文本向左或向右或居中对齐。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description | Test Text     || :---        |    :----:   |          ---: || Header      | Title       | Here&#39;s this   || Paragraph   | Text        | And more      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><h3 id="格式化表格中的文本"><a href="#格式化表格中的文本" class="headerlink" title="格式化表格中的文本"></a>格式化表格中的文本</h3><p>你可以为表格中的文本设置格式。例如，可以添加 <a href="https://www.markdown.xyz/basic-syntax/#links">链接（links）</a>、<a href="https://www.markdown.xyz/basic-syntax/#code-1">代码（code）</a> （注意，只能为单词或短语添加反引号 (```) ，不能添加 <a href="https://www.markdown.xyz/basic-syntax/#code-blocks">代码块（code blocks）</a>）以及 <a href="https://www.markdown.xyz/basic-syntax/#emphasis">强调（emphasis）</a>。</p><p>不支持的格式包括标题（headings）、块引用（blockquotes）、列表（lists）、水平分割线（horizontal rules）、图片（images）或 HTML 标记。</p><h3 id="转义表格中出现的管道符（Pipe-Characters）"><a href="#转义表格中出现的管道符（Pipe-Characters）" class="headerlink" title="转义表格中出现的管道符（Pipe Characters）"></a>转义表格中出现的管道符（Pipe Characters）</h3><p>如需在表格中显示管道符 (<code>|</code>)，你可以使用管道符的 HTML 字符编码（<code>|</code>）来实现。</p><h2 id="围栏代码块（Fenced-Code-Blocks）"><a href="#围栏代码块（Fenced-Code-Blocks）" class="headerlink" title="围栏代码块（Fenced Code Blocks）"></a>围栏代码块（Fenced Code Blocks）</h2><p>Markdown 的基本语法允许你通过缩进四个空格或一个制表符来创建 <a href="https://www.markdown.xyz/basic-syntax#code-blocks">代码块</a> 。如果你觉得不方便，可以试试围栏代码块（fenced code blocks）。根据 Markdown 解析器或编辑器的不同，代码块的前后可以使用三个反引号（<code>````）或三个波浪号（</code>~~~`）来标记围栏代码块。这有什么优势吗？你不必费力缩进任何行了！</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong> 需要在代码块中显示反引号（backticks）吗？请参见 <a href="https://www.markdown.xyz/basic-syntax/#escaping-backticks">这一章节</a> 以了解如何对其进行转义。</p><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>许多 Markdown 解析器都支持围栏代码块的语法高亮功能。此功能允许你为编写代码所用的编程语言添加带颜色的语法高亮显示。如需添加语法高亮，请在围栏代码块前的反引号旁指定所用的编程语言。</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;json&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="脚注（Footnotes）"><a href="#脚注（Footnotes）" class="headerlink" title="脚注（Footnotes）"></a>脚注（Footnotes）</h2><p>脚注（Footnotes）允许你添加注释（notes）和引用（references），而不会使文档正文混乱。当你创建脚注时，带有链接的上标数字会出现在你引用脚注的位置。 读者可以单击链接以跳转至页面底部的脚注内容处。</p><p>要创建一个脚注的引用，请在方括号中添加一个插入符（caret）以及一个标识符，标识符可以是数字或单词，但不能包含空格或制表符。标识符的作用仅是将脚注的引用和脚注本身进行关联，在输出中，脚注按顺序编号。</p><p>另一种创建脚注的方式是在方括号内添加一个插入符（caret）以及一个数字，后面跟着冒号和文本，即（<code>[^1]: My footnote.</code>）。这种方式让你不必在文档末尾添加脚注。你可以将脚注放到除列表（lists）、块引用（block quotes）和表格（tables）之外的任何位置上。</p><pre class="line-numbers language-none"><code class="language-none">Here&#39;s a simple footnote,[^1] and here&#39;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&#39;s one with multiple paragraphs and code.    Indent paragraphs to include them in the footnote.    &#96;&#123; my code &#125;&#96;    Add as many paragraphs as you like.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p>Here’s a simple footnote,<a href="https://www.markdown.xyz/extended-syntax/#fn:1">1</a> and here’s a longer one.<a href="https://www.markdown.xyz/extended-syntax/#fn:bignote">2</a></p><ol><li><p>This is the first footnote. <a href="https://www.markdown.xyz/extended-syntax/#fnref:1">↩</a></p></li><li><p>Here’s one with multiple paragraphs and code.</p><p>Indent paragraphs to include them in the footnote.</p><p><code>&#123; my code &#125;</code></p><p>Add as many paragraphs as you like. <a href="https://www.markdown.xyz/extended-syntax/#fnref:bignote">↩</a></p></li></ol><h2 id="自定义标题的-ID"><a href="#自定义标题的-ID" class="headerlink" title="自定义标题的 ID"></a>自定义标题的 ID</h2><p>许多 Markdown 解析器都支持为 <a href="https://www.markdown.xyz/basic-syntax/#headings">标题（headings）</a> 自定义 ID，某些 Markdown 解析器会自动为标题添加 ID。通过添加自定义 ID， 能够让你直接链接到这个标题，并且还能使用 CSS 修改其样式。如需为标题添加自定义 ID，请将自定义 ID 用花括号括起来并与标题一起放在同一行。</p><pre class="line-numbers language-none"><code class="language-none">### My Great Heading &#123;#custom-id&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的 HTML 如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&lt;h3 id&#x3D;&quot;custom-id&quot;&gt;My Great Heading&lt;&#x2F;h3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>###链接到标题的 ID</p><p>你可以在文档中创建一个 <a href="https://www.markdown.xyz/basic-syntax/#links">标准链接</a> ，其后是井号（<code>#</code>）和自定义的标题 ID ，从而链接到这个标题。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>[Heading IDs](#heading-ids)</code></td><td><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td><td><a href="https://www.markdown.xyz/extended-syntax/#heading-ids">Heading IDs</a></td></tr></tbody></table></div><p>其它网站也可以通过将自定义的标题 ID 添加到网页的完整的 URL 后面来链接到对应的标题（例如，<code>[Heading IDs](https://www.markdown.xyz/extended-syntax#heading-ids)</code>）。</p><h2 id="定义列表（Definition-Lists）"><a href="#定义列表（Definition-Lists）" class="headerlink" title="定义列表（Definition Lists）"></a>定义列表（Definition Lists）</h2><p>某些 Markdown 解析器允许你创建术语（terms）及其相应的定义（definitions）的列表，即 <em>定义列表（definition lists）</em>。要创建定义列表，请在第一行键入术语，然后在下一行中键入冒号，冒号后跟着空格和此术语的具体定义。</p><pre class="line-numbers language-none"><code class="language-none">First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的 HTML 如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;  &lt;dt&gt;First Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is the definition of the first term.&lt;&#x2F;dd&gt;  &lt;dt&gt;Second Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is one definition of the second term. &lt;&#x2F;dd&gt;  &lt;dd&gt;This is another definition of the second term.&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><ul><li><p>First Term</p><p>This is the definition of the first term.</p></li><li><p>Second Term</p><p>This is one definition of the second term.</p><p>This is another definition of the second term.</p></li></ul><h2 id="删除线（Strikethrough）"><a href="#删除线（Strikethrough）" class="headerlink" title="删除线（Strikethrough）"></a>删除线（Strikethrough）</h2><p>你可以贯穿单词的中心放一条横线从而删除这些单词。其效果看起来是这样的： <del>like this</del>。此功能允许你标记某些单词是错误的，不应该出现在文档中。在单词前面和后面分别放置两个波浪号（<code>~~</code>） 来表示删除这些单词。</p><pre class="line-numbers language-none"><code class="language-none">~~The world is flat.~~ We now know that the world is round.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><p><del>The world is flat.</del> We now know that the world is round.</p><h2 id="任务列表（Task-Lists）"><a href="#任务列表（Task-Lists）" class="headerlink" title="任务列表（Task Lists）"></a>任务列表（Task Lists）</h2><p>任务列表（task lists 或者 checklists）允许你创建带有复选框的项目列表。在支持任务列表的 Markdown 应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项前面添加破折号（<code>-</code>）和中间带空格的方括号（<code>[ ]</code>）。要选中复选框，请在方括号中间添加一个 <code>x</code> ，即（<code>[x]</code>）。</p><pre class="line-numbers language-none"><code class="language-none">- [x] Write the press release- [ ] Update the website- [ ] Contact the media<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p><img src="https://www.markdown.xyz/assets/images/tasklist.png" alt="Markdown task list"></p><h2 id="表情符号（Emoji）"><a href="#表情符号（Emoji）" class="headerlink" title="表情符号（Emoji）"></a>表情符号（Emoji）</h2><p>有两种方式可以将表情符号添加到 Markdown 文档中：将表情符号复制并粘贴到 Markdown 格式的文本中，或者键入 <em>表情符号的简码（emoji shortcodes）</em>。</p><h3 id="复制并粘贴表情符号"><a href="#复制并粘贴表情符号" class="headerlink" title="复制并粘贴表情符号"></a>复制并粘贴表情符号</h3><p>在大多数情况下，你可以简单地从 <a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号，然后将其粘贴到文档中。许多 Markdown 应用程序就会自动以 Markdown 格式的文本来显示表情符号。从 Markdown 应用程序导出的 HTML 和 PDF 文件也是可以显示表情符号的。</p><p><strong>提示：</strong> 如果你使用的是静态站点生成器，请确保 <a href="https://www.w3.org/International/tutorials/tutorial-char-enc/">HTML 页面的字符编码为 UTF-8</a>。</p><h3 id="使用表情符号的简码（Shortcodes）"><a href="#使用表情符号的简码（Shortcodes）" class="headerlink" title="使用表情符号的简码（Shortcodes）"></a>使用表情符号的简码（Shortcodes）</h3><p>某些 Markdown 应用程序允许你通过键入表情符号的简码（shortcodes）来插入表情符号。简码以冒号开头和结尾，两个冒号中间是表情符号的名称。</p><pre class="line-numbers language-none"><code class="language-none">Gone camping! :tent: Be back soon.That is so funny! :joy:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p>Gone camping! ⛺ Be back soon.</p><p>That is so funny! 😂</p><p><strong>注意：</strong> 你可以使用这个 <a href="https://gist.github.com/rxaviers/7360908">表情符号简码列表</a>，但请记住，表情符号的简码随着 Markdown 应用程序的不同而不同。有关详细信息，请参阅你所使用的 Markdown 应用程序的文档。</p><h2 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight"></a>Highlight</h2><p>This isn’t common, but some Markdown processors allow you to highlight text. The result looks like this. To highlight words, use two equal signs (<code>==</code>) before and after the words.</p><pre class="line-numbers language-none"><code class="language-none">I need to highlight these &#x3D;&#x3D;very important words&#x3D;&#x3D;.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">I need to highlight these &lt;mark&gt;very important words&lt;&#x2F;mark&gt;.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>I need to highlight these very important words.</p><h2 id="Subscript"><a href="#Subscript" class="headerlink" title="Subscript"></a>Subscript</h2><p>This isn’t common, but some Markdown processors allow you to use <em>subscript</em> to position one or more characters slightly below the normal line of type. To create a subscript, use one tilde symbol (<code>~</code>) before and after the characters.</p><pre class="line-numbers language-none"><code class="language-none">H~2~O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">H&lt;sub&gt;2&lt;&#x2F;sub&gt;O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>H2O</p><p><strong>Tip:</strong> Be sure to test this feature in your Markdown application before using it. Some Markdown applications use one tilde symbol before and after words not for subscript, but for <a href="https://www.markdown.xyz/extended-syntax/#strikethrough">strikethrough</a>.</p><h2 id="Superscript"><a href="#Superscript" class="headerlink" title="Superscript"></a>Superscript</h2><p>This isn’t common, but some Markdown processors allow you to use <em>superscript</em> to position one or more characters slightly above the normal line of type. To create a superscript, use one caret symbol (<code>^</code>) before and after the characters.</p><pre class="line-numbers language-none"><code class="language-none">X^2^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">X&lt;sup&gt;2&lt;&#x2F;sup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>X2</p><h2 id="自动将-URL-转换为链接"><a href="#自动将-URL-转换为链接" class="headerlink" title="自动将 URL 转换为链接"></a>自动将 URL 转换为链接</h2><p>许多 Markdown 解析器会自动将 URL 转换为链接。这意味着，即使你没有 <a href="https://www.markdown.xyz/basic-syntax/#links">使用中括号</a>，如果你输入 <a href="http://www.example.com，你的">http://www.example.com，你的</a> Markdown 解析器也会自动将其转换为链接。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><p><a href="http://www.example.com/">http://www.example.com</a></p><h2 id="禁止自动将-URL-转换为链接"><a href="#禁止自动将-URL-转换为链接" class="headerlink" title="禁止自动将 URL 转换为链接"></a>禁止自动将 URL 转换为链接</h2><p>如果你不希望自动将 URL 转换为链接，则可以通过反引号 <a href="https://www.markdown.xyz/basic-syntax/#code">将 URL 表示为代码</a> 。</p><pre class="line-numbers language-none"><code class="language-none">&#96;http:&#x2F;&#x2F;www.example.com&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2022/05/25/markdown-ji-ben-yu-fa/"/>
      <url>/2022/05/25/markdown-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.markdown.xyz/basic-syntax/">原文链接</a></p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>几乎所有 Markdown 应用程序都支持 John Gruber 原始设计文档中列出的 Markdown 基本语法。但是，Markdown 处理程序之间存在着细微的变化和差异，我们都会尽可能标记出来。</p><h2 id="标题（Headings）"><a href="#标题（Headings）" class="headerlink" title="标题（Headings）"></a>标题（Headings）</h2><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。井号的数量代表了标题的级别。例如，添加三个井号即创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code># Heading level 1</code></td><td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td>Heading level 1</td></tr><tr><td><code>## Heading level 2</code></td><td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td>Heading level 2</td></tr><tr><td><code>### Heading level 3</code></td><td><code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code></td><td>Heading level 3</td></tr><tr><td><code>#### Heading level 4</code></td><td><code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code></td><td>Heading level 4</td></tr><tr><td><code>##### Heading level 5</code></td><td><code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code></td><td>Heading level 5</td></tr><tr><td><code>###### Heading level 6</code></td><td><code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code></td><td>Heading level 6</td></tr></tbody></table></div><h3 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h3><p>还可以在文本下方添加任意数量的 <code>==</code> 号来标识一级标题，或者 <code>--</code> 号来标识二级标题。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Heading level 1===============</code></td><td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td>Heading level 1</td></tr><tr><td><code>Heading level 2---------------</code></td><td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td>Heading level 2</td></tr></tbody></table></div><h3 id="标题（Heading）用法的最佳实践"><a href="#标题（Heading）用法的最佳实践" class="headerlink" title="标题（Heading）用法的最佳实践"></a>标题（Heading）用法的最佳实践</h3><p>当井号（<code>#</code>）和标题文本之间没有空格时，各 Markdown 应用程序的处理方式是不一样的。为了兼容考虑，请在井号和标题文本之间添加一个空格。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code># Here&#39;s a Heading</code></td><td><code>#Here&#39;s a Heading</code></td></tr></tbody></table></div><p>You should also put blank lines before and after a heading for compatibility.</p><div class="table-container"><table><thead><tr><th>✅ Do this</th><th>❌ Don’t do this</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...# Heading...and after a heading.</code></td><td><code>Without blank lines, this might not look right.# HeadingDon&#39;t do this!</code></td></tr></tbody></table></div><h2 id="段落（Paragraphs）"><a href="#段落（Paragraphs）" class="headerlink" title="段落（Paragraphs）"></a>段落（Paragraphs）</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>I really like using Markdown.I think I&#39;ll use it to format all of my documents from now on.</code></td><td><code>&lt;p&gt;I really like using Markdown.&lt;/p&gt;&lt;p&gt;I think I&#39;ll use it to format all of my documents from now on.&lt;/p&gt;</code></td><td>I really like using Markdown.I think I’ll use it to format all of my documents from now on.</td></tr></tbody></table></div><h3 id="段落（Paragraph）用法的最佳实践"><a href="#段落（Paragraph）用法的最佳实践" class="headerlink" title="段落（Paragraph）用法的最佳实践"></a>段落（Paragraph）用法的最佳实践</h3><p>除非 <a href="https://www.markdown.xyz/basic-syntax/#paragraphs">段落在列表中</a>，否则不要用空格（spaces）或制表符（ tabs）缩进段落。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Don&#39;t put tabs or spaces in front of your paragraphs.Keep lines left-aligned like this.</code></td><td><code>This can result in unexpected formatting problems. Don&#39;t add tabs or spaces in front of paragraphs.</code></td></tr></tbody></table></div><h2 id="换行（Line-Breaks）"><a href="#换行（Line-Breaks）" class="headerlink" title="换行（Line Breaks）"></a>换行（Line Breaks）</h2><p>在一行的末尾添加两个或多个空格，然后按回车键（return），即可创建一个换行（line break）或新行 (<code>&lt;br&gt;</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>This is the first line.  And this is the second line.</code></td><td><code>&lt;p&gt;This is the first line.&lt;br&gt;And this is the second line.&lt;/p&gt;</code></td><td>This is the first line. And this is the second line.</td></tr></tbody></table></div><h3 id="换行（Line-Break）用法的最佳实践"><a href="#换行（Line-Break）用法的最佳实践" class="headerlink" title="换行（Line Break）用法的最佳实践"></a>换行（Line Break）用法的最佳实践</h3><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行 (称为 “结尾空格（trailing whitespace）”) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能需要使用除结尾空格以外的其它方式来进行换行。如果你所使用的 Markdown 应用程序 <a href="https://www.markdown.xyz/basic-syntax/#html">支持 HTML</a> 的话，你可以使用 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (<code>\</code>) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（ return）即可实现换行。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>First line with two spaces after.  And the next line.First line with the HTML tag after.&lt;br&gt;And the next line.</code></td><td><code>First line with a backslash after.\And the next line.First line with nothing after.And the next line.</code></td></tr></tbody></table></div><h2 id="强调（Emphasis）"><a href="#强调（Emphasis）" class="headerlink" title="强调（Emphasis）"></a>强调（Emphasis）</h2><p>通过将文本设置为粗体或斜体来强调其重要性。</p><h3 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>I just love **bold text**.</code></td><td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td><td>I just love <strong>bold text</strong>.</td></tr><tr><td><code>I just love __bold text__.</code></td><td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td><td>I just love <strong>bold text</strong>.</td></tr><tr><td><code>Love**is**bold</code></td><td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td><td>Love<strong>is</strong>bold</td></tr></tbody></table></div><h4 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="粗体（Bold）用法最佳实践"></a>粗体（Bold）用法最佳实践</h4><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Love**is**bold</code></td><td><code>Love__is__bold</code></td></tr></tbody></table></div><h3 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Italicized text is the *cat&#39;s meow*.</code></td><td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td><td>Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td><code>Italicized text is the _cat&#39;s meow_.</code></td><td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td><td>Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td><code>A*cat*meow</code></td><td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td><td>A<em>cat</em>meow</td></tr></tbody></table></div><h4 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="斜体（Italic）用法的最佳实践"></a>斜体（Italic）用法的最佳实践</h4><p>Markdown 的众多应用程序在如何处理单词中间的下划线上意见不一致。为了兼容起见，请用星号标注单词中间的斜体来表示着重。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>A*cat*meow</code></td><td><code>A_cat_meow</code></td></tr></tbody></table></div><h3 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>This text is ***really important***.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is ___really important___.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is __*really important*__.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is **_really important_**.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This is really***very***important text.</code></td><td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td><td>This is really<strong><em>very\</em></strong>important text.</td></tr></tbody></table></div><h4 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="粗体（Bold）和斜体（Italic）用法的最佳实践"></a>粗体（Bold）和斜体（Italic）用法的最佳实践</h4><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>This is really***very***important text.</code></td><td><code>This is really___very___important text.</code></td></tr></tbody></table></div><h2 id="块引用（Blockquotes）"><a href="#块引用（Blockquotes）" class="headerlink" title="块引用（Blockquotes）"></a>块引用（Blockquotes）</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h3 id="多个段落的块引用（Blockquotes）"><a href="#多个段落的块引用（Blockquotes）" class="headerlink" title="多个段落的块引用（Blockquotes）"></a>多个段落的块引用（Blockquotes）</h3><p>块引用可以包含多个段落。为段落之间的空白行各添加一个 <code>&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="嵌套块引用（Nested-Blockquotes）"><a href="#嵌套块引用（Nested-Blockquotes）" class="headerlink" title="嵌套块引用（Nested Blockquotes）"></a>嵌套块引用（Nested Blockquotes）</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h3 id="带有其它元素的块引用（Blockquotes-with-Other-Elements）"><a href="#带有其它元素的块引用（Blockquotes-with-Other-Elements）" class="headerlink" title="带有其它元素的块引用（Blockquotes with Other Elements）"></a>带有其它元素的块引用（Blockquotes with Other Elements）</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><pre class="line-numbers language-none"><code class="language-none">&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt;  *Everything* is going according to **plan**.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h3 id="Blockquotes-Best-Practices"><a href="#Blockquotes-Best-Practices" class="headerlink" title="Blockquotes Best Practices"></a>Blockquotes Best Practices</h3><p>For compatibility, put blank lines before and after blockquotes.</p><div class="table-container"><table><thead><tr><th>✅ Do this</th><th>❌ Don’t do this</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...&gt; This is a blockquote...and after a blockquote.</code></td><td><code>Without blank lines, this might not look right.&gt; This is a blockquoteDon&#39;t do this!</code></td></tr></tbody></table></div><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>你可以将多个条目组织成有序或无序列表。</p><h3 id="有序列表（Ordered-Lists）"><a href="#有序列表（Ordered-Lists）" class="headerlink" title="有序列表（Ordered Lists）"></a>有序列表（Ordered Lists）</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>1. First item2. Second item3. Third item4. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item1. Second item1. Third item1. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item8. Second item3. Third item5. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item2. Second item3. Third item  1. Indented item  2. Indented item4. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item  &lt;ol&gt;   &lt;li&gt;Indented item&lt;/li&gt;   &lt;li&gt;Indented item&lt;/li&gt;  &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td></tr></tbody></table></div><h4 id="有序列表（Ordered-List）用法的最佳实践"><a href="#有序列表（Ordered-List）用法的最佳实践" class="headerlink" title="有序列表（Ordered List）用法的最佳实践"></a>有序列表（Ordered List）用法的最佳实践</h4><p>CommonMark 和其它几种轻量级标记语言可以让你使用括号（<code>)</code>）作为分隔符（例如 <code>1) First item</code>），但并非所有的 Markdown 应用程序都支持此种用法，因此，从兼容的角度来看，此用法不推荐。为了兼容起见，请只使用英文句点作为分隔符。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>1. First item2. Second item</code></td><td><code>1) First item2) Second item</code></td></tr></tbody></table></div><h3 id="无序列表（Unordered-Lists）"><a href="#无序列表（Unordered-Lists）" class="headerlink" title="无序列表（Unordered Lists）"></a>无序列表（Unordered Lists）</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (<code>-</code>)、星号 (<code>*</code>) 或加号 (<code>+</code>) 。缩进一个或多个列表项可创建嵌套列表。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>- First item- Second item- Third item- Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>* First item* Second item* Third item* Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>+ First item+ Second item+ Third item+ Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>- First item- Second item- Third item  - Indented item  - Indented item- Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item  &lt;ul&gt;   &lt;li&gt;Indented item&lt;/li&gt;   &lt;li&gt;Indented item&lt;/li&gt;  &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td></tr></tbody></table></div><h4 id="以数字开头的无序列表项"><a href="#以数字开头的无序列表项" class="headerlink" title="以数字开头的无序列表项"></a>以数字开头的无序列表项</h4><p>如果你需要以数字开头并且紧跟一个英文句号（也就是 <code>.</code>）的无序列表项，则可以使使用反斜线（<code>\</code>）来 <a href="https://www.markdown.xyz/basic-syntax/#escaping-characters">转义</a> 这个英文句号。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>- 1968\. A great year!- I think 1969 was second best.</code></td><td><code>&lt;ul&gt; &lt;li&gt;1968. A great year!&lt;/li&gt; &lt;li&gt;I think 1969 was second best.&lt;/li&gt;&lt;/ul&gt;</code></td><td>1968. A great year!I think 1969 was second best.</td></tr></tbody></table></div><h4 id="无序列表（Unordered-List）用法的最佳实践"><a href="#无序列表（Unordered-List）用法的最佳实践" class="headerlink" title="无序列表（Unordered List）用法的最佳实践"></a>无序列表（Unordered List）用法的最佳实践</h4><p>Markdown 应用程序在如何处理同一列表中混用不同分隔符上并不一致。为了兼容起见，请不要在同一个列表中混用不同的分隔符，最好选定一种分隔符并一直用下去。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>- First item- Second item- Third item- Fourth item</code></td><td><code>+ First item* Second item- Third item+ Fourth item</code></td></tr></tbody></table></div><h3 id="在列表中添加列表项"><a href="#在列表中添加列表项" class="headerlink" title="在列表中添加列表项"></a>在列表中添加列表项</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><p><strong>Tip:</strong> If things don’t appear the way you expect, double check that you’ve indented the elements in the list four spaces or one tab.</p><h4 id="段落（Paragraphs）-1"><a href="#段落（Paragraphs）-1" class="headerlink" title="段落（Paragraphs）"></a>段落（Paragraphs）</h4><pre class="line-numbers language-none"><code class="language-none">* This is the first list item.* Here&#39;s the second list item.    I need to add another paragraph below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块（Blockquotes）"><a href="#引用块（Blockquotes）" class="headerlink" title="引用块（Blockquotes）"></a>引用块（Blockquotes）</h4><pre class="line-numbers language-none"><code class="language-none">* This is the first list item.* Here&#39;s the second list item.    &gt; A blockquote would look great below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块（Code-Blocks）"><a href="#代码块（Code-Blocks）" class="headerlink" title="代码块（Code Blocks）"></a>代码块（Code Blocks）</h4><p><a href="https://www.markdown.xyz/basic-syntax/#code-blocks">代码块（Code blocks）</a> 通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><pre class="line-numbers language-none"><code class="language-none">1. Open the file.2. Find the following code block on line 21:        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;Test&lt;&#x2F;title&gt;          &lt;&#x2F;head&gt;3. Update the title to match the name of your website.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li><p>Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Test&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Update the title to match the name of your website.</p></li></ol><h4 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h4><pre class="line-numbers language-none"><code class="language-none">1. Open the file containing the Linux mascot.2. Marvel at its beauty.    ![Tux, the Linux mascot](&#x2F;assets&#x2F;images&#x2F;tux.png)3. Close the file.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li><p>Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><p><img src="https://www.markdown.xyz/assets/images/tux.png" alt="Tux, the Linux mascot"></p></li><li><p>Close the file.</p></li></ol><h4 id="列表（Lists）-1"><a href="#列表（Lists）-1" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h4><p>你可以将无序列表嵌套在有序列表中，反之亦然。</p><pre class="line-numbers language-none"><code class="language-none">1. First item2. Second item3. Third item    - Indented item    - Indented item4. Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (```) 中。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>At the command prompt, type</code>nano<code>.</code></td><td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td><td>At the command prompt, type <code>nano</code>.</td></tr></tbody></table></div><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Use `code` in your Markdown file.</code></td><td><code>&lt;code&gt;Use</code>code<code>in your Markdown file.&lt;/code&gt;</code></td><td><code>Use</code>code<code>in your Markdown file.</code></td></tr></tbody></table></div><h3 id="代码块（Code-Blocks）-1"><a href="#代码块（Code-Blocks）-1" class="headerlink" title="代码块（Code Blocks）"></a>代码块（Code Blocks）</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;  &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;  &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 要创建不用缩进的代码块，请使用 <a href="https://www.markdown.xyz/extended-syntax/#fenced-code-blocks">围栏式代码块（fenced code blocks）</a>.</p><h2 id="分隔线（Horizontal-Rules）"><a href="#分隔线（Horizontal-Rules）" class="headerlink" title="分隔线（Horizontal Rules）"></a>分隔线（Horizontal Rules）</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><pre class="line-numbers language-none"><code class="language-none">***---_________________<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上三个分隔线的渲染效果看起来都一样：</p><hr><h3 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="分隔线（Horizontal Rule）用法最佳实践"></a>分隔线（Horizontal Rule）用法最佳实践</h3><p>为了兼容性，请在分隔线的前后均添加空白行。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...---...and after a horizontal rule.</code></td><td><code>Without blank lines, this would be a heading.---Don&#39;t do this!</code></td></tr></tbody></table></div><h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>要创建链接，请将链接文本括在方括号（例如 <code>[Duck Duck Go]</code>）中，后面紧跟着括在圆括号中的 URL（例如 <code>(https://duckduckgo.com)</code> ）。</p><pre class="line-numbers language-none"><code class="language-none">My favorite search engine is [Duck Duck Go](https:&#x2F;&#x2F;duckduckgo.com).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>My favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a>.</p><p><strong>Note:</strong> To link to an element on the same page, see <a href="https://www.markdown.xyz/extended-syntax/#linking-to-heading-ids">linking to heading IDs</a>.</p><h3 id="添加标题"><a href="#添加标题" class="headerlink" title="添加标题"></a>添加标题</h3><p>你可以选择为链接添加标题（即 title 属性）。当用户将鼠标悬停在链接上时，将显示一个提示。要添加标题，请将其放在 URL 后面。</p><pre class="line-numbers language-none"><code class="language-none">My favorite search engine is [Duck Duck Go](https:&#x2F;&#x2F;duckduckgo.com &quot;The best search engine for privacy&quot;).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>My favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a>.</p><h3 id="网址和电子邮件地址"><a href="#网址和电子邮件地址" class="headerlink" title="网址和电子邮件地址"></a>网址和电子邮件地址</h3><p>要将 URL 或电子邮件地址快速转换为链接，请将其括在尖括号中。</p><pre class="line-numbers language-none"><code class="language-none">&lt;https:&#x2F;&#x2F;www.markdownguide.org&gt;&lt;fake@example.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>渲染效果如下：</p><p><a href="https://www.markdownguide.org/">https://www.markdownguide.org</a><br><a href="mailto:fake@example.com">fake@example.com</a></p><h3 id="格式化链接"><a href="#格式化链接" class="headerlink" title="格式化链接"></a>格式化链接</h3><p>如需 <a href="https://www.markdown.xyz/basic-syntax/#emphasis">强调（emphasize）</a> 某个链接, 请在方括号前及圆括号后添加星号。要将链接表示为 <a href="https://www.markdown.xyz/basic-syntax/#code">代码（code）</a> ，请在方括号内添加反引号。</p><pre class="line-numbers language-none"><code class="language-none">I love supporting the **[EFF](https:&#x2F;&#x2F;eff.org)**.This is the *[Markdown Guide](https:&#x2F;&#x2F;www.markdownguide.org)*.See the section on [&#96;code&#96;](#code).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="https://www.markdown.xyz/basic-syntax/#code"><code>code</code></a>.</p><h3 id="引用式链接"><a href="#引用式链接" class="headerlink" title="引用式链接"></a>引用式链接</h3><p>引用式（Reference-style）链接是一种特殊类型的链接，它使得 URL 在 Markdown 中更易于显示和阅读。引用式链接由两部分组成：一部分被放置在正文文本中；另一部分被放置在文档中的其它地方，以便于阅读。</p><h4 id="引用式链接第一部分的格式"><a href="#引用式链接第一部分的格式" class="headerlink" title="引用式链接第一部分的格式"></a>引用式链接第一部分的格式</h4><p>引用式链接的第一部分的格式由两组方括号组成。第一组方括号内放的是显示为链接的文本，第二组方括号内放的是一个标签，该标签用于指向您存放在文档中其它位置的链接。</p><p>尽管不是必须的，但你可以在第一组和第二组方括号之间添加一个空格。第二组方括号中的标签不区分大小写，并且可以包含字母、数字、空格或标点符号。</p><p>以下示例中，链接的第一部分是等效的：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="引用式链接第二部分的格式"><a href="#引用式链接第二部分的格式" class="headerlink" title="引用式链接第二部分的格式"></a>引用式链接第二部分的格式</h4><p>引用式链接的第二部分可以包含以下属性：</p><ol><li>放在方括号内的标签，以及紧跟在方括号后面的一个冒号和至少一个空格（例如 <code>[label]:</code>）。</li><li>链接的 URL，可以选择将其括在尖括号内。</li><li>链接的标题（可有可无），可以将其括在双引号、单引号或括号内。</li></ol><p>以下示例中，链接的第二部分是等效的：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在 Markdown 文档中的任何位置。有些人将它们放在被引用的段落的后面，有些人将它们放在文档的末尾（类似尾注或脚注）。</p><h4 id="将两部分组合在一起使用的示例"><a href="#将两部分组合在一起使用的示例" class="headerlink" title="将两部分组合在一起使用的示例"></a>将两部分组合在一起使用的示例</h4><p>假设你将一个 URL 作为一个 <a href="https://www.markdown.xyz/basic-syntax/#links">标准 URL 链接</a> 添加到段落中，在 Markdown 中如下所示：</p><pre class="line-numbers language-none"><code class="language-none">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;), and that means comfort.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Though it may point to interesting additional information, the URL as displayed really doesn’t add much to the existing raw text other than making it harder to read. To fix that, you could format the URL like this instead:</p><pre class="line-numbers language-none"><code class="language-none">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole][1], and that means comfort.[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述两个实例中，渲染后的输出是相同的：</p><blockquote><p>In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it was a <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">hobbit-hole</a>, and that means comfort.</p></blockquote><p>该链接的 HTML 为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&quot; title&#x3D;&quot;Hobbit lifestyles&quot;&gt;hobbit-hole&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="链接（Link）的最佳使用实践"><a href="#链接（Link）的最佳使用实践" class="headerlink" title="链接（Link）的最佳使用实践"></a>链接（Link）的最佳使用实践</h3><p>不同的 Markdown 应用程序在处理 URL 中间的空格方面是不一样的。为了兼容起见，请尽量使用 <code>%20</code> （空格的编码形式）来代替空格。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>[link](https://www.example.com/my%20great%20page)</code></td><td><code>[link](https://www.example.com/my great page)</code></td></tr></tbody></table></div><h2 id="图片（Images）-1"><a href="#图片（Images）-1" class="headerlink" title="图片（Images）"></a>图片（Images）</h2><p>要添加图片，首先请添加感叹号（<code>!</code>），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。</p><pre class="line-numbers language-none"><code class="language-none">![The San Juan Mountains are beautiful!](&#x2F;assets&#x2F;images&#x2F;san-juan-mountains.jpg &quot;San Juan Mountains&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p><img src="https://www.markdown.xyz/assets/images/san-juan-mountains.jpg" alt="The San Juan Mountains are beautiful!"></p><h3 id="带链接的图片"><a href="#带链接的图片" class="headerlink" title="带链接的图片"></a>带链接的图片</h3><p>要为图片添加链接，请先为图片的 Markdown 标记添加一个方括号，然后紧跟着一个圆括号，并在圆括号中添加链接地址。</p><pre class="line-numbers language-none"><code class="language-none">[![An old rock in the desert](&#x2F;assets&#x2F;images&#x2F;shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https:&#x2F;&#x2F;www.flickr.com&#x2F;photos&#x2F;beaurogers&#x2F;31833779864&#x2F;in&#x2F;photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p><a href="https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv"><img src="https://www.markdown.xyz/assets/images/shiprock.jpg" alt="An old rock in the desert"></a></p><h2 id="转义字符（Escaping-Characters）"><a href="#转义字符（Escaping-Characters）" class="headerlink" title="转义字符（Escaping Characters）"></a>转义字符（Escaping Characters）</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 (<code>\</code>) 。</p><pre class="line-numbers language-none"><code class="language-none">\* 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>* 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。</p><h3 id="可做转义的（英文）字符"><a href="#可做转义的（英文）字符" class="headerlink" title="可做转义的（英文）字符"></a>可做转义的（英文）字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><div class="table-container"><table><thead><tr><th>字符</th><th>名称</th></tr></thead><tbody><tr><td>\</td><td>反斜杠（backslash）</td></tr><tr><td>`</td><td>backtick (另请参见 <a href="https://www.markdown.xyz/basic-syntax/#escaping-backticks">在代码中转义反引号</a>)</td></tr><tr><td>*</td><td>星号（asterisk）</td></tr><tr><td>_</td><td>下划线（underscore）</td></tr><tr><td>{ }</td><td>花括号（curly braces）</td></tr><tr><td>[ ]</td><td>方括号（brackets）</td></tr><tr><td>&lt; &gt;</td><td>angle brackets</td></tr><tr><td>( )</td><td>圆括号或括号（parentheses）</td></tr><tr><td>#</td><td>井号（pound sign）</td></tr><tr><td>+</td><td>加号（plus sign）</td></tr><tr><td>-</td><td>减号（minus sign） (也叫连字符 hyphen)</td></tr><tr><td>.</td><td>句点（dot）</td></tr><tr><td>!</td><td>感叹号（exclamation mark）</td></tr><tr><td>\</td><td></td><td>管道符（pipe） (另请参见 <a href="https://www.markdown.xyz/extended-syntax/#escaping-pipe-characters-in-tables">在表格中转义管道符</a>)</td></tr></tbody></table></div><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>大多 Markdown 应用程序允许你在 Markdown 格式文本中添加 HTML 标签。如果你喜欢某些 HTML 标签胜于 Markdown 语法的话，这将何有帮助。例如，某些人发现通过 HTML 标签添加图像更加容易。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>如需使用 HTML，请将 HTML 标签添加到 Markdown 格式文本中即可。</p><pre class="line-numbers language-none"><code class="language-none">This **word** is bold. This &lt;em&gt;word&lt;&#x2F;em&gt; is italic.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="HTML-用法最佳实践"><a href="#HTML-用法最佳实践" class="headerlink" title="HTML 用法最佳实践"></a>HTML 用法最佳实践</h3><p>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看 Markdown 应用程序的文档。某些应用程序只支持 HTML 标签的子集。</p><p>对于 HTML 的块级元素 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code> 和 <code>&lt;p&gt;</code>，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。</p><p>在 HTML 块级标签内不能使用 Markdown 语法。例如 <code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node—RED 启用使用身份认证登录</title>
      <link href="/2022/05/24/node-red-qi-yong-shi-yong-shen-fen-ren-zheng-deng-lu/"/>
      <url>/2022/05/24/node-red-qi-yong-shi-yong-shen-fen-ren-zheng-deng-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Node-RED 预设是无帐号与密码的，因此若建立在公开的伺服器上就是不安全的，任何人都可以透过 IP 或网域连上平台，且直接修改及部属编辑器上的节点，因此我们要运用其内建的使用者身分验证机制来保护平台的资讯安全。</p></blockquote><h3 id="编辑器和管理员-API-安全性"><a href="#编辑器和管理员-API-安全性" class="headerlink" title="编辑器和管理员 API 安全性"></a>编辑器和管理员 API 安全性</h3><p><strong>Editor</strong> 和 <strong>Admin API</strong> 支持两种类型的身份验证：</p><ul><li>基于用户名/密码凭据的身份验证</li><li>针对任何 OAuth/OpenID 提供者（例如 Twitter 或 GitHub）进行身份验证<h3 id="基于用户名-密码的身份验证"><a href="#基于用户名-密码的身份验证" class="headerlink" title="基于用户名/密码的身份验证"></a>基于用户名/密码的身份验证</h3></li></ul><p>要在 Editor 和 Admin API 上启用用户身份验证，请取消注释<em>设置文件</em><strong>adminAuth</strong> 中的属性：<br><pre class="line-numbers language-json" data-language="json"><code class="language-json">adminAuth: &#123;    type: &quot;credentials&quot;,    users: [        &#123;            username: &quot;admin&quot;,            password: &quot;$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.&quot;,            permissions: &quot;*&quot;        &#125;,        &#123;            username: &quot;george&quot;,            password: &quot;$2b$08$wuAqPiKJlVN27eF5qJp.RuQYuy6ZYONW7a&#x2F;UWYxDTtwKFCdB8F19y&quot;,            permissions: &quot;read&quot;        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该<em>users</em>属性是一个用户对象数组。这允许您定义多个用户，每个用户都可以拥有不同的权限。</p><p>上面的这个示例配置定义了两个用户。一个被称为<em>admin</em>有权在编辑器内执行所有操作且密码为<em>password</em>. 另一个调用<em>george</em> who 被授予只读访问权限。</p><p>请注意，密码是使用 bcrypt 算法安全地散列的。</p><blockquote><p>注意：在以前的 Node-RED 版本中，该设置httpAdminAuth 可用于在编辑器上启用 HTTP 基本身份验证。此选项已弃用，不应使用。</p></blockquote><h3 id="生成密码哈希"><a href="#生成密码哈希" class="headerlink" title="生成密码哈希"></a>生成密码哈希</h3><p>如果您使用的是 Node-RED 1.1.0 或更高版本，则可以使用以下命令：</p><p><code>node-red admin hash-pw</code></p><p>对于旧版本的 Node-RED，您可以：</p><ul><li>安装单独的node-red-admin命令行工具并使用以下命令：<br>  <code>node-red-admin hash-pw</code></li><li><p>或者，找到 Node-RED 的安装目录并使用以下命令：</p><p>  <code>node -e &quot;console.log(require(&#39;bcryptjs&#39;).hashSync(process.argv[1], 8));&quot; your-password-here</code></p></li></ul><p>在所有情况下，您都会取回密码的散列版本，然后您可以将其粘贴到您的设置文件中。</p><h3 id="Where-is-my-settings-file"><a href="#Where-is-my-settings-file" class="headerlink" title="Where is my settings file?"></a>Where is my settings file?</h3>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何取得舊版 macOS</title>
      <link href="/2022/05/23/ru-he-qu-de-jiu-ban-macos/"/>
      <url>/2022/05/23/ru-he-qu-de-jiu-ban-macos/</url>
      
        <content type="html"><![CDATA[<p>如果您的 Mac 與最新版 macOS 不相容，您可以升級到舊版 macOS，例如 macOS Big Sur、Catalina、Mojave 或 High Sierra。</p><p>若要取得最新功能，並維護 Mac 的安全性、穩定性、相容性與效能，請務必讓軟體保持最新狀態。Apple 建議您一律使用與 Mac 相容的最新版 macOS。</p><p><a href="https://support.apple.com/zh-tw/HT212735">了解如何升級為 macOS Monterey</a>（最新版 macOS）。</p><h2 id="檢查相容性"><a href="#檢查相容性" class="headerlink" title="檢查相容性"></a>檢查相容性</h2><p>Mac 隨附的 macOS 版本是其可以使用的最早版本。例如，如果 Mac 隨附 macOS Big Sur，則不能使用 macOS Catalina 或之前版本。如果 macOS 與裝置不相容，App Store 或安裝程式會告知您。如果您嘗試安裝比目前安裝版本更舊的 macOS，安裝程式會指出此版本的 macOS 太舊，無法在這一版的 macOS 中打開。</p><ul><li>macOS Big Sur 11 <a href="https://support.apple.com/zh-tw/HT211238">硬體需求</a></li><li>macOS Catalina 10.15 <a href="https://support.apple.com/zh-tw/HT210222">硬體需求</a></li><li>macOS Mojave 10.14 <a href="https://support.apple.com/kb/SP777?locale=zh_TW">硬體需求</a></li><li>macOS High Sierra 10.13 <a href="https://support.apple.com/kb/SP765?locale=zh_TW">硬體需求</a></li><li>macOS Sierra 10.12 <a href="https://support.apple.com/kb/SP742?locale=zh_TW">硬體需求</a></li><li>OS X El Capitan 10.11 <a href="https://support.apple.com/kb/SP728?locale=zh_TW">硬體需求</a></li><li>OS X Yosemite 10.10 <a href="https://support.apple.com/kb/SP711?locale=zh_TW">硬體需求</a></li></ul><hr><h2 id="製作備份"><a href="#製作備份" class="headerlink" title="製作備份"></a>製作備份</h2><p>安裝任何升級程式之前，最好先<a href="https://support.apple.com/zh-tw/HT201250">備份 Mac</a>。「時光機」可協助您輕鬆備份，而您也可以採取其他備份方法。</p><hr><h2 id="在-Mac-上使用-Safari-下載-macOS"><a href="#在-Mac-上使用-Safari-下載-macOS" class="headerlink" title="在 Mac 上使用 Safari 下載 macOS"></a>在 Mac 上使用 Safari 下載 macOS</h2><p>Safari 會利用這些連結在 App Store 中尋找舊版安裝程式。從 App Store 下載安裝程式後，安裝程式會自動打開。</p><ul><li><a href="macappstores://apps.apple.com/tw/app/macos-big-sur/id1526878132?mt=12">macOS Big Sur</a> 可以升級 Catalina、Mojave、High Sierra、Sierra、El Capitan、Yosemite、Mavericks</li><li><a href="macappstores://apps.apple.com/tw/app/macos-catalina/id1466841314?mt=12">macOS Catalina</a> 可以升級 Mojave、High Sierra、Sierra、El Capitan、Yosemite、Mavericks</li><li><a href="macappstores://apps.apple.com/tw/app/macos-mojave/id1398502828?mt=12">macOS Mojave</a> 可以升級 High Sierra、Sierra、El Capitan、Yosemite、Mavericks、Mountain Lion</li><li><a href="macappstores://apps.apple.com/tw/app/macos-high-sierra/id1246284741?mt=12">macOS High Sierra</a> 可以升級 Sierra、El Capitan、Yosemite、Mavericks、Mountain Lion</li></ul><p>Safari 會以名為 InstallOS.dmg 或 InstallMacOSX.dmg 的磁碟映像檔的形式，來下載以下舊版安裝程式。請開啟磁碟映像檔，然後開啟其中的 .pkg 安裝程式。它會安裝一個名為「安裝 [版本名稱]」的 App。從「應用程式」檔案夾中打開該 App，即可開始安裝作業系統。</p><ul><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-39476-20191023-48f365f4-0015-4c41-9f44-39d3d2aca067/InstallOS.dmg">macOS Sierra</a> 可以升級 El Capitan、Yosemite、Mavericks、Mountain Lion 或 Lion</li><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg">OS X El Capitan</a> 可以升級 Yosemite、Mavericks、Mountain Lion、Lion 或 Snow Leopard</li><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-41343-20191023-02465f92-3ab5-4c92-bfe2-b725447a070d/InstallMacOSX.dmg">OS X Yosemite</a> 可以升級 Mavericks、Mountain Lion、Lion 或 Snow Leopard</li></ul><p>發佈日期： 2022 年 03 月 03 日</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶面尺寸和镜头焦距配套对应的视场角</title>
      <link href="/2022/05/23/ba-mian-chi-cun-he-jing-tou-jiao-ju-pei-tao-dui-ying-de-shi-chang-jiao/"/>
      <url>/2022/05/23/ba-mian-chi-cun-he-jing-tou-jiao-ju-pei-tao-dui-ying-de-shi-chang-jiao/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>镜头焦距：</th><th>1.9mm</th><th>1.9mm</th><th>1.9mm</th><th>2.4mm</th><th>2.8mm</th><th>2.8mm</th><th>2.8mm</th><th>3.6mm</th><th>3.6mm</th><th>3.6mm</th><th>3.9mm</th><th>4mm</th><th>4mm</th><th>4mm</th><th>5mm</th><th>6mm</th></tr></thead><tbody><tr><td>靶面尺寸</td><td>长(mm)</td><td>宽(mm)</td><td>对角(mm)</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td></tr><tr><td>1/6”</td><td>2.4</td><td>1.8</td><td>3</td><td>64.55128973</td><td>50.69235275</td><td>76.58032769</td><td>53.13010326</td><td>46.39718182</td><td>35.63777844</td><td>56.35718118</td><td>36.86989827</td><td>28.07248741</td><td>45.23973067</td><td>34.20545852</td><td>33.39849</td><td>25.36077</td><td>41.11209</td><td>28.04247</td><td>22.61987</td></tr><tr><td>1/4”</td><td>3.2</td><td>2.4</td><td>4</td><td>80.20181646</td><td>64.55128973</td><td>92.93760301</td><td>67.3801362</td><td>59.48976361</td><td>46.39718182</td><td>71.0753568</td><td>47.92497877</td><td>36.86989827</td><td>58.10920919</td><td>44.61241087</td><td>43.60282</td><td>33.39849</td><td>53.1301</td><td>37.97443</td><td>29.86283</td></tr><tr><td>1/4”</td><td>3.6</td><td>2.7</td><td>4.5</td><td>86.90368608</td><td>70.7895929</td><td>99.64153386</td><td>73.73979655</td><td>65.47045366</td><td>51.48141759</td><td>77.56872952</td><td>53.13010326</td><td>41.11209114</td><td>64.01076751</td><td>49.55028198</td><td>48.45549</td><td>37.29908</td><td>58.71551</td><td>43.13259</td><td>33.39849</td></tr><tr><td>1/3.6”</td><td>4</td><td>3</td><td>5</td><td>92.93760301</td><td>76.58032769</td><td>105.5303338</td><td>79.61114354</td><td>71.0753568</td><td>56.35718118</td><td>83.52060083</td><td>58.10920919</td><td>45.23973067</td><td>69.55566392</td><td>54.29936432</td><td>53.1301</td><td>41.11209</td><td>64.01077</td><td>48.44853</td><td>36.8699</td></tr><tr><td>1/3.2”</td><td>4.536</td><td>3.416</td><td>5.678</td><td>100.0913228</td><td>83.90774916</td><td>112.4151895</td><td>86.76048649</td><td>78.01494644</td><td>62.76638318</td><td>90.79251787</td><td>64.42185655</td><td>50.76348344</td><td>76.51941044</td><td>60.35929687</td><td>59.10647</td><td>46.24497</td><td>70.73046</td><td>55.86371</td><td>41.41318</td></tr><tr><td>1/3”</td><td>4.8</td><td>3.6</td><td>6</td><td>103.265031</td><td>86.90368608</td><td>115.305115</td><td>90.00000154</td><td>81.20259068</td><td>65.47045366</td><td>93.94986962</td><td>67.3801362</td><td>53.13010326</td><td>79.61114354</td><td>63.21500557</td><td>61.92751</td><td>48.45549</td><td>73.7398</td><td>59.65761</td><td>43.60282</td></tr><tr><td>1/2.8”</td><td>4.59</td><td>3.42</td><td>5.71</td><td>100.7581907</td><td>83.97442642</td><td>112.712541</td><td>87.4376781</td><td>78.67903116</td><td>62.82601814</td><td>91.11447318</td><td>65.03502234</td><td>50.81543708</td><td>76.83274295</td><td>60.95034996</td><td>59.6901</td><td>46.29342</td><td>71.0347</td><td>56.6316</td><td>41.86371</td></tr><tr><td>1/2.7”</td><td>5.27</td><td>3.96</td><td>6.592</td><td>108.4120734</td><td>92.3623794</td><td>120.0768619</td><td>95.3444878</td><td>86.52220908</td><td>70.53153652</td><td>99.30323061</td><td>72.40411143</td><td>57.62158847</td><td>84.95166994</td><td>68.08914978</td><td>66.74979</td><td>52.67082</td><td>78.97705</td><td>66.68016</td><td>47.41896</td></tr><tr><td>1/2.7”</td><td>5.371</td><td>4.035</td><td>6.718</td><td>109.4409395</td><td>93.43598697</td><td>121.0111347</td><td>96.42642672</td><td>87.60845497</td><td>71.54819508</td><td>100.3720838</td><td>73.44383343</td><td>58.53399502</td><td>86.03311928</td><td>69.10180006</td><td>67.75285</td><td>53.53047</td><td>80.04372</td><td>68.23864</td><td>48.22499</td></tr><tr><td>1/2.5”</td><td>5.76</td><td>4.29</td><td>7.182</td><td>113.172555</td><td>96.93218357</td><td>124.2333209</td><td>100.3888595</td><td>91.61386047</td><td>74.90938911</td><td>104.1109859</td><td>77.31961783</td><td>61.57579159</td><td>89.85658289</td><td>72.88888476</td><td>71.50778</td><td>56.40487</td><td>83.83182</td><td>74.42337</td><td>51.28201</td></tr><tr><td>1/2.3”</td><td>6.16</td><td>4.62</td><td>7.7</td><td>116.6605317</td><td>101.1246685</td><td>127.4667255</td><td>104.1470771</td><td>95.45262362</td><td>79.04526389</td><td>107.9452551</td><td>81.09765338</td><td>65.3738742</td><td>93.84391352</td><td>76.59937866</td><td>75.19254</td><td>60.01287</td><td>87.81062</td><td>81.11793</td><td>54.34588</td></tr><tr><td>1/2”</td><td>6.4</td><td>4.8</td><td>8</td><td>118.6005569</td><td>103.265031</td><td>129.184566</td><td>106.2602065</td><td>97.62815133</td><td>81.20259068</td><td>110.0159615</td><td>83.26708009</td><td>67.3801362</td><td>96.02557665</td><td>78.73863583</td><td>77.31962</td><td>61.92751</td><td>90</td><td>85.31844</td><td>56.14497</td></tr><tr><td>1/1.8”</td><td>7.2</td><td>5.4</td><td>9</td><td>124.3518094</td><td>109.7316158</td><td>134.218899</td><td>112.6198669</td><td>104.2500345</td><td>87.91674815</td><td>116.2184184</td><td>90.00000154</td><td>73.73979655</td><td>102.6803852</td><td>85.41878137</td><td>83.97443</td><td>68.0387</td><td>96.73292</td><td>100.5046</td><td>61.92751</td></tr><tr><td>1/1.7”</td><td>7.6</td><td>5.7</td><td>9.5</td><td>126.8698998</td><td>112.6198669</td><td>136.3971834</td><td>115.4487133</td><td>107.2312982</td><td>91.01405967</td><td>118.9635407</td><td>93.09631699</td><td>76.73497208</td><td>105.6834082</td><td>88.5118831</td><td>87.0624</td><td>70.93975</td><td>99.79819</td><td>108.9137</td><td>64.69489</td></tr><tr><td>1/1.6”</td><td>8.08</td><td>6.01</td><td>10.07</td><td>129.6250777</td><td>115.3913423</td><td>138.6511528</td><td>118.5743466</td><td>110.5507182</td><td>94.04505096</td><td>121.842496</td><td>96.59223359</td><td>79.70500692</td><td>108.8708424</td><td>92.0202983</td><td>90.5701</td><td>73.83141</td><td>103.07</td><td>119.8922</td><td>67.90739</td></tr><tr><td>2/3”</td><td>8.8</td><td>6.6</td><td>11</td><td>133.2888726</td><td>120.1369784</td><td>141.8845934</td><td>122.7790828</td><td>115.0576174</td><td>99.37180137</td><td>126.0395407</td><td>101.421188</td><td>85.02089561</td><td>113.5868613</td><td>96.89477536</td><td>95.45262</td><td>79.04526</td><td>107.9453</td><td>138.6173</td><td>72.50768</td></tr><tr><td>1”</td><td>12.9</td><td>9.6</td><td>16</td><td>147.1728347</td><td>136.8093814</td><td>153.2795657</td><td>139.1802367</td><td>133.0678505</td><td>119.4871277</td><td>141.41991</td><td>121.6647753</td><td>106.2602065</td><td>131.5445116</td><td>117.681393</td><td>116.3893</td><td>100.3889</td><td>126.8699</td><td>397.3125</td><td>94.14006</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 摄像头相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视场角 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bits 速查表</title>
      <link href="/2022/05/22/bits-su-cha-biao/"/>
      <url>/2022/05/22/bits-su-cha-biao/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="bits-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> Bits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java函数式编程之Optional</title>
      <link href="/2022/05/21/java-han-shu-shi-bian-cheng-zhi-optional/"/>
      <url>/2022/05/21/java-han-shu-shi-bian-cheng-zhi-optional/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址：<a href="https://juejin.cn/post/6844903908360323080">https://juejin.cn/post/6844903908360323080</a></p></blockquote><p><code>java.util.Optional</code>是JDK8中引入的类，它是JDK从著名的Java工具包<code>Guava</code>中移植过来。本文编写的时候使用的是JDK11。<code>Optional</code>是一个包含了<code>NULL</code>值或者非<code>NULL</code>值的对象容器，它常用作明确表明没有结果（其实明确表明存在结果也可以用<code>Optional</code>表示）的方法返回类型，这样可以避免<code>NULL</code>值带来的可能的异常（一般是<code>NullPointerException</code>）。也就是说，一个方法的返回值类型是<code>Optional</code>，则应该避免返回<code>NULL</code>，而应该让返回值指向一个包含<code>NULL</code>对象的<code>Optional</code>实例。<code>Optional</code>的出现为<code>NULL</code>判断、过滤操作、映射操作等提供了函数式适配入口，它算是Java引入函数式编程的一个重要的里程碑。</p><h2 id="Optional各个方法源码分析和使用场景"><a href="#Optional各个方法源码分析和使用场景" class="headerlink" title="Optional各个方法源码分析和使用场景"></a>Optional各个方法源码分析和使用场景</h2><p><code>Optional</code>的源码比较简单，归根于它是一个简单的对象容器。下面会结合源码分析它的所有构造、属性、方法和对应的使用场景。</p><h3 id="Optional属性和构造"><a href="#Optional属性和构造" class="headerlink" title="Optional属性和构造"></a>Optional属性和构造</h3><p><code>Optional</code>的属性和构造如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Optional&lt;T&gt; &#123;    &#x2F;&#x2F; 这个是通用的代表NULL值的Optional实例    private static final Optional&lt;?&gt; EMPTY &#x3D; new Optional&lt;&gt;();    &#x2F;&#x2F; 泛型类型的对象实例    private final T value;        &#x2F;&#x2F; 实例化Optional，注意是私有修饰符，value置为NULL    private Optional() &#123;        this.value &#x3D; null;    &#125;        &#x2F;&#x2F; 直接返回内部的EMPTY实例    public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;T&gt; t &#x3D; (Optional&lt;T&gt;) EMPTY;        return t;    &#125;        &#x2F;&#x2F; 通过value实例化Optional，如果value为NULL则抛出NPE    private Optional(T value) &#123;        this.value &#x3D; Objects.requireNonNull(value);    &#125;        &#x2F;&#x2F; 通过value实例化Optional，如果value为NULL则抛出NPE，实际上就是使用Optional(T value)    public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;        return new Optional&lt;&gt;(value);    &#125;    &#x2F;&#x2F; 如果value为NULL则返回EMPTY实例，否则调用Optional#of(value)    public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;        return value &#x3D;&#x3D; null ? empty() : of(value);    &#125;        &#x2F;&#x2F; 暂时省略其他代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果明确一个对象实例不为<code>NULL</code>的时候，应该使用<code>Optional#of()</code>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);assert null !&#x3D; oOptional op &#x3D; Optional.of(o);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果无法明确一个对象实例是否为<code>NULL</code>的时候，应该使用<code>Optional#ofNullable()</code>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional op &#x3D; Optional.ofNullable(selectByOrderId(orderId));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>明确表示一个持有<code>NULL</code>值的<code>Optional</code>实例可以使用<code>Optional.empty()</code>。</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果value为空，则抛出NPE，否则直接返回valuepublic T get() &#123;    if (value &#x3D;&#x3D; null) &#123;        throw new NoSuchElementException(&quot;No value present&quot;);    &#125;    return value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>get()</code>方法一般是需要明确<code>value</code>不为<code>NULL</code>的时候使用，它做了先验<code>value</code>的存在性。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);assert null !&#x3D; oOptional op &#x3D; Optional.of(o);Order value &#x3D; op.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="isPresent-方法"><a href="#isPresent-方法" class="headerlink" title="isPresent()方法"></a>isPresent()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断value是否存在，不为NULL则返回true，如果为NULL则返回falsepublic boolean isPresent() &#123;    return value !&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);boolean existed &#x3D; Optional.ofNullable(o).isPresent();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty()方法"></a>isEmpty()方法</h3><p><code>isEmpty()</code>是JDK11引入的方法，是<code>isPresent()</code>的反向判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断value是否存在，为NULL则返回true，为非NULL则返回falsepublic boolean isEmpty() &#123;    return value &#x3D;&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ifPresent-方法"><a href="#ifPresent-方法" class="headerlink" title="ifPresent()方法"></a>ifPresent()方法</h3><p><code>ifPresent()</code>方法的作用是：如果<code>value</code>不为<code>NULL</code>，则使用<code>value</code>调用消费者函数式接口的消费方法<code>Consumer#accept()</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void ifPresent(Consumer&lt;? super T&gt; action) &#123;    if (value !&#x3D; null) &#123;        action.accept(value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(selectByOrderId(orderId)).ifPresent(o-&gt; LOGGER.info(&quot;订单ID:&#123;&#125;&quot;,o.getOrderId());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ifPresentOrElse-方法"><a href="#ifPresentOrElse-方法" class="headerlink" title="ifPresentOrElse()方法"></a>ifPresentOrElse()方法</h3><p><code>ifPresentOrElse()</code>方法是JDK9新增的方法，它是<code>ifPresent()</code>方法的加强版，如果<code>value</code>不为<code>NULL</code>，则使用<code>value</code>调用消费者函数式接口的消费方法<code>Consumer#accept()</code>，如果<code>value</code>为<code>NULL</code>则执行<code>Runnable#run()</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) &#123;    if (value !&#x3D; null) &#123;        action.accept(value);    &#125; else &#123;        emptyAction.run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String orderId &#x3D; &quot;xxxx&quot;; Optional.ofNullable(selectByOrderId(orderId)).ifPresentOrElse(o-&gt; LOGGER.info(&quot;订单ID:&#123;&#125;&quot;,o.getOrderId()), ()-&gt; LOGGER.info(&quot;订单&#123;&#125;不存在&quot;,o.getOrderId()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;    &#x2F;&#x2F; 判断predicate不能为NULL    Objects.requireNonNull(predicate);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回自身    if (!isPresent()) &#123;        return this;    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，则通过predicate判断，命中返回自身，不命中则返回空实例empty        return predicate.test(value) ? this : empty();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的功能是简单的过滤功能，容器持有对象<code>value</code>非<code>NULL</code>会做一次判断，决定返回自身实例还是<code>empty()</code>。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(selectByOrderId(orderId)).filter(o -&gt; o.getStatus() &#x3D;&#x3D; 1).ifPresent(o-&gt; LOGGER.info(&quot;订单&#123;&#125;的状态为1&quot;,o.getOrderId));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><p><code>map()</code>是简单的值映射操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;    &#x2F;&#x2F; 判断mapper不能为NULL    Objects.requireNonNull(mapper);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回empty()    if (!isPresent()) &#123;        return empty();    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，通过mapper转换类型，重新封装为可空的Optional实例        return Optional.ofNullable(mapper.apply(value));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>API注释里面的一个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;URI&gt; uris &#x3D; ...;&#x2F;&#x2F; 找到URI列表中未处理的URI对应的路径Optional&lt;Path&gt; p &#x3D; uris.stream().filter(uri -&gt; !isProcessedYet(uri)).findFirst().map(Paths::get);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="flatMap-方法"><a href="#flatMap-方法" class="headerlink" title="flatMap()方法"></a>flatMap()方法</h3><p><code>flatMap()</code>方法也是一个映射操作，不过映射的<code>Optional</code>类型返回值直接由外部决定，不需要通过值重新封装为<code>Optional</code>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper) &#123;    &#x2F;&#x2F; mapper存在性判断    Objects.requireNonNull(mapper);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回empty()    if (!isPresent()) &#123;        return empty();    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，通过mapper转换，直接返回mapper的返回值，做一次空判断        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;U&gt; r &#x3D; (Optional&lt;U&gt;) mapper.apply(value);        return Objects.requireNonNull(r);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class OptionalOrderFactory&#123;    static Optional&lt;Order&gt; create(String id)&#123;        &#x2F;&#x2F;省略...    &#125;&#125;String orderId &#x3D; &quot;xxx&quot;;Optional&lt;Order&gt; op &#x3D;  Optional.of(orderId).flatMap(id -&gt; OptionalOrderFactory.create(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="or-方法"><a href="#or-方法" class="headerlink" title="or()方法"></a>or()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) &#123;    &#x2F;&#x2F; supplier存在性判断    Objects.requireNonNull(supplier);    &#x2F;&#x2F; value不为NULL，则直接返回自身    if (isPresent()) &#123;        return this;    &#125; else &#123;        &#x2F;&#x2F; value为NULL，则返回supplier提供的Optional实例，做一次空判断        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;T&gt; r &#x3D; (Optional&lt;T&gt;) supplier.get();        return Objects.requireNonNull(r);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order a &#x3D; null;Order b &#x3D; select();&#x2F;&#x2F; 拿到的就是b订单实例包装的OptionalOptional&lt;Order&gt; op &#x3D; Optional.ofNullable(a).or(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="stream-方法"><a href="#stream-方法" class="headerlink" title="stream()方法"></a>stream()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 对value做NULL判断，转换为Stream类型public Stream&lt;T&gt; stream() &#123;    if (!isPresent()) &#123;        return Stream.empty();    &#125; else &#123;        return Stream.of(value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElse-方法"><a href="#orElse-方法" class="headerlink" title="orElse()方法"></a>orElse()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 值不为NULL则直接返回value，否则返回otherpublic T orElse(T other) &#123;    return value !&#x3D; null ? value : other;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>orElse()</code>就是常见的提供默认值兜底的方法，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String v1 &#x3D; null;String v2 &#x3D; &quot;default&quot;;&#x2F;&#x2F; 拿到的就是v2对应的&quot;default&quot;值String value &#x3D; Optional.ofNullable(v1).orElse(v2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElseGet-方法"><a href="#orElseGet-方法" class="headerlink" title="orElseGet()方法"></a>orElseGet()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 值不为NULL则直接返回value，否则返回Supplier#get()public T orElseGet(Supplier&lt;? extends T&gt; supplier) &#123;    return value !&#x3D; null ? value : supplier.get();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>orElseGet()</code>只是<code>orElse()</code>方法的升级版，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String v1 &#x3D; null;Supplier&lt;String&gt; v2 &#x3D; () -&gt; &quot;default&quot;;&#x2F;&#x2F; 拿到的就是v2对应的&quot;default&quot;值String value &#x3D; Optional.ofNullable(v1).orElseGet(v2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElseThrow-方法"><a href="#orElseThrow-方法" class="headerlink" title="orElseThrow()方法"></a>orElseThrow()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果值为NULL，则抛出NoSuchElementException，否则直接返回valuepublic T orElseThrow() &#123;    if (value &#x3D;&#x3D; null) &#123;        throw new NoSuchElementException(&quot;No value present&quot;);    &#125;    return value;&#125;&#x2F;&#x2F; 如果值不为NULL，则直接返回value，否则返回Supplier#get()提供的异常实例public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;    if (value !&#x3D; null) &#123;        return value;    &#125; else &#123;        throw exceptionSupplier.get();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(orderInfoVo.getAmount()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId())));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="equals-和hashCode-方法"><a href="#equals-和hashCode-方法" class="headerlink" title="equals()和hashCode()方法"></a>equals()和hashCode()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean equals(Object obj) &#123;    if (this &#x3D;&#x3D; obj) &#123;        return true;    &#125;    if (!(obj instanceof Optional)) &#123;        return false;    &#125;    Optional&lt;?&gt; other &#x3D; (Optional&lt;?&gt;) obj;    return Objects.equals(value, other.value);&#125;public int hashCode() &#123;    return Objects.hashCode(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个方法都是比较<code>value</code>，说明了<code>Optional</code>实例如果使用于<code>HashMap</code>的KEY，只要<code>value</code>相同，对于<code>HashMap</code>就是同一个KEY。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Optional,Boolean&gt; map &#x3D; new HashMap&lt;&gt;();Optional&lt;String&gt; op1 &#x3D; Optional.of(&quot;throwable&quot;);map.put(op1, true);Optional&lt;String&gt; op2 &#x3D; Optional.of(&quot;throwable&quot;);map.put(op2, false);&#x2F;&#x2F; 输出falseSystem.out.println(map.get(op1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Optional实战"><a href="#Optional实战" class="headerlink" title="Optional实战"></a>Optional实战</h2><p>下面展示一下<code>Optional</code>的一些常见的使用场景。</p><h3 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h3><p>空判断主要是用于不知道当前对象是否为<code>NULL</code>的时候，需要设置对象的属性。不使用<code>Optional</code>时候的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(null !&#x3D; order)&#123;    order.setAmount(orderInfoVo.getAmount());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>时候的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(order).ifPresent(o -&gt; o.setAmount(orderInfoVo.getAmount()));&#x2F;&#x2F; 如果判断空的对象是OrderInfoVo如下Order o &#x3D; select();OrderInfoVo vo &#x3D; ...Optional.ofNullable(vo).ifPresent(v -&gt; o.setAmount(v.getAmount()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>实现空判断的好处是<strong>只有一个属性设值的时候可以压缩代码为一行</strong>，这样做的话，代码会相对简洁。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在维护一些老旧的系统的时候，很多情况下外部的传参没有做空判断，因此需要写一些断言代码如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (null &#x3D;&#x3D; orderInfoVo.getAmount())&#123;    throw new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId()));&#125;if (StringUtils.isBlank(orderInfoVo.getAddress())&#123;    throw new IllegalArgumentException(String.format(&quot;%s订单的address不能为空&quot;,orderInfoVo.getOrderId()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>后的断言代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(orderInfoVo.getAmount()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId())));Optional.ofNullable(orderInfoVo.getAddress()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的address不能为空&quot;,orderInfoVo.getOrderId())));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="综合仿真案例"><a href="#综合仿真案例" class="headerlink" title="综合仿真案例"></a>综合仿真案例</h3><p>下面是一个仿真案例，模拟的步骤如下：</p><ul><li>给出客户ID列表查询客户列表。</li><li>基于存在的客户列表中的客户ID查询订单列表。</li><li>基于订单列表转换为订单DTO视图列表。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datastatic class Customer &#123;    private Long id;&#125;@Datastatic class Order &#123;    private Long id;    private String orderId;    private Long customerId;&#125;@Datastatic class OrderDto &#123;    private String orderId;&#125;&#x2F;&#x2F; 模拟客户查询private static List&lt;Customer&gt; selectCustomers(List&lt;Long&gt; ids) &#123;    return null;&#125;&#x2F;&#x2F; 模拟订单查询private static List&lt;Order&gt; selectOrders(List&lt;Long&gt; customerIds) &#123;    return null;&#125;&#x2F;&#x2F; main方法public static void main(String[] args) throws Exception &#123;    List&lt;Long&gt; ids &#x3D; new ArrayList&lt;&gt;();    List&lt;OrderDto&gt; view &#x3D; Optional.ofNullable(selectCustomers(ids))            .filter(cs -&gt; !cs.isEmpty())            .map(cs -&gt; selectOrders(cs.stream().map(Customer::getId).collect(Collectors.toList())))            .map(orders -&gt; &#123;                List&lt;OrderDto&gt; dtoList &#x3D; new ArrayList&lt;&gt;();                orders.forEach(o -&gt; &#123;                    OrderDto dto &#x3D; new OrderDto();                    dto.setOrderId(o.getOrderId());                    dtoList.add(dto);                &#125;);                return dtoList;            &#125;).orElse(Collections.emptyList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Optional</code>本质是一个对象容器，它的特征如下：</p><ol><li><code>Optional</code>作为一个容器承载对象，提供方法适配部分函数式接口，结合部分函数式接口提供方法实现<code>NULL</code>判断、过滤操作、安全取值、映射操作等等。</li><li><code>Optional</code>一般使用场景是用于方法返回值的包装，当然也可以作为临时变量从而享受函数式接口的便捷功能。</li><li><code>Optional</code>只是一个简化操作的工具，可以解决多层嵌套代码的节点空判断问题（例如简化箭头型代码）。</li><li><code>Optional</code>并非银弹。</li></ol><p>这里提到箭头型代码，下面尝试用常规方法和<code>Optional</code>分别解决：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 假设VO有多个层级，每个层级都不知道父节点是否为NULL，如下&#x2F;&#x2F; - OrderInfoVo&#x2F;&#x2F;   - UserInfoVo&#x2F;&#x2F;     - AddressInfoVo&#x2F;&#x2F;        - address(属性)&#x2F;&#x2F; 假设我要为address属性赋值，那么就会产生箭头型代码。&#x2F;&#x2F; 常规方法String address &#x3D; &quot;xxx&quot;;OrderInfoVo o &#x3D; ...;if(null !&#x3D; o)&#123;    UserInfoVo uiv &#x3D; o.getUserInfoVo();    if (null !&#x3D; uiv)&#123;        AddressInfoVo aiv &#x3D; uiv.getAddressInfoVo();        if (null !&#x3D; aiv)&#123;            aiv.setAddress(address);        &#125;    &#125;&#125;&#x2F;&#x2F; 使用OptionalString address &#x3D; &quot;xxx&quot;;OrderInfoVo o &#x3D; null;Optional.ofNullable(o)        .map(OrderInfoVo::getUserInfoVo)        .map(UserInfoVo::getAddressInfoVo)        .ifPresent(a -&gt; a.setAddress(address));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>解决箭头型代码，通过映射操作<code>map()</code>能减少大量的<code>if</code>和<code>NULL</code>判断分支，使得代码更加简洁。</p><p>有些开发者提议把<code>DAO</code>方法的返回值类型定义为<code>Optional</code>，笔者对此持中立态度，原因是：</p><ol><li><code>Optional</code>是JDK1.8引入，低版本的JDK并不能使用，不是所有的系统都能平滑迁移到JDK1.8+。</li><li>并不是所有人都热衷于函数式编程，因为它带来了便捷的同时转变了代码的阅读逻辑（有些人甚至会认为降低了代码的可读性）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球机PTZ和视场角与ONVIF和PTZ对应关系</title>
      <link href="/2022/05/21/qiu-ji-ptz-he-shi-chang-jiao-yu-onvif-he-ptz-dui-ying-guan-xi/"/>
      <url>/2022/05/21/qiu-ji-ptz-he-shi-chang-jiao-yu-onvif-he-ptz-dui-ying-guan-xi/</url>
      
        <content type="html"><![CDATA[<p>文章目录</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul><li><p>不同品牌对应关系不一致，同一品牌，根据摄像头产品参数也会不一致</p></li><li><p>球机的PTZ和ONVIF的PTZ是线性关系</p></li><li><p>摄像头的视场角与ONVIF的Zoom是非线性关系</p></li><li><p>ONVIF的PTZ范围</p><p>P、T ∈[-1, 1]</p><p>Z∈ [0,1]</p></li><li><p>球机PTZ范围：根据不同型号不一致</p><h2 id="PTZ-ONVIF-amp-PTZ-SDK"><a href="#PTZ-ONVIF-amp-PTZ-SDK" class="headerlink" title="PTZ_ONVIF &amp; PTZ_SDK"></a>PTZ_ONVIF &amp; PTZ_SDK</h2></li><li><p>以海康相机iDS-2VS435-F837为例，分别ONVIF控制球机转动指定PTZ坐标，再使用SDK获取PTZ坐标</p></li><li>海康球机SDK获取PTZ坐标(具体参考《设备网络SDK使用手册》)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int p_pos &#x3D; HexToDecMa(ptz_pos.wPanPos) &#x2F; 10 % 360;&#x2F;&#x2F; 十六进制转化为十进制角度int t_pos &#x3D; HexToDecMa(ptz_pos.wTiltPos) &#x2F; 10 % 360;int z_pos &#x3D; HexToDecMa(ptz_pos.wZoomPos) &#x2F; 10 % 360;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ONVIF——&gt;PTZ</p><p>模型函数是线性关系$\ y=kx+b $<br>LS最小二乘拟合<br>关系如下：<br>\begin{cases}<br>p′=179.87∗p+179.95 \\<br>t′=55.00∗t+35.24 \\<br>z′=36.00∗z+1.0<br>\end{cases}</p><p>球机水平方向转动360°<br>球机垂直方向转动[-20°, 90°]<br>球机光学放大倍数37倍<br>可以根据参数来验证拟合关系，设计正交试验，只需要测量几次即可</p><p>球机视场角与ONVIF对应关系</p><p>有时候需要实时获取视场角</p><p>视场角∝放大倍数∝Zoom</p><p>以海康相机iDS-2VS435-F837为例，固定PT，分别ONVIF控制球机转动指定Z，再获取视场角，视场角获取可以参考《视场角计算》</p><p>对应关系如下：</p><p>ONVIF-Zoom ——&gt;水平/垂直视场角</p><p>可以很明显看出是非线性关系<br>采用《非线性优化算法——LM》拟合曲线<br>关系如下</p><script type="math/tex; mode=display">{ F O V H = 1.626 ∗ e 0.634 0.177 + z o o m F O V V = 0.953 ∗ e 0.598 0.166 + z o o m{FOVH=1.626∗e0.6340.177+zoomFOVV=0.953∗e0.5980.166+zoom{FOVH=1.626∗e0.6340.177+zoomFOVV=0.953∗e0.5980.166+zoom{ FOV H =1.626∗e 0.177+zoom0.634FOV V =0.953∗e 0.166+zoom0.598</script><p>​    </p><p>拟合效果如下</p>]]></content>
      
      
      
        <tags>
            
            <tag> camera onvif </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/19/hello-world/"/>
      <url>/2022/05/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void main()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
