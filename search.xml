<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>s3fs挂载minio存储</title>
      <link href="/2023/01/03/s3fs-gua-zai-minio-cun-chu/"/>
      <url>/2023/01/03/s3fs-gua-zai-minio-cun-chu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/">https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export CVAT_HOST&#x3D;10.9.98.213export no_proxy&#x3D;localhost,127.0.0.1,.example.com,172.19.0.0&#x2F;16,172.20.0.0&#x2F;16,172.17.0.0&#x2F;16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>```shell<br>docker-compose up -d<pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;shelldocker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>docker-compose -f docker-compose.yml -f components/serverless/docker-compose.serverless.yml up -d</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;openvino&#x2F;docker-compose.openvino.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  up -d --build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="s3fs挂载minio存储"><a href="#s3fs挂载minio存储" class="headerlink" title="s3fs挂载minio存储"></a>s3fs挂载minio存储</h3><ol><li><p>安装 s3fs：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在文件中输入您的凭据<code>$&#123;HOME&#125;/.passwd-s3fs</code>并设置仅所有者权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo ACCESS_KEY_ID:SECRET_ACCESS_KEY &gt; $&#123;HOME&#125;&#x2F;.passwd-s3fschmod 600 $&#123;HOME&#125;&#x2F;.passwd-s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>user_allow_other</code>在<code>/etc/fuse.conf</code>文件中取消注释：<code>sudo nano /etc/fuse.conf</code></p></li><li><p>运行 s3fs，替换<code>bucket_name</code>，<code>mount_point</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;$&#123;HOME&#125;&#x2F;.passwd-s3fs -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h4><p>按照上面的前 3 个安装步骤进行操作。</p><h5 id="使用-fstab"><a href="#使用-fstab" class="headerlink" title="使用 fstab"></a>使用 fstab</h5><ol><li><p>使用以下内容创建一个名为 aws_s3_fuse 的 bash 脚本（例如在 /usr/bin 中，以 root 身份）（替换<code>user_name</code>将安装磁盘的代表，<code>backet_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashsudo -u root s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_styleexit 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ol><li><p>给它执行权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod +x &#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑<code>/etc/fstab</code>添加这样一行，替换<code>mount_point</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse  &#x2F;mnt&#x2F;share     fuse    allow_other,user,_netdev     0       0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="使用系统"><a href="#使用系统" class="headerlink" title="使用系统"></a>使用系统</h5><ol><li><p>创建单元文件<code>sudo nano /etc/systemd/system/s3fs.service</code> （替换<code>user_name</code>, <code>bucket_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Unit]Description&#x3D;FUSE filesystem over AWS S3 bucketAfter&#x3D;network.target[Service]Environment&#x3D;&quot;MOUNT_POINT&#x3D;&#x2F;mnt&#x2F;share&quot;User&#x3D;rootGroup&#x3D;rootExecStart&#x3D;s3fs cvat &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style -o umask&#x3D;0000 -o endpoint&#x3D;fr-parExecStop&#x3D;fusermount -u &#x2F;mnt&#x2F;shareRestart&#x3D;alwaysType&#x3D;forking[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新系统配置，系统启动时启用unit autorun，挂载bucket：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reloadsudo systemctl enable s3fs.servicesudo systemctl start s3fs.service# 卸载$ fusermount -u &#x2F;mnt&#x2F;share&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看</p><p>一个文件<code>/etc/mtab</code>包含当前挂载的文件系统的记录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;mtab | grep &#39;s3fs&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> minio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorRT环境安装</title>
      <link href="/2022/12/28/tensorrt-huan-jing-an-zhuang/"/>
      <url>/2022/12/28/tensorrt-huan-jing-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><pre class="line-numbers language-none"><code class="language-none">!pip install -U numpy&#x3D;&#x3D;1.23.1!pip install -U onnx&#x3D;&#x3D;1.12.0!pip install -U onnxruntime&#x3D;&#x3D;1.12.1!pip install -U protobuf&#x3D;&#x3D;3.16.0!pip install -U typing-extensions&#x3D;&#x3D;4.4.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ubuntu users: the quickest way to install protobuf is to run</p><pre class="line-numbers language-none"><code class="language-none">apt-get install python3-pip python3-dev libprotobuf-dev protobuf-compiler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Then you can build ONNX as:</p><pre class="line-numbers language-none"><code class="language-none">export CMAKE_ARGS&#x3D;&quot;-DONNX_USE_PROTOBUF_SHARED_LIBS&#x3D;ON&quot;git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;onnx&#x2F;onnx.gitcd onnx# prefer lite protoset CMAKE_ARGS&#x3D;-DONNX_USE_LITE_PROTO&#x3D;ONpip install -e .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Verify-Installation"><a href="#Verify-Installation" class="headerlink" title="Verify Installation"></a>Verify Installation</h2><p>After installation, run</p><pre class="line-numbers language-none"><code class="language-none">python -c &quot;import onnx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>ONNX uses <a href="https://docs.pytest.org/">pytest</a> as test driver. In order to run tests, you will first need to install pytest:</p><pre class="line-numbers language-none"><code class="language-none">pip install pytest nbval<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>After installing pytest, use the following command to run tests.</p><pre class="line-numbers language-none"><code class="language-none">pytest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p><a href="https://github.com/google/benchmark/tree/0d98dba29d66e93259db7daa53a9327df767a415">https://github.com/google/benchmark/tree/0d98dba29d66e93259db7daa53a9327df767a415</a></p><h2 id="Installation-1"><a href="#Installation-1" class="headerlink" title="Installation"></a>Installation</h2><pre class="line-numbers language-none"><code class="language-none"># Check out the library.$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;benchmark.git# Go to the library root directory$ cd benchmark# Make a build directory to place the build output.$ cmake -E make_directory &quot;build&quot;# Generate build system files with cmake, and download any dependencies.$ cmake -E chdir &quot;build&quot; cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES&#x3D;on -DCMAKE_BUILD_TYPE&#x3D;Release ..&#x2F;# or, starting with CMake 3.13, use a simpler form:# cmake -DCMAKE_BUILD_TYPE&#x3D;Release -S . -B &quot;build&quot;# Build the library.$ cmake --build &quot;build&quot; --config Release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fatal: 无法访问 ‘<a href="https://github.com/openstreetmap/osmosis.git/’：GnuTLS">https://github.com/openstreetmap/osmosis.git/’：GnuTLS</a> recv error (-110): The TLS connection was non-properly terminated.</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>关掉ssl<br>输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">apt-get install gnutls-bingit config --global http.sslVerify falsegit config --global http.postBuffer 1048576000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="pybind11"><a href="#pybind11" class="headerlink" title="pybind11"></a>pybind11</h2><pre class="line-numbers language-none"><code class="language-none">$ cd &#x2F;workspace&#x2F;TensorRT&#x2F;parsers&#x2F;onnx&#x2F;third_party&#x2F;onnx&#x2F;third_party&#x2F;$ git clone https:&#x2F;&#x2F;github.com&#x2F;pybind&#x2F;pybind11.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>运行<code>yolov5</code>时<code>docker</code>容器报错：<code>ImportError: libGL.so.1: cannot open shared object file: No such file or directory</code>。</p><p>解决办法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install ffmpeg libsm6 libxext6  -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ cd $TRT_OSSPATH $ mkdir -p build &amp;&amp; cd build $ cmake .. -DTRT_LIB_DIR&#x3D;$TRT_LIBPATH -DTRT_OUT_DIR&#x3D;&#96;pwd&#96;&#x2F;out $ make -j$(nproc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Jetson TX2上升级cmake方法</title>
      <link href="/2022/12/20/jetson-tx2-shang-sheng-ji-cmake-fang-fa/"/>
      <url>/2022/12/20/jetson-tx2-shang-sheng-ji-cmake-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="从源码安装camke"><a href="#从源码安装camke" class="headerlink" title="从源码安装camke"></a>从源码安装camke</h1><h2 id="1-删除默认的cmake"><a href="#1-删除默认的cmake" class="headerlink" title="1. 删除默认的cmake"></a>1. 删除默认的cmake</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt remove cmakesudo apt purge --auto-remove cmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-从官网下载所需版本，解压，创建build文件夹"><a href="#2-从官网下载所需版本，解压，创建build文件夹" class="headerlink" title="2. 从官网下载所需版本，解压，创建build文件夹"></a>2. 从官网下载所需版本，解压，创建build文件夹</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version&#x3D;3.13build&#x3D;3mkdir ~&#x2F;tempcd ~&#x2F;tempwget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v$version&#x2F;cmake-$version.$build.tar.gztar -xzvf cmake-$version.$build.tar.gzcd cmake-$version.$build&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bootstrapmake -j4sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-移动路径"><a href="#4-移动路径" class="headerlink" title="4. 移动路径"></a>4. 移动路径</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cp .&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-验证安装结果"><a href="#5-验证安装结果" class="headerlink" title="5.验证安装结果"></a>5.验证安装结果</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：<br><pre class="line-numbers language-none"><code class="language-none">cmake version 3.13.3CMake suite maintained and supported by Kitware (kitware.com&#x2F;cmake).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读记录-2022/12</title>
      <link href="/2022/12/06/yue-du-ji-lu-2022-12/"/>
      <url>/2022/12/06/yue-du-ji-lu-2022-12/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.51cto.com/article/677110.html">digiKam使用</a><br><a href="https://snapcraft.io/install/digikam/ubuntu">snap digiKam</a><br><a href="https://linuxhint.com/setup-configure-autocomplete-zsh/">Ubuntu zsh autoComplete</a><br><a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/paddlepaddle/tags">Paddle Nvidia Containers</a><br><a href="https://github.com/NVIDIA/DeepLearningExamples">NVIDIA DeepLearningExamples</a><br><a href="https://github.com/PINTO0309/openvino2tensorflow">openvino2tensorflow</a><br><a href="https://netron.app/">netron可视化网络</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter NoteBook 的快捷鍵</title>
      <link href="/2022/11/10/jupyter-notebook-de-kuai-jie-jian/"/>
      <url>/2022/11/10/jupyter-notebook-de-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）"><a href="#快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）" class="headerlink" title="快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:"></a>快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:</h3><div class="table-container"><table><thead><tr><th style="text-align:left">快捷鍵</th><th style="text-align:left">作用</th><th style="text-align:left">說明</th></tr></thead><tbody><tr><td style="text-align:left">Enter</td><td style="text-align:left">轉入編輯模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Enter</td><td style="text-align:left">運行本單元，選中下個單元</td><td style="text-align:left">新單元默認為命令模式</td></tr><tr><td style="text-align:left">Ctrl-Enter</td><td style="text-align:left">運行本單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Alt-Enter</td><td style="text-align:left">運行本單元，在其下插入新單元</td><td style="text-align:left">新單元默認為編輯模式</td></tr><tr><td style="text-align:left">Y</td><td style="text-align:left">單元轉入代碼狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">單元轉入 markdown 狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">R</td><td style="text-align:left">單元轉入 raw 狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">設定 1 級標題</td><td style="text-align:left">僅在 markdown 狀態下時建議使用標題相關快捷鍵，如果單元處於其他狀態，則會強制切換到 markdown 狀態</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">設定 2 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">設定 3 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">設定 4 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">設定 5 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">設定 6 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Up</td><td style="text-align:left">選中上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">K</td><td style="text-align:left">選中上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Down</td><td style="text-align:left">選中下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">選中下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-K</td><td style="text-align:left">連續選擇上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-J</td><td style="text-align:left">連續選擇下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">在上方插入新單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">在下方插入新單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">剪切選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">複製選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-V</td><td style="text-align:left">粘貼到上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">粘貼到下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">恢復刪除的最後一個單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">D,D</td><td style="text-align:left">刪除選中的單元</td><td style="text-align:left">連續按兩個 D 鍵</td></tr><tr><td style="text-align:left">Shift-M</td><td style="text-align:left">合併選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">開關行號</td><td style="text-align:left">編輯框的行號是可以開啟和關閉的</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">轉換輸出</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-O</td><td style="text-align:left">轉換輸出滾動</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Esc</td><td style="text-align:left">關閉頁面</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Q</td><td style="text-align:left">關閉頁面</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">H</td><td style="text-align:left">顯示快捷鍵幫助</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I,I</td><td style="text-align:left">中斷 NoteBook 內核</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0,0</td><td style="text-align:left">重啟 NoteBook 內核</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift</td><td style="text-align:left">忽略</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Space</td><td style="text-align:left">向上滾動</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Space</td><td style="text-align:left">向下滾動</td></tr></tbody></table></div><h3 id="編輯模式快捷鍵（-按-Enter-鍵啟動）"><a href="#編輯模式快捷鍵（-按-Enter-鍵啟動）" class="headerlink" title="編輯模式快捷鍵（ 按 Enter 鍵啟動）:"></a>編輯模式快捷鍵（ 按 Enter 鍵啟動）:</h3><div class="table-container"><table><thead><tr><th style="text-align:left">快捷鍵</th><th style="text-align:left">作用</th><th style="text-align:left">說明</th></tr></thead><tbody><tr><td style="text-align:left">Tab</td><td style="text-align:left">代碼補全或縮進</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Tab</td><td style="text-align:left">提示</td><td style="text-align:left">輸出幫助信息，部分函數、類、方法等會顯示其定義原型，如果在其後加 <code>?</code> 再運行會顯示更加詳細的幫助</td></tr><tr><td style="text-align:left">Ctrl-]</td><td style="text-align:left">縮進</td><td style="text-align:left">向右縮進</td></tr><tr><td style="text-align:left">Ctrl-[</td><td style="text-align:left">解除縮進</td><td style="text-align:left">向左縮進</td></tr><tr><td style="text-align:left">Ctrl-A</td><td style="text-align:left">全選</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Z</td><td style="text-align:left">撤銷</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Shift-Z</td><td style="text-align:left">重做</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Y</td><td style="text-align:left">重做</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Home</td><td style="text-align:left">跳到單元開頭</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Up</td><td style="text-align:left">跳到單元開頭</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-End</td><td style="text-align:left">跳到單元末尾</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Down</td><td style="text-align:left">跳到單元末尾</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Left</td><td style="text-align:left">跳到左邊一個字首</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Right</td><td style="text-align:left">跳到右邊一個字首</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Backspace</td><td style="text-align:left">刪除前面一個字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Delete</td><td style="text-align:left">刪除後面一個字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Esc</td><td style="text-align:left">切換到命令模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-M</td><td style="text-align:left">切換到命令模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Enter</td><td style="text-align:left">運行本單元，選中下一單元</td><td style="text-align:left">新單元默認為命令模式</td></tr><tr><td style="text-align:left">Ctrl-Enter</td><td style="text-align:left">運行本單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Alt-Enter</td><td style="text-align:left">運行本單元，在下面插入一單元</td><td style="text-align:left">新單元默認為編輯模式</td></tr><tr><td style="text-align:left">Ctrl-Shift—</td><td style="text-align:left">分割單元</td><td style="text-align:left">按光標所在行進行分割</td></tr><tr><td style="text-align:left">Ctrl-Shift-Subtract</td><td style="text-align:left">分割單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift</td><td style="text-align:left">忽略</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Up</td><td style="text-align:left">光標上移或轉入上一單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Down</td><td style="text-align:left">光標下移或轉入下一單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-/</td><td style="text-align:left">註釋整行/撤銷註釋</td><td style="text-align:left">僅代碼狀態有效</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Jupyter 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paddle RCNN系列参数配置</title>
      <link href="/2022/11/03/paddle-rcnn-xi-lie-can-shu-pei-zhi/"/>
      <url>/2022/11/03/paddle-rcnn-xi-lie-can-shu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="RCNN系列模型参数配置教程"><a href="#RCNN系列模型参数配置教程" class="headerlink" title="RCNN系列模型参数配置教程"></a>RCNN系列模型参数配置教程</h1><ul><li>标签： 模型参数配置</li></ul><pre class="line-numbers language-none"><code class="language-none">#基础配置  # 检测模型的名称architecture: MaskRCNN# 默认使用GPU运行，设为False时使用CPU运行use_gpu: true# 最大迭代次数，而一个iter会运行batch_size * device_num张图片# 一般batch_size为1时，1x迭代18万次，2x迭代36万次max_iters: 180000# 模型保存间隔，如果训练时eval设置为True，会在保存后进行验证snapshot_iter: 10000# 输出指定区间的平均结果，默认20，即输出20次的平均结果。也是默认打印log的间隔。log_iter: 20# 训练权重的保存路径save_dir: output# 模型的预训练权重，默认是从指定url下载pretrain_weights: https:&#x2F;&#x2F;paddle-imagenet-models-name.bj.bcebos.com&#x2F;ResNet50_cos_pretrained.tar# 验证模型的评测标准，可以选择COCO或者VOCmetric: COCO# 用于模型验证或测试的训练好的权重weights: output&#x2F;mask_rcnn_r50_fpn_1x&#x2F;model_final&#x2F;# 用于训练或验证的数据集的类别数目# **其中包含背景类，即81&#x3D;80 + 1（背景类）**num_classes: 81#####################################模型配置###################################### Mask RCNN元结构，包括了以下主要组件, 具体细节可以参考[论文]( https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1703.06870)MaskRCNN:  backbone: ResNet  fpn: FPN  rpn_head: FPNRPNHead  roi_extractor: FPNRoIAlign  bbox_assigner: BBoxAssigner  bbox_head: BBoxHead  mask_assigner: MaskAssigner  mask_head: MaskHead  rpn_only: false# 主干网络ResNet:  # 配置在哪些阶段加入可变性卷积，默认不添加  dcn_v2_stages: []  # ResNet深度，默认50  depth: 50  # 主干网络返回的主要阶段特征用于FPN作进一步的特征融合  # 默认从[2,3,4,5]返回特征  feature_maps: [2,3,4,5]  # 是否在训练中固定某些权重，默认从第2阶段开始固定，即resnet的stage 1  freeze_at: 2  # 是否停止norm layer的梯度回传，默认是  freeze_norm: true  # norm layer的权重衰退值  norm_decay: 0.0  # norm layer的类型, 可以选择bn&#x2F;sync_bn&#x2F;affine_channel, 默认为affine_channel  norm_type: affine_channel  # ResNet模型的类型, 分为&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;四种, 默认使用&#39;b&#39;类型  variant: b# FPN多特征融合FPN:  # FPN使用的最高层特征后是否添加额外conv，默认false  has_extra_convs: false  # FPN使用主干网络最高层特征，默认是resnet第5阶段后添加额外卷积操作变&lt;成了FPN的第6个，总共有5个阶段  max_level: 6  # FPN使用主干网络最低层特征，默认是resnet第2阶段的输出  min_level: 2  # FPN中使用Norm类型, bn&#x2F;sync_bn&#x2F;affine_channel&#x2F;null, 默认不用null  norm_type: null  # FPN输出特征的通道数量, 默认是256  num_chan: 256  # 特征图缩放比例, 默认是[0.03125, 0.0625, 0.125, 0.25]  spatial_scale: [0.03125, 0.0625, 0.125, 0.25]# 检测第一阶段RPNFPNRPNHead:  # FPN第一层特征生成anchor时，默认anchor尺寸32  anchor_start_size: 32  # RPNHead默认进行前背景二分类  num_classes: 1  # 根据特征图尺寸，在特征图的每个位置生成N个大小、长宽比各不同anchor  # N &#x3D; anchor_sizes * aspect_ratios  # 具体实现参考[API](fluid.layers.anchor_generator)  anchor_generator:    aspect_ratios: [0.5, 1.0, 2.0]    variance: [1.0, 1.0, 1.0, 1.0]  # 首先计算Anchor和GT BBox之间的IoU，为每个Anchor匹配上GT，  # 然后根据阈值过滤掉IoU低的Anchor，得到最终的Anchor及其GT进行loss计算  # 具体实现参考[API](fluid.layers.rpn_target_assign)  rpn_target_assign:    rpn_batch_size_per_im: 256    rpn_fg_fraction: 0.5    rpn_negative_overlap: 0.3    rpn_positive_overlap: 0.7    rpn_straddle_thresh: 0.0  # 首先取topk个分类分数高的anchor  # 然后通过NMS对这topk个anchor进行重叠度检测，对重叠高的两个anchor只保留得分高的  # 训练和测试阶段主要区别在最后NMS保留的Anchor数目  # 训练时输出2000个proposals，推理时输出1000个proposals  # 具体实现参考[API](fluid.layers.generate_proposals)  train_proposal:    min_size: 0.0    nms_thresh: 0.7    post_nms_top_n: 2000    pre_nms_top_n: 2000  test_proposal:    min_size: 0.0    nms_thresh: 0.7    post_nms_top_n: 1000    pre_nms_top_n: 1000# 对FPN每层执行RoIAlign后，然后合并输出结果，用于BBox Head计算FPNRoIAlign:  # 用于抽取特征特征的FPN的层数，默认为4  canconical_level: 4  # 用于抽取特征特征的FPN的特征图尺寸，默认为224  canonical_size: 224  # 用于抽取特征特征的最高层FPN，默认是2  max_level: 5  # 用于抽取特征特征的最底层FPN，默认是2  min_level: 2  #roi extractor的采样率，默认为2  sampling_ratio: 2  # 输出bbox的特征图尺寸，默认为7  box_resolution: 7  # 输出mask的特征图尺寸，默认为14  mask_resolution: 14# 输出实例掩码的HeadMaskHead:  # 卷积的数量，FPN是4，其他为0，默认为0  num_convs: 4  # mask head输出的特征图尺寸，默认14  resolution: 28  # 空洞率，默认为1  dilation: 1  # 第一个卷积后输出的特征图通道数, 默认为256  num_chan_reduced: 256  # 输出的mask的类别，默认为81  num_classes: 81# 求rpn生成的roi跟gt bbox之间的iou，然后根据阈值进行过滤，保留一定数量的roi# 再根据gt bbox的标签，对roi进行标签赋值，即得到每个roi的类别# 具体实现参考[API](fluid.layers.generate_proposal_labels)BBoxAssigner:  batch_size_per_im: 512  bbox_reg_weights: [0.1, 0.1, 0.2, 0.2]  bg_thresh_lo: 0.0  bg_thresh_hi: 0.5  fg_fraction: 0.25  fg_thresh: 0.5# 根据roi的label，选择前景，为其赋值mask label# 具体实现参考[API](fluid.layers.generate_mask_labels)MaskAssigner:  resolution: 28  num_classes: 81# 输出检测框的HeadBBoxHead:  # 在roi extractor和bbox head之间，插入两层FC，对特征做进一步学习  head: TwoFCHead  # 通过NMS进行bbox过滤  # 具体实现参考[API](fluid.layers.multiclass_nms)  nms:    keep_top_k: 100    nms_threshold: 0.5    score_threshold: 0.05# 输出检测框之前，对特征进一步学习TwoFCHead:  # FC输出的特征图通道数，默认是1024  num_chan: 1024#####################################训练配置###################################### 学习率配置LearningRate:  # 初始学习率, 一般情况下8卡gpu，batch size为2时设置为0.02  # 可以根据具体情况，按比例调整  # 比如说4卡V100，bs&#x3D;2时，设置为0.01  base_lr: 0.01  # 学习率规划器  # 具体实现参考[API](fluid.layers.piecewise_decay)  schedulers:    # 学习率衰减策略    # 对于coco数据集，1个epoch大概需要7000个iter    # if step &lt; 120000:    #    learning_rate &#x3D; 0.1    # elif 120000 &lt;&#x3D; step &lt; 160000:    #    learning_rate &#x3D; 0.1 * 0.1    # else:    #    learning_rate &#x3D; 0.1 * (0.1)**2    - !PiecewiseDecay      gamma: 0.1      milestones: [120000, 160000]    # 在训练开始时，调低学习率为base_lr * start_factor，然后逐步增长到base_lr，这个过程叫学习率热身，按照以下公式更新学习率    # linear_step &#x3D; end_lr - start_lr    # lr &#x3D; start_lr + linear_step * (global_step &#x2F; warmup_steps)    # 具体实现参考[API](fluid.layers.linear_lr_warmup)    - !LinearWarmup      start_factor: 0.3333333333333333      steps: 500OptimizerBuilder:  # 默认使用SGD+Momentum进行训练  # 具体实现参考[API](fluid.optimizer)  optimizer:    momentum: 0.9    type: Momentum  # 默认使用L2权重衰减正则化  # 具体实现参考[API](fluid.regularizer)  regularizer:    factor: 0.0001    type: L2#####################################数据配置###################################### 模型训练集设置参考# 训练、验证、测试使用的数据配置主要区别在数据路径、模型输入、数据增强参数设置TrainReader:  # 训练过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，标记的目标框、实例标签、实例分割掩码  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;gt_bbox&#39;, &#39;gt_class&#39;, &#39;is_crowd&#39;, &#39;gt_mask&#39;]  # VOC数据集对应的输入，注意选择VOC时，也要对应修改metric: VOC- # fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;gt_bbox&#39;, &#39;gt_class&#39;, &#39;is_difficult&#39;]  # 数据集目录配置  dataset:    # 指定数据集名称，可以选择VOCDataSet, COCODataSet    !COCODataSet    # 训练图片所在目录    image_dir: train2017    # 标记文件所在目录    anno_path: annotations&#x2F;instances_train2017.json    # 数据集根目录    dataset_dir: dataset&#x2F;coco  # 对一个batch中的单张图片做的数据增强  sample_transforms:  # 读取Image图像为numpy数组  # 可以选择将图片从BGR转到RGB，可以选择对一个batch中的图片做mixup增强  - !DecodeImage    to_rgb: true  # 对图片进行随机翻转  # 可以选择同步翻转mask，可以选择归一化bbox的坐标  - !RandomFlipImage    prob: 0.5  # 归一化图片，默认均值[0.485, 0.456, 0.406]，方差[1, 1, 1]  # 可以选择将归一化结果除以255，可以选择图片的数据格式  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  # 调整图片尺寸，默认采用cv2的线性插值  - !ResizeImage    target_size: 800    max_size: 1333    interp: 1    use_cv2: true  # 调整图片数据格式，默认使用CHW  - !Permute    to_bgr: false    channel_first: true  # 对一个batch中的图片统一做的数据增强  batch_transforms:  # 将一个batch中的图片，按照最大的尺寸，做补齐  - !PadBatch    pad_to_stride: 32    # 选择是否使用padding之后的image信息，默认为false    use_padded_im_info: false  # 1个GPU的batch size，默认为1  batch_size: 1  # 选择是否打乱所有样本的顺序  shuffle: true  # 使用多进程&#x2F;线程的数目，默认为2  worker_num: 2  # 选择是否使用多进程，默认为false  use_process: false  # 如果最后一个batch的图片数量为奇数，选择是否丢掉这个batch，不进行训练，默认是不丢掉的  drop_last: false  # 使用数据集中的样本数目，默认是-1，表示使用全部  samples: -1  # 模型验证集设置参考  EvalReader:  # 验证过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，图片shape  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;im_shape&#39;]  dataset:    !COCODataSet    image_dir: val2017    anno_path: annotations&#x2F;instances_val2017.json    dataset_dir: dataset&#x2F;coco  sample_transforms:  - !DecodeImage    to_rgb: true  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  - !ResizeImage    interp: 1    max_size: 1333    target_size: 800    use_cv2: true  - !Permute    channel_first: true    to_bgr: false    batch_size: 1    shuffle: false    drop_last: false    drop_empty: false    worker_num: 2# 测试验证集设置参考TestReader:  # 测试过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，图片shape  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;im_shape&#39;]  dataset:    # 测试图片所在目录    !ImageFolder    anno_path: annotations&#x2F;instances_val2017.json  sample_transforms:  - !DecodeImage    to_rgb: true    with_mixup: false  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  - !ResizeImage    interp: 1    max_size: 1333    target_size: 800    use_cv2: true  - !Permute    channel_first: true    to_bgr: false  batch_size: 1  shuffle: false  drop_last: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Paddle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RCNN  参数配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2022/11/03/linux-chang-yong-ming-ling/"/>
      <url>/2022/11/03/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看分辨率等信息$ identify xxx.jpg# 关闭模型评估内存异常未正确推出的进程$ ps aux | grep &#39;tools&#x2F;train.py&#39;  | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9$ ps aux | grep &#39;tools&#x2F;eval.py&#39;  | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9# 按照文件大小排序显示，按字节排序，按兆（M）加参数 ‘h’$ du -sh .&#x2F;* | sort -rn   从大到小$ du -sh .&#x2F;* | sort -n    从小到大# 选择部分列出$ du -s &#x2F;usr&#x2F;* | sort -rn | head     前面的10个$ du -s &#x2F;usr&#x2F;* | sort -rn | tail     后面的10个# 查找文件内容$ find .&#x2F; -type f -name &quot;*.xml&quot; | xargs grep &quot;0000280.png&quot;# 远程Copy文件到本地$ scp rtzh@10.11.109.247:&#x2F;data&#x2F;aiimages&#x2F;dataset&#x2F;anjian&#x2F;gkpw.zip .&#x2F;#统计文件数量$ ls -l | grep &quot;^-&quot; | wc -l# 列出 tar.xz 文件内容tar -tf archive.tar.xz#压缩tar –zcvf jpg.tar.gz a&#x2F;# 将文件或者文件件打包为zip压缩包，book.zip大小为38.8Mzip -r book.zip .&#x2F;input.pdf# 将book.zip分割，每个压缩包不超过20M，生成两个压缩包subbook.zip（17.8M）和subbook.z01（21M）zip -s 20m book.zip --out subbook.zip#解压到指定目录tar -zxvf &#x2F;bbs.tar.zip -C &#x2F;zzz&#x2F;bbs    # 解压多个unzip \*.zip #实时显示GPU资源使用情况watch -n 2 -d nvidia-smi #启动 visualdl$ visualdl --logdir .&#x2F;vdl_dir&#x2F;scalar --host 0.0.0.0 --port 8088# 查看Docker环境变量信息$ systemctl show docker --property Environment# Docker proxy config$ &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d$ nano proxy.conf[Service]Environment&#x3D;&quot;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;127.0.0.1:2340&#x2F;&quot;Environment&#x3D;&quot;HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;127.0.0.1:2340&#x2F;&quot;Environment&#x3D;&quot;NO_PROXY&#x3D;localhost,127.0.0.1,.example.com&quot;$ systemctl daemon-reload$ systemctl restart docker$ systemctl status docker#清除历史编译文件夹$ find . -name pom.xml -exec mvn clean -f &#39;&#123;&#125;&#39; \;$ find . -name &#39;target&#39; -a -type d -exec rm -rfv &#39;&#123;&#125;&#39; \;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mAP计算</title>
      <link href="/2022/11/03/map-ji-suan/"/>
      <url>/2022/11/03/map-ji-suan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文链接[<a href="https://aistudio.baidu.com/aistudio/projectdetail/2213799">https://aistudio.baidu.com/aistudio/projectdetail/2213799</a>] </p></blockquote><p>在机器学习领域中，用于评价一个模型的性能有多种指标，其中几项就是FP、FN、TP、TN、精确率(Precision)、召回率(Recall)、准确率(Accuracy)。</p><p>mean Average Precision, 即各类别AP的平均值，是AP：PR 曲线下面积。</p><p>此前先了解一下IOU评判标准：</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/156a2736163b482d9405bbf1a7fc76c8d818d372669642c88f26d7f8f9ad6a1f" alt="img"></p><p>TP、FP、FN、TN</p><p>常见的评判方式，第一位的T,F代表正确或者错误。第二位的P和N代表判断的正确或者错误</p><ul><li>True Positive (TP): IoU&gt;IOUthreshold IoU&gt;<em>I<strong>O</strong>U</em>threshold  (IOU的阈值一般取0.5)的所有检测框数量（同一Ground Truth只计算一次），可以理解为真实框，或者标准答案</li><li>False Positive (FP): IoU&lt;IOUthreshold IoU&lt;<em>I<strong>O</strong>U</em>threshold  的所有检测框数量</li><li>False Negative (FN): 没有检测到的 GT 的数量</li><li>True Negative (TN): mAP中无用到</li></ul><p><img src="https://ai-studio-static-online.cdn.bcebos.com/c9ddb96d1bc94786903d6e3186a951fe7042c831c2ad4d329aaf95298c2eda79" alt="img"></p><p>查准率（Precision）: Precision =TPTP+FP=TP all detections =<em>T**P</em>+<em>F<strong>P</strong>T**P</em>= all detections <em>T**P</em></p><p>查全率（Recall）: Recall =TPTP+FN=TP all ground truths =<em>T**P</em>+<em>F<strong>N</strong>T**P</em>= all ground truths <em>T**P</em></p><p>二者绘制的曲线称为 P-R 曲线： 查准率：P 为纵轴y 查全率：R 为横轴x轴，如下图</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/2505d5e4ce9040879553d2a3252785e9d5cf697d278543999e77ef0b51d2847a" alt="img"></p><p>mAP值即为，PR曲线下的面积。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练过程记录（一）</title>
      <link href="/2022/11/03/xun-lian-guo-cheng-ji-lu-yi/"/>
      <url>/2022/11/03/xun-lian-guo-cheng-ji-lu-yi/</url>
      
        <content type="html"><![CDATA[<p>根据基建赛方提供的数据集进行训练，</p><h3 id="一、首先对数据集进行转换，转化步骤如下"><a href="#一、首先对数据集进行转换，转化步骤如下" class="headerlink" title="一、首先对数据集进行转换，转化步骤如下"></a>一、首先对数据集进行转换，转化步骤如下</h3><h4 id="1、VOC数据集拆分-运行脚本，并设置训练集和验证集比例"><a href="#1、VOC数据集拆分-运行脚本，并设置训练集和验证集比例" class="headerlink" title="1、VOC数据集拆分  运行脚本，并设置训练集和验证集比例"></a>1、VOC数据集拆分  运行脚本，并设置训练集和验证集比例</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">python tools&#x2F;splitData_labelImg.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cd.bjrtzh.com/zentao/file-read-3156.png" alt="img"></p><h4 id="2、voc数据集转coco数据集，转化命令如下"><a href="#2、voc数据集转coco数据集，转化命令如下" class="headerlink" title="2、voc数据集转coco数据集，转化命令如下"></a>2、voc数据集转coco数据集，转化命令如下</h4><p><img src="https://cd.bjrtzh.com/zentao/file-read-3157.png" alt="img"></p><h4 id="3、coco-box转segmentation"><a href="#3、coco-box转segmentation" class="headerlink" title="3、coco box转segmentation"></a>3、coco box转segmentation</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">python tools&#x2F;Segmentations.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cd.bjrtzh.com/zentao/file-read-3158.png" alt="img"></p><h3 id="二、开始训练"><a href="#二、开始训练" class="headerlink" title="二、开始训练"></a>二、开始训练</h3><h4 id="1、设定学习率为"><a href="#1、设定学习率为" class="headerlink" title="1、设定学习率为"></a>1、设定学习率为</h4><p><code>base_lr: 0.00125</code></p><h4 id="2、训练epoch为92轮"><a href="#2、训练epoch为92轮" class="headerlink" title="2、训练epoch为92轮"></a>2、训练epoch为92轮</h4><p>经过观察当训练到60轮次左右时Loss值已经停止下降保持在0.19243如下图所示，下一步将调整学习率增加一倍，并且对数据集进行增强，</p><p>采用线下增强方式，采用 移位（translation）、视角（viewpoint）、大小（size）、照明（illumination）</p><p>（*Paddle也支持线上增强，即在输入模型之前做resize处理）</p><p><img src="https://cd.bjrtzh.com/zentao/file-read-3159.png" alt="img"><br><img src="https://cd.bjrtzh.com/zentao/file-read-3162.png" alt="img"><br><em>optimization分析当前发生local minima或saddle point的原因</em></p><p><img src="https://cd.bjrtzh.com/zentao/file-read-3160.png" alt="img"><img src="https://cd.bjrtzh.com/zentao/file-read-3161.png" alt="img"></p><p>当前训练集仅为800张，数据增强后继续观察。</p>]]></content>
      
      
      <categories>
          
          <category> Deep Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mask rcnn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyper parameter调优</title>
      <link href="/2022/11/02/hyper-parameter-diao-you/"/>
      <url>/2022/11/02/hyper-parameter-diao-you/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/5681667359188_.pic.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Object detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 18.04安装NCCL</title>
      <link href="/2022/11/01/ubuntu-18-04-an-zhuang-nccl/"/>
      <url>/2022/11/01/ubuntu-18-04-an-zhuang-nccl/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu-18-04安装NCCL"><a href="#Ubuntu-18-04安装NCCL" class="headerlink" title="Ubuntu 18.04安装NCCL"></a>Ubuntu 18.04安装NCCL</h1><blockquote><p><a href="https://developer.nvidia.com/nccl/nccl-legacy-downloads">https://developer.nvidia.com/nccl/nccl-legacy-downloads</a></p></blockquote><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>官网下载地址：<a href="https://developer.nvidia.com/nccl/nccl-download">https://developer.nvidia.com/nccl/nccl-download</a><br>注意版本与你的cuda适配。</p><p>2.安装</p><p>获得.deb安装文件如：nccl-local-repo-ubuntu1804-2.8.4-cuda11.1_1.0-1_amd64.deb后</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo dpkg -i nccl-local-repo-ubuntu1804-2.8.4-cuda11.1_1.0-1_amd64.deb  # 安装# 如果提示缺少公共CUDA GPG秘钥sudo apt-key add &#x2F;var&#x2F;nccl-repo-2.8.3-ga-cuda10.2&#x2F;7fa2af80.pub# 必不可少更新sudo apt updatesudo apt install libnccl2 libnccl-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> NVIDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nccl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH tunnel</title>
      <link href="/2022/11/01/ssh-tunnel/"/>
      <url>/2022/11/01/ssh-tunnel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接 <a href="https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/">https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/</a><br><a href="https://www.escapelife.site/posts/e6647650.html">https://www.escapelife.site/posts/e6647650.html</a><br><a href="https://blog.csdn.net/scwMason/article/details/111152300">https://blog.csdn.net/scwMason/article/details/111152300</a></p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>公网服务器B</li><li>需要访问的目标内网服务器A</li></ol><h5 id="公网服务器配置"><a href="#公网服务器配置" class="headerlink" title="公网服务器配置"></a>公网服务器配置</h5><p>修改公网主机 B 的 SSH 配置文件/etc/ssh/sshd_config</p><p>GatewayPorts yes<br>1<br>这样可以把监听的端口绑定到任意 IP 0.0.0.0 上，否则只有本机 127.0.0.1 可以访问。</p><h5 id="重启-sshd-服务"><a href="#重启-sshd-服务" class="headerlink" title="重启 sshd 服务"></a>重启 sshd 服务</h5><p><code>sudo service sshd restart</code><br>内网服务器配置</p><p>在内网主机 A 上，执行以下命令安装 AutoSSH</p><p>How to install AutoSSH on various systems via their package manager.</p><div class="table-container"><table><thead><tr><th>OS</th><th>Install method</th></tr></thead><tbody><tr><td>Debian / Ubuntu</td><td><code>$ sudo apt-get install autossh</code></td></tr><tr><td>CentOS / Fedora / RHEL</td><td><code>$ sudo yum install autossh</code></td></tr><tr><td>ArchLinux</td><td><code>$ sudo pacman -S autossh</code></td></tr><tr><td>FreeBSD</td><td><code># pkg install autossh</code> or <code># cd /usr/ports/security/autossh/ &amp;&amp; make install clean</code></td></tr><tr><td>OSX</td><td><code>$ brew install autossh</code></td></tr></tbody></table></div><p>Alternatively you can also compile and install AutoSSH from source:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;www.harding.motd.ca&#x2F;autossh&#x2F;autossh-1.4e.tgzgunzip -c autossh-1.4e.tgz | tar xvf -cd autossh-1.4e.&#x2F;configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="断线免密登录自动重连"><a href="#断线免密登录自动重连" class="headerlink" title="断线免密登录自动重连"></a>断线免密登录自动重连</h5><p>ssh 反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及 AutoSSH 来提供稳定的 ssh 反向代理隧道。</p><p>1、在内网主机 A 上产生公钥和私钥</p><p><code>ssh-keygen</code><br>然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub 或 id_dsa,id_dsa.pub</p><p>2、拷贝秘钥 在内网主机 A 上继续执行如下命令，将内网主机 A 上的秘钥文件 copy 到公网主机 B 中。</p><p><code>ssh-copy-id  username@ip</code><br>其中“username”是公网主机 B 的用户名，ip 为公网主机 B 的 ip，然后按照提示输入公网主机 B 的密码就完成了。</p><p>启动autossh</p><p><strong>注意</strong></p><p><strong>前提是公网服务器的22001端口（也可自定义）已经开放，没有的话先去设置安全组</strong></p><pre class="line-numbers language-none"><code class="language-none">autossh -M 4010 -NR 10022:localhost:22  root@XXX.XXX.XXX.XXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数解释：</strong></p><ul><li>“-M 4010”意思是使用内网主机 A 的 4010 端口监视 SSH 连接状态，连接出问题了会自动重连</li><li>“ -N”意思是不执行远程命令</li><li>“-R”意思是将远程主机（公网主机 B）的某个端口转发到本地指定机器的指定端口</li></ul><p>代码解释：</p><p>“22001:localhost:4000”意思是将内网主机 A 的 4000 号端口转发至公网主机 B 的 22001 号端口上<br>“username@xxx.xxx.xxx.xxx”意思是公网主机 B 的用户名和 IP<br>“-p xxxx”意思是公网主机 B 的 SSH 端口，如果是默认的 22 号端口，则可以不输入.<br>查看端口情况</p><p><code>lsof -i:4010</code></p><h2 id="AutoSSH-during-boot-with-systemd"><a href="#AutoSSH-during-boot-with-systemd" class="headerlink" title="AutoSSH during boot with systemd"></a>AutoSSH during boot with systemd</h2><p>If you want a permanent SSH tunnel already created during boot time, you will (nowadays) have to create a systemd service and enable it. There is however an important thing to note about systemd and AutoSSH: <code>-f</code> (background usage) already implies <code>AUTOSSH_GATETIME=0</code>, however <code>-f</code> is not supported by systemd.</p><blockquote><p><a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html">http://www.freedesktop.org/software/systemd/man/systemd.service.html</a><br>[…] running programs in the background using “&amp;”, and other elements of shell syntax are not supported.</p></blockquote><p>So in the case of <code>systemd</code> we need to make use of <code>AUTOSSH_GATETIME</code>. Let’s look at a very basic service:</p><pre class="line-numbers language-none"><code class="language-none">$ vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh-ssh-tunnel.service$ sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh-ssh-tunnel.service[Unit]Description&#x3D;AutoSSH service for remote tunnelAfter&#x3D;network.target[Service]Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;User&#x3D;rootExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 4010 -NR 10022:localhost:22  root@39.106.68.XXX[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tell systemd that we have added some stuff:</p><pre class="line-numbers language-none"><code class="language-none">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Start the service</p><pre class="line-numbers language-none"><code class="language-none">systemctl start autossh-ssh-tunnel.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Enable during boot time</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable autossh-ssh-tunnel.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SSH tunnel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> autossh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPN 心跳保护</title>
      <link href="/2022/10/25/vpn-xin-tiao-bao-hu/"/>
      <url>/2022/10/25/vpn-xin-tiao-bao-hu/</url>
      
        <content type="html"><![CDATA[<h2 id="VPN-心跳保护"><a href="#VPN-心跳保护" class="headerlink" title="VPN 心跳保护"></a>VPN 心跳保护</h2><ul><li><p>添加ppp0网络检测<br><code>nano health_vpn.sh</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# &quot;100%&quot;在ping的输出结果中(证明未ping该网段)if ping -w 1 -c 3 192.168.42.1 | grep &quot;100%&quot; &gt;&#x2F;dev&#x2F;null  #未ping通则重启网卡,并重新添加路由表then        echo &quot;192.168.42.1 is Not reachable&quot;        echo &quot;restart docker vpn-client ...&quot;        docker restart vpn-client        echo &quot;ending start vpn...&quot;#ping通则不作处理else        echo &quot;192.168.42.1 is reachable&quot;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#添加执行权限chmod +x health_vpn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>crontab -e 选择要使用的vi工具</p></li><li><p>添加定时计划</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* * * * * sleep 10; &#x2F;home&#x2F;rtzh&#x2F;health_vpn.sh  &gt;&gt;&#x2F;tmp&#x2F;health-vpn.txt#验证成功后可关闭日志，避免日志文件过大* * * * * sleep 10; &#x2F;home&#x2F;rtzh&#x2F;health_vpn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重启cron服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service cron restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看是否启动成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status croncrontab -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="打开cron日志"><a href="#打开cron日志" class="headerlink" title="打开cron日志"></a>打开cron日志</h2><p>Ubuntu系统默认是不打开cron日志的</p><p>如何打开，很简单，控制台输入</p><p><code>vi /etc/rsyslog.d/50-default.conf</code></p><p>打开文件，在文件中找到cron.*，把前面的#去掉，保存退出，输入</p><p><code>sudo service rsyslog restart</code></p><p>重启系统日志，然后稍微等下应该就能在/var/log目录下看到cron.log，vi cron.log就可以查看cron运行日志了。</p><pre class="line-numbers language-none"><code class="language-none">tail -f &#x2F;var&#x2F;log&#x2F;cron.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vpn client </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读记录（2022年10月）</title>
      <link href="/2022/10/20/yue-du-ji-lu/"/>
      <url>/2022/10/20/yue-du-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="2022-10-20"><a href="#2022-10-20" class="headerlink" title="2022-10-20"></a>2022-10-20</h2><ul><li><strong>mmdection环境搭建</strong><br><a href="https://pytorch.org/get-started/previous-versions/">PyThorch历史版本安装</a><br><a href="https://blog.csdn.net/Singlepledge/article/details/107138749">Ubuntu 20.04 : 几个BT下载软件和命令</a><br><a href="https://blog.csdn.net/weixin_45385568/article/details/115084264">ubuntu20.04显卡驱动 cuda cudnn安装</a><br><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">cudnn安装</a><br><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA历史版本官方下载地址</a><br><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">显卡驱动与CUDA版本对应关系</a><br><a href="https://blog.csdn.net/Yana_Zeng/article/details/119539835">pytorch安装</a><br><a href="https://pytorch.org/get-started/previous-versions/">pytorch历史版本</a><br><a href="https://blog.csdn.net/qq_26794857/article/details/111878108">NCCL安装</a></li></ul><h2 id="2022-10-21"><a href="#2022-10-21" class="headerlink" title="2022-10-21"></a>2022-10-21</h2><p>  <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">Nvidia-docker install guide</a><br>  <a href="https://support.strongvpn.com/hc/en-us/articles/360039667713-IKEv2-Setup-Ubuntu-18-and-above-on-Command-Line">Ubuntu IPSec vpn安装</a><br>  <a href="https://hub.docker.com/r/fengzhou/ipsec-vpn-client">ipsec-vpn-client docker</a></p><h2 id="2022-10-24"><a href="#2022-10-24" class="headerlink" title="2022-10-24"></a>2022-10-24</h2><p>  <a href="https://blog.csdn.net/qq_41627642/article/details/124803970">Swin-Transformer-Object-Detection V2.11.0环境搭建</a><br>  <a href="https://blog.csdn.net/CSDN_X_W/article/">Swin Transformer Object Detection 目标检测-1</a><br>  <a href="https://blog.csdn.net/weixin_44347020/article/details/116153242">基于mmdetection训练Swin Transformer Object Detection</a><br>  <a href="https://github.com/microsoft/Swin-Transformer">Swin-Transformer</a></p><h2 id="2022-10-27"><a href="#2022-10-27" class="headerlink" title="2022-10-27"></a>2022-10-27</h2><p>  <a href="https://www.paddlepaddle.org.cn/whl/linux/mkl/avx/stable.html">PaddlePaddle安装包</a><br>  <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/version/cudnn_cn.html">PaddlePaddle Api</a><br>  <a href="https://github.com/alibaba/EasyCV/blob/master/docs/source/data_hub.md">alibaba EasyCV datahub</a><br>  <a href="https://blog.csdn.net/qq_38410428/article/details/103645212">遥感数据集</a><br>  <a href="https://xie.infoq.cn/article/3c4afe81a2e2693eb23406752">alibaba EasyCV datahub</a><br>  <a href="https://github.com/mcordts/cityscapesScripts">Cityscapes数据集</a><br>  <a href="https://blog.csdn.net/hanruiding/article/details/89493466">按文件大小排序</a></p><h2 id="2022-11-1"><a href="#2022-11-1" class="headerlink" title="2022-11-1"></a>2022-11-1</h2><p>  <a href="https://blog.csdn.net/weixin_43152331/article/details/124929760">conda自动补全</a><br>  <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/version/cudnn_cn.html">Paddle cudnn</a></p><h2 id="2022-11-2"><a href="#2022-11-2" class="headerlink" title="2022-11-2"></a>2022-11-2</h2><p>  <a href="https://blog.csdn.net/qq_40265247/article/details/121275111">数据集处理</a><br>  <a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">Hexo插入图片</a><br>  <a href="https://aistudio.baidu.com/aistudio/projectdetail/1422430?channelType=0&amp;channel=0">PaddleDetection源码解析</a><br>  <a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme">VSCode theme</a></p><h2 id="2022-11-3"><a href="#2022-11-3" class="headerlink" title="2022-11-3"></a>2022-11-3</h2><p>  <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/distributed/launch_cn.html">Paddle多机多卡训练</a><br>  <a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/install/download_lib.html">Cuda cuDNN TensorRT Paddle_Inference依赖关系</a><br>  <a href="https://docs.nvidia.com/deeplearning/tensorrt/archives/tensorrt-801/install-guide/index.html">TensorRT安装</a><br>  <a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/quick_start/python_demo.html">Paddle TensorRT推理验证</a><br>  <a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/nv_gpu_infer/gpu_trt_infer.html">GPU TensorRT 加速推理(NV-GPU/Jetson)</a><br>  <a href="https://aistudio.baidu.com/aistudio/projectdetail/2213799">数据增强</a><br>  <a href="https://cocodataset.org/#download">Coco Dataset</a><br>  <a href="https://docs.onepanel.ai/docs/deployment/configuration/miniotenants/">Onepanel Configuration</a></p><h2 id="2022-11-4"><a href="#2022-11-4" class="headerlink" title="2022-11-4"></a>2022-11-4</h2><p>  <a href="https://cvat-ai.github.io/datumaro/docs/getting_started/">Dataset Management Framework</a></p><h2 id="2022-11-7"><a href="#2022-11-7" class="headerlink" title="2022-11-7"></a>2022-11-7</h2><p>  <a href="http://loginzlib2vrak5zzpcocc3ouizykn6k5qecgj2tzlnab5wcbqhembyd.onion/">打死都不说</a><br>  <a href="https://paddledetection.readthedocs.io/tutorials/GETTING_STARTED.html">PaddleDetection tutorial</a></p><h2 id="2022-11-9"><a href="#2022-11-9" class="headerlink" title="2022-11-9"></a>2022-11-9</h2><p>  <a href="https://www.cnblogs.com/makefile/p/nms.html">Non-Maximum Suppression，NMS</a></p><h2 id="2022-11-10"><a href="#2022-11-10" class="headerlink" title="2022-11-10"></a>2022-11-10</h2><p>  <a href="https://zhuanlan.zhihu.com/p/514636147">ZSH</a><br>  <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">ZSH Theme</a><br>  <a href="https://blog.csdn.net/qq_44315987/article/details/112759477">JupyterLab ipykernel</a><br>  <a href="https://zhuanlan.zhihu.com/p/534555250">JupyterLab ipykernel</a></p><h2 id="2022-11-11"><a href="#2022-11-11" class="headerlink" title="2022-11-11"></a>2022-11-11</h2><p>  <a href="https://monitor.firefox.com/breaches?">firefox monitor</a></p><h2 id="2022-11-15"><a href="#2022-11-15" class="headerlink" title="2022-11-15"></a>2022-11-15</h2><p>  <a href="https://note.qidong.name/2020/05/docker-proxy/">docker proxy</a></p><h2 id="2022-11-24"><a href="#2022-11-24" class="headerlink" title="2022-11-24"></a>2022-11-24</h2><p>  <a href="https://developer.nvidia.com/zh-cn/blog/gpu-dashboards-in-jupyter-lab/">Jupyter 实验室中的 GPU 仪表板</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 阅读记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microk8s曲线救国</title>
      <link href="/2022/10/14/microk8s-qu-xian-jiu-guo/"/>
      <url>/2022/10/14/microk8s-qu-xian-jiu-guo/</url>
      
        <content type="html"><![CDATA[<h2 id="一-安装前的准备"><a href="#一-安装前的准备" class="headerlink" title="一. 安装前的准备"></a>一. 安装前的准备</h2><ol><li>安装 pullk8s 工具，此工具可以通过 hub.docker.com 的 opsdockerimage 仓库下载k8s所需的 k8s.gcr.io 或 gcr.io 镜像，无需自己翻墙，每天更新一次，包括所有image 的全平台的所有tags。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo curl -L &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;OpsDocker&#x2F;pullk8s&#x2F;main&#x2F;pullk8s.sh&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pullk8s$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pullk8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s COMMAND [NAME[:TAG|@DIGEST]] [OPTIONS]Pull gcr.io&#39;s image for hub.docker.comCommands:  check    Check gcr.io&#39;s fail pull images.  pull     Pull an image or a repositoryOptions:  --microk8s  If use MicroK8s release.Examples:  pullk8s pull gcr.io&#x2F;google_containers&#x2F;etcd:2.0.12  pullk8s pull k8s.gcr.io&#x2F;etcd:2.0.12  pullk8s pull k8s.gcr.io&#x2F;pause:3.6 --microk8s  pullk8s check --microk8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>安装 snap ,Ubuntu 目前已经支持。</p><p>其他系统的安装见 Installing snapd | Snapcraft documentation    <a href="https://snapcraft.io/docs/installing-snapd">https://snapcraft.io/docs/installing-snapd</a></p></li></ol><h2 id="检查被屏蔽的-gcr-io-或-k8s-gcr-io-容器名称"><a href="#检查被屏蔽的-gcr-io-或-k8s-gcr-io-容器名称" class="headerlink" title="检查被屏蔽的 gcr.io 或 k8s.gcr.io 容器名称"></a>检查被屏蔽的 gcr.io 或 k8s.gcr.io 容器名称</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s check --microk8sk8s.gcr.io&#x2F;pause:3.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>此时提示的 k8s.gcr.io/pause:3.1 就是pull 失败的容器名称</p><ul><li>因 microk8s 启动需要时间，可能要执行多次才能看到失败的容器名称，</li><li>使用 pullk8s 拉取失败的镜像，并导入到 pod 空间中</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s pull k8s.gcr.io&#x2F;pause:3.1 --microk8s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> microk8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pullk8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>install onepanel</title>
      <link href="/2022/10/14/install-onepanel/"/>
      <url>/2022/10/14/install-onepanel/</url>
      
        <content type="html"><![CDATA[<h2 id="Install-onepanel"><a href="#Install-onepanel" class="headerlink" title="Install onepanel"></a>Install onepanel</h2><h2 id="Install-onepanel-1"><a href="#Install-onepanel-1" class="headerlink" title="Install onepanel"></a>Install onepanel</h2><blockquote><p>官方参考文档    </p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/files/">https://docs.onepanel.ai/docs/deployment/configuration/files/</a></p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/#configure-local-dns">https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/#configure-local-dns</a></p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/">https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/</a></p><p>Git Blog</p></blockquote><p><strong>1    Install microk8s using the command line</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo snap install microk8s --channel&#x3D;1.21&#x2F;stable --classicsudo snap alias microk8s.kubectl kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2 Make sure your current user has permissions to work with <code>microk8s</code>.</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo usermod -a -G microk8s $USERsudo chown -f -R $USER ~.&#x2F;kube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Configuring the proxy environment variables</strong></p><p><em>启用proxy后需要在安装k8s基础容器后关闭代理</em></p><p>修改配置文件<code>/etc/environment</code> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo nano &#x2F;etc&#x2F;environmentHTTPS_PROXY&#x3D;http:&#x2F;&#x2F;squid.internal:3128HTTP_PROXY&#x3D;http:&#x2F;&#x2F;squid.internal:3128NO_PROXY&#x3D;10.0.0.0&#x2F;8,192.168.0.0&#x2F;16,127.0.0.1,172.16.0.0&#x2F;16https_proxy&#x3D;http:&#x2F;&#x2F;squid.internal:3128http_proxy&#x3D;http:&#x2F;&#x2F;squid.internal:3128no_proxy&#x3D;10.0.0.0&#x2F;8,192.168.0.0&#x2F;16,127.0.0.1,172.16.0.0&#x2F;16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>we need to configure <code>NO_PROXY</code> and <code>no_proxy</code> with the IP ranges the pods and services occupy</p><p>For the changes to take effect we need to restart MicroK8s:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stopmicrok8s start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Wait for it to be ready.</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3 Enable the following required add-ons:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo microk8s enable storage dns rbac<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4 Update API server config<code>(optional)</code></strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;args&#x2F;kube-apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add to the top</p><pre class="line-numbers language-none"><code class="language-none">--service-account-signing-key-file&#x3D;$&#123;SNAP_DATA&#125;&#x2F;certs&#x2F;serviceaccount.key--service-account-key-file&#x3D;$&#123;SNAP_DATA&#125;&#x2F;certs&#x2F;serviceaccount.key--service-account-issuer&#x3D;api--service-account-api-audiences&#x3D;api,nats<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Restart microk8s for the changes to take effect</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5 Enable microk8s addons</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo microk8s enable storage dns rbacmicrok8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Check <code>node</code> and <code>pod</code> status</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-------------node status----------root@rtzh-virtual-k8s:~# sudo microk8s.kubectl get nodeNAME               STATUS   ROLES    AGE   VERSIONrtzh-virtual-k8s   Ready    &lt;none&gt;   18m   v1.21.13-3+cbc10c94808907------------pod status-------------root@rtzh-virtual-k8s:~# sudo microk8s.kubectl get pod --all-namespaces NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGEkube-system   calico-kube-controllers-f7868dd95-hfmz5   1&#x2F;1     Running   0          19mkube-system   calico-node-k8kk6                         1&#x2F;1     Running   0          19mkube-system   hostpath-provisioner-566686b959-lk6hg     1&#x2F;1     Running   0          2m55skube-system   coredns-7f9c69c78c-2fsrt                  1&#x2F;1     Running   0          2m53s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Configure DNS</strong></p><p>i. Edit the resolvconf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;args&#x2F;kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add to the top</p><pre class=" language-lang---resolv-conf=/run/systemd/resolve/resolv.conf```"><code class="language-lang---resolv-conf=/run/systemd/resolve/resolv.conf```">ii. Edit coredns configmap so we point to the resolv.conf file<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s kubectl edit cm coredns -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>Set the forward section to:```forward . /etc/resolv.conf 8.8.8.8  8.8.4.4</code></pre><p>iii. Restart microk8s</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Install-Onepanel"><a href="#Install-Onepanel" class="headerlink" title="Install Onepanel#"></a>Install Onepanel<a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s#install-onepanel">#</a></h2><ol><li><p>Install</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># startvpncurl -sLO https:&#x2F;&#x2F;github.com&#x2F;onepanelio&#x2F;onepanel&#x2F;releases&#x2F;latest&#x2F;download&#x2F;opctl-linux-amd64chmod +x opctl-linux-amd64sudo mv .&#x2F;opctl-linux-amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;opctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Initialize Onepanel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">opctl init --provider microk8s \--enable-metallb \--artifact-repository-provider s3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>params.yaml</code>按照模板中的说明进行填充，并参阅<a href="https://docs.onepanel.ai/docs/deployment/configuration/files#sections">配置文件部分</a>以获取更多详细信息。</p><pre class="line-numbers language-none"><code class="language-none"># - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Generated with Onepanel CLI # CLI version: v1.0.2# Command: opctl init --provider microk8s --enable-metallb --artifact-repository-provider s3# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Onepanel# Description: Onepanel application information# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -application:  defaultNamespace: example  domain: onepanel.test  fqdn: app.onepanel.test  insecure: true  nodePool:    label: node.kubernetes.io&#x2F;instance-type    options:      - name: &#39;Local machine&#39;        value: &#39;local&#39;  provider: microk8s# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Artifact repository# Description: S3 compatible object storage for storing files across Onepanel# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -artifactRepository:  s3:    # S3 access key    accessKey: &#39;minio&#39;    # Name of bucket, example: my-bucket    bucket: &#39;mybucket&#39; # Your bucket here    endpoint: &#39;minio.example.svc.cluster.local&#39; # replace &#96;example&#96; with your namespace    # Change to true if endpoint does NOT support HTTPS    insecure: true    # Key Format for objects stored by Workflows. This can reference Workflow variables    keyFormat: artifacts&#x2F;&#123;&#123;workflow.namespace&#125;&#125;&#x2F;&#123;&#123;workflow.name&#125;&#125;&#x2F;&#123;&#123;pod.name&#125;&#125;    publicEndpoint: 10.1.131.146:9000 # The IP address from minio    # Bucket region, this can be anything since it is running locally    region: us-west-2    # S3 secret key    secretKey: &#39;minio123&#39;# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: cert-manager# Description: automatically creates and renews TLS certificates using Let&#39;s Encrypt# Docs: https:&#x2F;&#x2F;onepanelio.github.io&#x2F;core-docs&#x2F;docs&#x2F;deployment&#x2F;configuration&#x2F;tls# CLI flag: --enable-cert-manager# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -certManager:  email: test@test.com # Not used in local deployments as certs are generated locally# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Application and kubernetes load balancing on non-cloud deployments.# Description: MetalLB, LoadBalancer# CLI flag: --enable-metallb# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -metalLb:  addresses:    - 192.168.99.0&#x2F;32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Deploy onepanel</p><blockquote><p><code>issue</code> kfserving controller image pull unauthorized</p></blockquote><p>Modifying the kfserving version before deploying onepanel</p><p>If you have already executed <code>kubeconfig opctl apply</code>, delete  cache file </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf .onepanel&#x2F;kubernetes.yamlrm -rf .onepanel&#x2F;manifests&#x2F;cache&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nano .onepanel&#x2F;manifests&#x2F;v1.0.2&#x2F;kfserving&#x2F;base&#x2F;kfserving.yaml# change- gcr.io&#x2F;kfserving&#x2F;kfserving-controller:v0.6.0to+ kfserving&#x2F;kfserving-controller:v0.6.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s config &gt; kubeconfigKUBECONFIG&#x3D;.&#x2F;kubeconfig opctl apply<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="Expose-Onepanel-using-Nginx"><a href="#Expose-Onepanel-using-Nginx" class="headerlink" title="Expose Onepanel using Nginx"></a>Expose Onepanel using Nginx</h2><p>First, install nginx.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Then, configure nginx to expose Onepanel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Change this</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;        # First attempt to serve request as file, then        # as directory, then fall back to displaying a 404.        try_files $uri $uri&#x2F; &#x3D;404;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>to</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;  client_max_body_size 0; # No size limit to upload requests      proxy_pass http:&#x2F;&#x2F;192.168.99.0; # the ip address you gave metallb  proxy_set_header Host $host;  proxy_http_version 1.1;  proxy_set_header Upgrade $http_upgrade;  proxy_set_header Connection &quot;upgrade&quot;;  proxy_request_buffering off;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, stop editing and run</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Configure-Local-DNS"><a href="#Configure-Local-DNS" class="headerlink" title="Configure Local DNS"></a>Configure Local DNS</h2><p><code>/etc/hosts</code></p><p>添加一行</p><p>For this example, we will assume the IP is: 10.9.98.213</p><pre class="line-numbers language-none"><code class="language-none"># &lt;ip&gt; &lt;fqdn&gt;10.9.98.213 app.onepanel.test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>常用命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s.kubectl describe node# Describe a nodemicrok8s.kubectl describe node ml#跟踪Node节点信息microk8s.kubectl describe pods -A #显示所有pod信息microk8s.kubectl describe pod kfserving-controller-manager-0 -n kfserving-system  #显示指定pod详细信息microk8s.kubectl delete deployment kfserving-models-web-app -n kfserving-system #删除deploymentmicrok8s.kubectl delete pod kfserving-controller-manager-0 -n kfserving-system #删除podmicrok8s.kubectl get pods --all-namespaces #同下microk8s kubectl get pods -A# 获取所有pod执行状态microk8s kubectl get deployment -A# 查看所有部署microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready  #重启microk8s.kubectl logs -f onepanel-core-ui-7d9b8d5954-bbtzv -n onepanel#查看日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> onepanel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu install vnc</title>
      <link href="/2022/10/13/ubuntu-install-vnc/"/>
      <url>/2022/10/13/ubuntu-install-vnc/</url>
      
        <content type="html"><![CDATA[<h3 id="Install-and-Configure-a-VNC-in-Ubuntu"><a href="#Install-and-Configure-a-VNC-in-Ubuntu" class="headerlink" title="Install and Configure a VNC in Ubuntu"></a>Install and Configure a VNC in Ubuntu</h3><p>To install <strong>TigerVNC</strong> server and other associated packages in Ubuntu, run the following command.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo apt install tigervnc-standalone-server tigervnc-common tigervnc-xorg-extension tigervnc-viewer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Now start the VNC server by running the <strong>vncserver</strong> command as a normal user. This action will create the initial configuration stored in the <code>$HOME/.vnc</code> directory and it will also prompt you to set up a login password.</p><p>Enter a password (which must be at least six characters length) and confirm/verify it. Then set a view-only password if you wish, as follows.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver$ ls -l ~&#x2F;.vnc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Next, we need to configure the DE to work with the VNC <strong>server. So, stop the \</strong>VNC*<em> server using the following command, in order to perform some configurations.*</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ vncserver -kill :1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To configure <strong>GNOME</strong> or whatever desktop you have installed, create a file called <strong>xstartup</strong> under the configurations directory using your <a href="https://www.tecmint.com/linux-command-line-editors/">favorite text editor</a>.</p><pre class="line-numbers language-none"><code class="language-none">$ vi ~&#x2F;.vnc&#x2F;xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add the following lines in the file. These commands will be automatically executed whenever you start or restart the TigerVNC server. Note that the commands may vary depending on the DE you installed.</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;shexec &#x2F;etc&#x2F;vnc&#x2F;xstartupxrdb $HOME&#x2F;.Xresourcesvncconfig -iconic &amp;dbus-launch --exit-with-session gnome-session &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Save the file and set the appropriate permission on the file so it can be executed.</p><pre class="line-numbers language-none"><code class="language-none">$ chmod 700 ~&#x2F;.vnc&#x2F;xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Next, start the <strong>VNC</strong> server by running the following command as a normal user. Set your own values for the display geometry. In addition, use the <code>-localhost</code> flag to allow connections from the <strong>localhost</strong> only and by analogy, only from users authenticated on the server.</p><p>In addition, <strong>VNC</strong> by default uses TCP port <code>5900+N</code>, where <code>N</code> is the display number. In this case, the <code>:1</code> means that the VNC server will run on display port number <strong>5901</strong>.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver :1 -localhost -geometry 1024x768 -depth 32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To list <strong>VNC</strong> server sessions on your system, run the following command.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver -list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Once the VNC server has started, check the port it is running on with the <a href="https://www.tecmint.com/20-netstat-commands-for-linux-network-management/">netstat command</a>.</p><pre class="line-numbers language-none"><code class="language-none">$ netstat -tlnp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">vncserver -localhost no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remote vnc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>microk8s安装onepanel</title>
      <link href="/2022/10/13/microk8s-an-zhuang-onepanel/"/>
      <url>/2022/10/13/microk8s-an-zhuang-onepanel/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-Dashboard</title>
      <link href="/2022/10/10/kubernetes-dashboard/"/>
      <url>/2022/10/10/kubernetes-dashboard/</url>
      
        <content type="html"><![CDATA[<h5 id="1-部署和访问-Kubernetes-仪表板"><a href="#1-部署和访问-Kubernetes-仪表板" class="headerlink" title="1.部署和访问 Kubernetes 仪表板"></a>1.部署和访问 Kubernetes 仪表板</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo recommended.yaml https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.6.1&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml#修改刚下载的yaml文件，添加type: NodePort -&gt; 外网访问$ vim recommended.yaml# ------------------- Dashboard Service ------------------- #kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  ports:    - port: 443      targetPort: 8443  selector:    k8s-app: kubernetes-dashboard  type: NodePort----------------------------------------------------------------# create -f 创建dashboard$ kubectl create -f recommended.yaml# 查看namespace为kubernetes-dashboard下创建的pods$ kubectl get pods -n kubernetes-dashboard--------------------------------------------------------------------------NAME                                    READY   STATUS    RESTARTS   AGEkubernetes-dashboard-5fd74ddbcd-2m4j6   1&#x2F;1     Running   0          3d23h$ kubectl proxy &amp;# Starting to serve on 127.0.0.1:8001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Access Control:</strong> 创建一个admin账号，否则进去之后无法观测各个小集群的信息(没有admin权限登录后各个界面都没有集群信息)</p><pre class="line-numbers language-applescript" data-language="applescript"><code class="language-applescript">$ vim dashboard_admin.yaml# *** 请替换为你想创建的名字----------------------------------------apiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRoleBindingmetadata:  name: ***  namespace: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:  - kind: ServiceAccount    name: ***    namespace: kubernetes-dashboard-----------------------------------------$ kubectl create -f dashboard_admin.yaml# 查找名为*** secret token$ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep ***| awk &#39;&#123;print $1&#125;&#39;)----------------------------------------------------token:   eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJl.....# 复制这长一串的token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>Chrome可能回因为证书问题无法访问</em></p><pre class="line-numbers language-autohotkey" data-language="autohotkey"><code class="language-autohotkey">在chrome该页面上，直接键盘敲入这12个字符：&#96;thisisunsafe&#96;**注意：鼠标点击当前页面任意位置，让页面处于最上层即可输入**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-通过局域网访问"><a href="#2-通过局域网访问" class="headerlink" title="2.通过局域网访问"></a>2.通过局域网访问</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl port-forward -n kubernetes-dashboard --address 0.0.0.0 service&#x2F;kubernetes-dashboard 8080:443<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建一个dashboard管理用户</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create serviceaccount dashboard-admin -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>绑定用户为集群管理用户</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole&#x3D;cluster-admin --serviceaccount&#x3D;kube-system:dashboard-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完以上操作后,由于管理用户的名称为<code>dashboard-admin</code>,生成的对应的secret的值则为<code>dashboard-admin-token-随机字符串</code>我的机器上完整名称为<code>dashboard-admin-token-sg6bp</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[centos@k8s-master dashboard]$ kubectl get secret -n&#x3D;kube-system |grep dashboard-admin-tokendashboard-admin-token-sg6bp                      kubernetes.io&#x2F;service-account-token   3      23h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到这个secret的完整名称,或者不使用grep管道,列出所有的secrets,然后从中寻找需要的.</p><p>通过上面介绍过的<code>kubectl describe secret</code>命令查看token</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[centos@k8s-master dashboard]$ kubectl describe -n&#x3D;kube-system  secret dashboard-admin-token-sg6bpName:         dashboard-admin-token-sg6bpNamespace:    kube-systemLabels:       &lt;none&gt;Annotations:  kubernetes.io&#x2F;service-account.name: dashboard-admin              kubernetes.io&#x2F;service-account.uid: c60d2a65-619e-11e9-a627-0050568417a2Type:  kubernetes.io&#x2F;service-account-tokenData&#x3D;&#x3D;&#x3D;&#x3D;ca.crt:     1025 bytesnamespace:  11 bytestoken:      eyJhbGciOiJSUzI1NiIsImtp...[centos@k8s-master dashboard]$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把以上token复制到登陆页面的token栏里,就可以登陆了.登陆以后就可以看到如上面最后展示的有完整信息的界面.</p><h5 id="3-获取token"><a href="#3-获取token" class="headerlink" title="3.获取token"></a>3.获取token</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get secret -n&#x3D;kube-system |grep dashboard-admin-tokenkubectl describe -n&#x3D;kube-system  secret dashboard-admin-token-t854k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dashboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes-kubectl安装</title>
      <link href="/2022/10/08/kubernetes-kubectl-an-zhuang/"/>
      <url>/2022/10/08/kubernetes-kubectl-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h1 id="在-Linux-系统中安装并设置-kubectl"><a href="#在-Linux-系统中安装并设置-kubectl" class="headerlink" title="在 Linux 系统中安装并设置 kubectl"></a>在 Linux 系统中安装并设置 kubectl</h1><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><p>kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.25 版本的客户端能与 v1.24、 v1.25 和 v1.26 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。</p><h2 id="在-Linux-系统中安装-kubectl"><a href="#在-Linux-系统中安装-kubectl" class="headerlink" title="在 Linux 系统中安装 kubectl"></a>在 Linux 系统中安装 kubectl</h2><p>在 Linux 系统中安装 kubectl 有如下几种方法：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-kubectl-binary-with-curl-on-linux">用 curl 在 Linux 系统中安装 kubectl</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-using-native-package-management">用原生包管理工具安装</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-using-other-package-management">用其他包管理工具安装</a></li></ul><h3 id="用-curl-在-Linux-系统中安装-kubectl"><a href="#用-curl-在-Linux-系统中安装-kubectl" class="headerlink" title="用 curl 在 Linux 系统中安装 kubectl"></a>用 curl 在 Linux 系统中安装 kubectl</h3><ol><li><p>用以下命令下载最新发行版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明：</strong></p><p>如需下载某个指定的版本，请用指定版本号替换该命令的这一部分： <code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code>。</p><p>例如，要在 Linux 中下载 v1.25.0 版本，请输入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;v1.25.0&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证该可执行文件（可选步骤）</p><p>下载 kubectl 校验和文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl.sha256&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于校验和文件，验证 kubectl 的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;$(cat kubectl.sha256)  kubectl&quot; | sha256sum --check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证通过时，输出为：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">kubectl: OK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证失败时，<code>sha256</code> 将以非零值退出，并打印如下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl: FAILEDsha256sum: WARNING: 1 computed checksum did NOT match<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>下载的 kubectl 与校验和文件版本必须相同。</p></li><li><p>安装 kubectl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo install -o root -g root -m 0755 kubectl &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明：</strong></p><p>即使你没有目标系统的 root 权限，仍然可以将 kubectl 安装到目录 <code>~/.local/bin</code>中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x kubectlmkdir -p ~&#x2F;.local&#x2F;binmv .&#x2F;kubectl ~&#x2F;.local&#x2F;bin&#x2F;kubectl# 之后将 ~&#x2F;.local&#x2F;bin 附加（或前置）到 $PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行测试，以保障你安装的版本是最新的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl version --client<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用如下命令来查看版本的详细信息：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">kubectl version --client --output&#x3D;yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="用原生包管理工具安装"><a href="#用原生包管理工具安装" class="headerlink" title="用原生包管理工具安装"></a>用原生包管理工具安装</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-install-0">基于 Debian 的发行版</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-install-1">基于 Red Hat 的发行版</a></li></ul><ol><li><p>更新 <code>apt</code> 包索引，并安装使用 Kubernetes <code>apt</code> 仓库所需要的包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y ca-certificates curl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 Debian 9（stretch）或更早版本，则你还需要安装 <code>apt-transport-https</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install -y apt-transport-https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>下载 Google Cloud 公开签名秘钥：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加 Kubernetes <code>apt</code> 仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg] https:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>更新 <code>apt</code> 包索引，使之包含新的仓库并安装 kubectl：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="用其他包管理工具安装"><a href="#用其他包管理工具安装" class="headerlink" title="用其他包管理工具安装"></a>用其他包管理工具安装</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#other-kubectl-install-0">Snap</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#other-kubectl-install-1">Homebrew</a></li></ul><p>如果你使用的 Ubuntu 或其他 Linux 发行版，内建支持 <a href="https://snapcraft.io/docs/core/install">snap</a> 包管理工具， 则可用 <a href="https://snapcraft.io/">snap</a> 命令安装 kubectl。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">snap install kubectl --classickubectl version --client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="验证-kubectl-配置"><a href="#验证-kubectl-配置" class="headerlink" title="验证 kubectl 配置"></a>验证 kubectl 配置</h2><p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个 <a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>， 该文件在 <a href="https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh">kube-up.sh</a> 创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。 通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p><p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl cluster-info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p><p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p><pre class="line-numbers language-none"><code class="language-none">The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p><p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl cluster-info dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="kubectl-的可选配置和插件"><a href="#kubectl-的可选配置和插件" class="headerlink" title="kubectl 的可选配置和插件"></a>kubectl 的可选配置和插件</h2><h3 id="启用-shell-自动补全功能"><a href="#启用-shell-自动补全功能" class="headerlink" title="启用 shell 自动补全功能"></a>启用 shell 自动补全功能</h3><p>kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。</p><p>下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-0">Bash</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-1">Fish</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-2">Zsh</a></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>kubectl 的 Bash 补全脚本可以用命令 <code>kubectl completion bash</code> 生成。 在 Shell 中导入（Sourcing）补全脚本，将启用 kubectl 自动补全功能。</p><p>然而，补全脚本依赖于工具 <a href="https://github.com/scop/bash-completion"><strong>bash-completion</strong></a>， 所以要先安装它（可以用命令 <code>type _init_completion</code> 检查 bash-completion 是否已安装）。</p><h3 id="安装-bash-completion"><a href="#安装-bash-completion" class="headerlink" title="安装 bash-completion"></a>安装 bash-completion</h3><p>很多包管理工具均支持 bash-completion（参见<a href="https://github.com/scop/bash-completion#installation">这里</a>）。 可以通过 <code>apt-get install bash-completion</code> 或 <code>yum install bash-completion</code> 等命令来安装它。</p><p>上述命令将创建文件 <code>/usr/share/bash-completion/bash_completion</code>，它是 bash-completion 的主脚本。 依据包管理工具的实际情况，你需要在 <code>~/.bashrc</code> 文件中手工导入此文件。</p><p>要查看结果，请重新加载你的 Shell，并运行命令 <code>type _init_completion</code>。 如果命令执行成功，则设置完成，否则将下面内容添加到文件 <code>~/.bashrc</code> 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新加载 Shell，再输入命令 <code>type _init_completion</code> 来验证 bash-completion 的安装状态。</p><h3 id="启动-kubectl-自动补全功能"><a href="#启动-kubectl-自动补全功能" class="headerlink" title="启动 kubectl 自动补全功能"></a>启动 kubectl 自动补全功能</h3><h4 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h4><p>你现在需要确保一点：kubectl 补全脚本已经导入（sourced）到 Shell 会话中。 可以通过以下两种方法进行设置：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-bash-autocompletion-0">当前用户</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-bash-autocompletion-1">系统全局</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;source &lt;(kubectl completion bash)&#39; &gt;&gt;~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;alias k&#x3D;kubectl&#39; &gt;&gt;~&#x2F;.bashrcecho &#39;complete -o default -F __start_kubectl k&#39; &gt;&gt;~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>bash-completion 负责导入 <code>/etc/bash_completion.d</code> 目录中的所有补全脚本。</p><p>两种方式的效果相同。重新加载 Shell 后，kubectl 自动补全功能即可生效。 若要在当前 Shell 会话中启用 Bash 补全功能，需要运行 <code>exec bash</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exec bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装-kubectl-convert-插件"><a href="#安装-kubectl-convert-插件" class="headerlink" title="安装 kubectl convert 插件"></a>安装 <code>kubectl convert</code> 插件</h3><p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。 这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。 更多信息请访问 <a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis">迁移到非弃用 API</a></p><ol><li><p>用以下命令下载最新发行版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl-convert&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证该可执行文件（可选步骤）</p><p>下载 kubectl-convert 校验和文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl-convert.sha256&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于校验和，验证 kubectl-convert 的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;$(cat kubectl-convert.sha256) kubectl-convert&quot; | sha256sum --check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证通过时，输出为：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">kubectl-convert: OK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证失败时，<code>sha256</code> 将以非零值退出，并打印输出类似于：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl-convert: FAILEDsha256sum: WARNING: 1 computed checksum did NOT match<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>下载相同版本的可执行文件和校验和。</p></li><li><p>安装 kubectl-convert</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo install -o root -g root -m 0755 kubectl-convert &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl-convert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证插件是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl convert --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你没有看到任何错误就代表插件安装成功了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubectl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes安装</title>
      <link href="/2022/10/08/kubernetes-an-zhuang/"/>
      <url>/2022/10/08/kubernetes-an-zhuang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文档<a href="https://zhuanlan.zhihu.com/p/146028810">https://zhuanlan.zhihu.com/p/146028810</a></p></blockquote><h2 id="安装kubeadm-kubelet-和-kubectl"><a href="#安装kubeadm-kubelet-和-kubectl" class="headerlink" title="安装kubeadm, kubelet 和 kubectl"></a>安装kubeadm, kubelet 和 kubectl</h2><p>部署之前，我们需要安装一下三个包：</p><ul><li><strong>kubeadm</strong>: 引导启动k8s集群的命令行工具。</li><li><strong>kubelet</strong>: 在群集中所有节点上运行的核心组件, 用来执行如启动pods和containers等操作。</li><li><strong>kubectl</strong>: 操作集群的命令行工具。</li></ul><p>首先添加apt-key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update &amp;&amp; sudo apt install -y apt-transport-https curlcurl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-下载-Google-Cloud-公开签名秘钥："><a href="#1-下载-Google-Cloud-公开签名秘钥：" class="headerlink" title="1.下载 Google Cloud 公开签名秘钥："></a>1.下载 Google Cloud 公开签名秘钥：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg   (可手动下载)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-添加-Kubernetes-apt-仓库："><a href="#2-添加-Kubernetes-apt-仓库：" class="headerlink" title="2.添加 Kubernetes apt 仓库："></a>2.添加 Kubernetes <code>apt</code> 仓库：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg] http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kubernetes&#x2F;apt kubernetes-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-更新-apt-包索引，安装-kubelet、kubeadm-和-kubectl，并锁定其版本："><a href="#3-更新-apt-包索引，安装-kubelet、kubeadm-和-kubectl，并锁定其版本：" class="headerlink" title="3.更新 apt 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本："></a>3.更新 <code>apt</code> 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y kubelet&#x3D;1.23.12-00 kubeadm&#x3D;1.23.12-00 kubectl&#x3D;1.23.12-00sudo apt-mark hold kubelet kubeadm kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>安装老版本的 Kubernetes</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-cache madison kubectl | grep $&#123;version&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭Swap</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo swapoff -a# use &quot;free -m&quot; to see if we successfully unable the swap$ free -m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-创建Master节点"><a href="#4-创建Master节点" class="headerlink" title="4.创建Master节点"></a>4.创建Master节点</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm init --config kubeadm-config.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># kubeadm-config.yamlkind: ClusterConfigurationapiVersion: kubeadm.k8s.io&#x2F;v1beta3kubernetesVersion: v1.23.12imageRepository: registry.cn-hangzhou.aliyuncs.com&#x2F;google_containersnetworking:  podSubnet: 10.244.0.0&#x2F;16  serviceSubnet: 172.16.0.0&#x2F;16---kind: KubeletConfigurationapiVersion: kubelet.config.k8s.io&#x2F;v1beta1cgroupDriver: cgroupfs---apiVersion: kubeadm.k8s.io&#x2F;v1beta3kind: InitConfigurationlocalAPIEndpoint:  advertiseAddress: &quot;192.168.0.192&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据上面的步骤：</p><p><strong>1)</strong> 在主机节点(A)当前用户home下创建.kube, 拷贝admin配置文件，赋予权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mkdir -p $HOME&#x2F;.kube$ sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config$ sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2)</strong> 在主节点(A)安装网络插件，这是必要的，因为pod之间需要通信, 这里使用的是flannel</p><pre class="line-numbers language-applescript" data-language="applescript"><code class="language-applescript">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml# 其他 Networking 和 network policy 可以参考以下链接https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-添加Worker节点"><a href="#5-添加Worker节点" class="headerlink" title="5.添加Worker节点"></a>5.添加Worker节点</h5><p>要为群集添加工作节点，需要为每台计算机执行以下操作：</p><ul><li>SSH到机器</li><li>成为root用户，(如: sudo su -)</li><li>运行上面的<code>kubeadm init</code>命令输出的：<code>kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code></li></ul><p>如果我们忘记了Master节点的加入token，可以使用如下命令来查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm token list# 输出：# TOKEN                     TTL       EXPIRES                USAGES                   DESCRIPTION   EXTRA GROUPS# abcdef.0123456789abcdef   22h       2018-11-10T14:24:51Z   authentication,signing   &lt;none&gt;        system:bootstrappers:kubeadm:default-node-token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记录 <code>kubeadm init</code> 输出的 <code>kubeadm join</code> 命令。 你需要此命令<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">将节点加入集群</a>。</p><pre class="line-numbers language-none"><code class="language-none">kubeadm join 192.168.0.192:6443 --token yca760.ascp39dkvddytq3h \        --discovery-token-ca-cert-hash sha256:ecfd86831e088af80789823035d4999fc45c050610a4b787ba84e50750493ed9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用下面的名为 <code>kubeadm-config.yaml</code> 的 kubeadm <a href="https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/docs/reference/config-api/kubeadm-config.v1beta3">配置文件</a> 示例用于向集群中添加另一个控制面节点。</p><p><a href="https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/setup/production-environment/tools/kubeadm/dual-stack-support.md">https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/setup/production-environment/tools/kubeadm/dual-stack-support.md</a></p><pre class="line-numbers language-none"><code class="language-none">apiVersion: kubeadm.k8s.io&#x2F;v1beta3kind: JoinConfigurationcontrolPlane:  localAPIEndpoint:    advertiseAddress: &quot;192.168.0.193&quot;    bindPort: 6443discovery:  bootstrapToken:    apiServerEndpoint: 192.168.0.192:6443    token: &quot;yca760.ascp39dkvddytq3h&quot;    caCertHashes:    - &quot;sha256:ecfd86831e088af80789823035d4999fc45c050610a4b787ba84e50750493ed9&quot;    # 请更改上面的认证信息，使之与你的集群中实际使用的令牌和 CA 证书匹配nodeRegistration:  kubeletExtraArgs:    node-ip: 10.100.0.4,fd00:1:2:3::4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，token的有效期是24小时，如果我们的token已经过期的话，可以使用以下命令重新生成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm token create# 输出：# 9w6mbu.3k2z7pprl3eaozk9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们也没有<code>--discovery-token-ca-cert-hash</code>的值，可以使用以下命令生成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;# 输出：# 9fcb02a0f4ab216866f87986106437b7305474850f0de81b9ac9c36a468f7c67<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-卸载-k8s"><a href="#6-卸载-k8s" class="headerlink" title="6.卸载 k8s"></a>6.卸载 k8s</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#卸载集群kubeadm resetrm -rf $HOME&#x2F;.kube---------------sudo apt-get purge kubeadm kubectl kubelet kubernetes-cni sudo apt-get autoremove  sudo rm -rf ~&#x2F;.kube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统过载时施加背压</title>
      <link href="/2022/09/29/xi-tong-guo-zai-shi-shi-jia-bei-ya/"/>
      <url>/2022/09/29/xi-tong-guo-zai-shi-shi-jia-bei-ya/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转自<a href="https://mechanical-sympathy.blogspot.com/">Mechanical Sympathy</a></p></blockquote><p>系统在持续负载下应如何响应？它是否应该继续接受请求，直到它的响应时间跟随致命的曲棍球棒，然后是崩溃？除非系统设计为处理到达的请求多于其处理能力的情况，否则通常会发生这种情况。如果我们看到请求的持续到达率超过了我们的系统能够处理的能力，那么就必须付出一些代价。让整个系统降级并不是我们想要为客户提供的理想服务。更好的方法是以我们系统的最大可能吞吐率处理事务，同时保持良好的响应时间，并拒绝超过此到达率的请求。</p><p>让我们将一个小型美术馆作为一个隐喻。在这个画廊中，典型的观众平均花费 20 分钟浏览，画廊最多可容纳 30 位观众。如果超过 30 位观众同时占据画廊，那么客户就会因为无法清楚地看到画作而变得不高兴。如果发生这种情况，他们不太可能购买或退货。为了让我们的观众满意，最好建议一些观众去几扇门下的咖啡馆，然后在画廊不那么忙的时候回来。这样，画廊里的观众就可以在没有其他观众的情况下看到所有的画作，同时那些我们无法容纳的人享用咖啡。如果我们应用<a href="http://en.wikipedia.org/wiki/Little&#39;s_law">利特尔定律</a>我们不能让客户到达每小时超过 90 个，否则会超出最大容量。如果他们在 9:00-10:00 之间以每小时 100 人的速度到达，那么我相信路边的咖啡馆会感谢额外的 10 位顾客。</p><p>在我们的系统中，可用容量通常取决于我们的线程池大小和处理单个事务的时间。这些线程池通常以队列为前端，以处理高于我们最大到达率的流量突发。如果队列是无界的，并且我们的到达率持续高于最大容量，那么队列将不受限制地增长。随着队列的增长，它们越来越多地增加了超出可接受响应时间的延迟，最终它们将消耗所有内存，导致我们的系统出现故障。将溢出的请求发送到咖啡馆，同时仍以最大可能的速度为其他人提供服务不是更好吗？我们可以通过设计我们的系统来应用“背压”来做到这一点。</p><div class="table-container"><table><thead><tr><th><a href="https://4.bp.blogspot.com/-H5j78ebce9w/T7erBJ8X-gI/AAAAAAAAADM/F_ak3B9Wdl0/s1600/back-pressure.png"><img src="https://4.bp.blogspot.com/-H5j78ebce9w/T7erBJ8X-gI/AAAAAAAAADM/F_ak3B9Wdl0/s1600/back-pressure.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1。</td></tr></tbody></table></div><p><a href="http://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离</a>鼓励在所有级别进行良好的系统设计。我喜欢分层设计，以便第三方网关与主要交易服务分开。这可以通过让网关只负责协议转换和边界安全来实现。典型的网关可以是运行<a href="http://jcp.org/en/jsr/detail?id=315">Servlets</a>的 Web 容器。<a href="http://martinfowler.com/eaaCatalog/domainModel.html">网关接受客户请求，应用适当的安全性，并转换通道协议以转发到托管域模型</a>的事务服务. 如果需要保留事务，事务服务可以使用持久存储。例如，聊天服务器域模型的状态可能不需要保存，而出于合规和业务原因，金融交易模型必须保存多年。</p><p>图 1. 上面是许多系统中典型请求流的简化视图。网关中的线程池接受用户请求并将它们转发给事务服务。假设我们有一个异步事务服务，前面有一个输入和输出队列，或类似的<a href="http://en.wikipedia.org/wiki/FIFO">FIFO</a>结构。如果我们希望系统满足响应时间服务质量（QoS）保证，那么我们需要考虑以下三个变量：</p><ol><li>线程上单个事务所花费的时间</li><li>池中可以并行执行事务的线程数</li><li><p>设置最大可接受延迟的输入队列长度</p><p><strong>最大延迟=（事务时间/线程数）*队列长度</strong></p><p><strong>队列长度=最大延迟/（事务时间/线程数）</strong></p></li></ol><p>通过允许队列不受限制，延迟将继续增加。因此，如果我们想设置最大响应时间，那么我们需要限制队列长度。</p><p>通过限制输入队列，我们阻止了接收网络数据包的线程，这将向上游施加背压。如果网络协议是 TCP，则通过填充网络缓冲区对发送方施加类似的背压。这个过程可以通过网关一直重复到客户那里。对于每项服务，我们都需要配置队列，以便它们在实现端到端客户体验所需的服务质量方面发挥作用。</p><p>我经常发现的最大胜利之一是缩短处理单个事务延迟所需的时间。这有助于最好和最坏的情况。</p><h5 id="最坏"><a href="#最坏" class="headerlink" title="最坏"></a><strong>最坏</strong></h5><p>的情况假设队列是无限的，系统处于持续的重负载下。在内存耗尽之前，事情可能会以微妙的方式很快开始出错。当队列大于处理器缓存时，您认为会发生什么？消费者线程将在他们努力跟上的时候遭受缓存未命中，从而使问题更加复杂。这可能会导致系统很快陷入困境并最终崩溃。在 Linux 下，这尤其令人讨厌，因为<a href="http://en.wikipedia.org/wiki/C_dynamic_memory_allocation">malloc</a>或其朋友之一会成功，因为 Linux 默认允许“<a href="http://www.win.tue.nl/~aeb/linux/lk/lk-9.html#ss9.6">过度提交</a>”，然后在使用该内存时，<a href="http://lwn.net/Articles/317814/"> OOM Killer</a>将开始拍摄过程。当操作系统开始拍摄过程时，你就知道事情不会有好的结局！</p><p><strong>那么同步设计呢？</strong></p><p>你可能会说同步设计没有队列。好吧，不是那么明显。如果您有一个线程池，那么它将有一个锁或信号量等待队列来分配线程。如果您足够疯狂地为每个请求分配一个新线程，那么一旦您克服了创建线程的巨大成本，您的线程就会在运行队列中等待处理器执行。此外，这些队列涉及上下文切换和条件变量，这大大增加了<a href="http://mechanical-sympathy.blogspot.co.uk/2011/11/locks-condition-variables-latency.html">成本</a>. 你不能逃避排队，他们无处不在！最好接受它们并设计您的系统需要向其客户提供的服务质量。如果我们必须有队列，那就为它们设计，也许选择一些性能很好的无锁队列。</p><p>当我们需要支持像 REST 这样的同步协议时，使用背压（由我们在网关处的完整传入队列发出信号）发送有意义的“服务器繁忙”消息，例如 HTTP 503 状态代码。然后，客户可以将此解释为在路边的咖啡馆享用咖啡和蛋糕的时间。</p><p><strong>需要注意的细微之处…</strong></p><p>您需要考虑整个端到端服务。如果客户端从您的系统中使用数据的速度非常慢怎么办？它可能会在网关中绑定一个线程，使其停止工作。现在你有更少的线程在队列中工作，所以响应时间会增加。需要监控队列和线程，并且在超过阈值时需要采取适当的措施。例如，当队列已满 70% 时，是否应该发出警报以便进行调查？此外，还需要对交易时间进行抽样，以确保它们在预期范围内。</p><h5 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h5><p>如果我们不考虑我们的系统在重负载下的表现，那么它们很可能会严重退化，最坏的情况是崩溃。当它们以这种方式崩溃时，我们会发现是否有任何真正邪恶的数据损坏漏洞潜伏在那些黑暗的地方。应用背压是应对持续高负载的一种有效技术，这样可以在不降低已接受请求和事务的系统性能的情况下提供最大吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backpressure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git撤销commit</title>
      <link href="/2022/09/29/git-che-xiao-commit/"/>
      <url>/2022/09/29/git-che-xiao-commit/</url>
      
        <content type="html"><![CDATA[<p>当我们写完代码后，我们一般都是</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">git add . &#x2F;&#x2F; 添加所有文件git commit - m &quot;xxxxxx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们<code>git commit</code>完之后，还没有执行<code>git push</code>，想修改/撤销这个<code>commit</code>，怎么办？</p><h2 id="1、如果只是想修改注释，可以这样操作"><a href="#1、如果只是想修改注释，可以这样操作" class="headerlink" title="1、如果只是想修改注释，可以这样操作"></a>1、如果只是想修改注释，可以这样操作</h2><p><code>git commit --amend</code><br>这个时候进入<code>vim</code>编辑，直接修改即可，修改完注释，退出<code>vim</code>编辑<br><code>:wq</code>保存已编辑的注释，重新<code>git push</code>即可</p><h2 id="2、要撤回commit"><a href="#2、要撤回commit" class="headerlink" title="2、要撤回commit"></a>2、要撤回commit</h2><p><code>git reset --soft HEAD^</code><br>这样就能成功的撤回你刚刚的<code>commit</code>操作。</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>如果你进行了2次commit，想都撤回，可以使用HEAD~2<br><strong>注意，这个命令仅仅是撤回commit操作，写的代码仍然保留</strong></p><hr><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p><code>--mixed</code><br>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数，<code>git reset --mixed HEAD^</code> 和 <code>git reset HEAD^</code> 效果是一样的。</p><p><code>--soft</code><br>不删除工作空间改动代码，<strong>撤销commit</strong>，<strong>不撤销<code>git add .</code></strong> </p><p><code>--hard</code><br><strong>删除工作空间改动代码</strong>，<strong>撤销commit，撤销<code>git add .</code></strong><br><strong>注意完成这个操作后，会删除工作空间代码！！！恢复到上一次的commit状态。慎重！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 版本管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于锁与无锁并发算法</title>
      <link href="/2022/09/28/jcp-jsr166/"/>
      <url>/2022/09/28/jcp-jsr166/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JSR 166 <a href="https://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html">https://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html</a><br>​<a href="https://jcp.org/en/jsr/detail?id=166">https://jcp.org/en/jsr/detail?id=166</a><br>​<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a></p><p>​    原文链接 <a href="https://mechanical-sympathy.blogspot.com/2013/08/lock-based-vs-lock-free-concurrent.html">https://mechanical-sympathy.blogspot.com/2013/08/lock-based-vs-lock-free-concurrent.html</a></p></blockquote><p><strong>测试用例</strong></p><p>为了比较实现，我需要一个不支持特定方法的 API 测试用例。例如，API 应该是无垃圾的并允许方法是原子的。一个简单的测试用例是设计一个可以在二维空间周围移动的宇宙飞船，其位置坐标可以以原子方式读取。每个事务至少需要读取或写入 2 个字段才能使并发有趣。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 与可以移动的船的并发表示的接口 * 一个二维空间，同时执行更新和读取。 *&#x2F;public interface Spaceship&#123;    &#x2F;**     * Read the position of the spaceship into the array of coordinates provided.     *     * @param coordinates into which the x and y coordinates should be read.     * @return the number of attempts made to read the current state.     *&#x2F;    int readPosition(final int[] coordinates);    &#x2F;**     * Move the position of the spaceship by a delta to the x and y coordinates.     *     * @param xDelta delta by which the spaceship should be moved in the x-axis.     * @param yDelta delta by which the spaceship should be moved in the y-axis.     * @return the number of attempts made to write the new coordinates.     *&#x2F;    int move(final int xDelta, final int yDelta);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分解一个不可变的 Position 对象，上面的 API 会更干净，但我想保持它无垃圾，并创建以最小间接更新多个内部字段的需要。这个 API 可以很容易地扩展到 3 维空间，并且要求实现是原子的。</p><p>为每艘宇宙飞船构建了多个实现，并由测试工具执行。此博客的所有代码和结果都可以在<a href="https://github.com/mjpt777/rw-concurrency">这里</a>找到。<a href="https://github.com/mjpt777/rw-concurrency/blob/master/src/PerfTest.java">测试工具</a></p><p>将依次运行每个实现，方法是使用<a href="http://mechanical-sympathy.blogspot.co.uk/2012/04/invoke-interface-optimisations.html">超态调度</a>模式来尝试并防止在访问并发方法时内联、锁粗化和循环展开。</p><p>每个实现都受到 4 种不同的线程场景的影响，这些场景会导致不同的争用配置文件：</p><ul><li>1 位读者 - 1 位作者</li><li>2 位读者 - 1 位作者</li><li>3 位读者 - 1 位作者</li><li>2 位读者 - 2 位作者</li></ul><p>所有测试均使用 64 位 Java 1.7.0_25、Linux 3.6.30 和四核 2.2GHz Ivy Bridge i7-3632QM 运行。对于每个实施，吞吐量在 5 秒内测量，测试重复 5 次以确保充分预热。下面的结果是 5 次运行的平均每秒吞吐量。为了近似典型的 Java 部署，没有使用线程亲和性或核心隔离，这会显着减少方差。</p><p><strong>注意：</strong>其他 CPU 和操作系统可能会产生非常不同的结果。</p><p><strong>结果</strong></p><div class="table-container"><table><thead><tr><th><a href="https://3.bp.blogspot.com/-OPpjg2SYJNg/Uhsd8wDzwvI/AAAAAAAAAKU/CDFVT_GKKQg/s1600/1-reader-1-writer.png"><img src="https://3.bp.blogspot.com/-OPpjg2SYJNg/Uhsd8wDzwvI/AAAAAAAAAKU/CDFVT_GKKQg/s1600/1-reader-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://4.bp.blogspot.com/-FLfb4NzCfDE/Uhseh8sGtAI/AAAAAAAAAKc/NhTqXc_PgEw/s1600/2-readers-1-writer.png"><img src="https://4.bp.blogspot.com/-FLfb4NzCfDE/Uhseh8sGtAI/AAAAAAAAAKc/NhTqXc_PgEw/s1600/2-readers-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 2。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://3.bp.blogspot.com/-XfxlHbgvM2M/Uhse4umPIcI/AAAAAAAAAKk/WTlZfBFKZMc/s1600/3-readers-1-writer.png"><img src="https://3.bp.blogspot.com/-XfxlHbgvM2M/Uhse4umPIcI/AAAAAAAAAKk/WTlZfBFKZMc/s1600/3-readers-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 3。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://1.bp.blogspot.com/-wOEnC0kN-XY/UhsfRf2ld3I/AAAAAAAAAKs/7l9BA5rRTMM/s1600/2-readers-2-writers.png"><img src="https://1.bp.blogspot.com/-wOEnC0kN-XY/UhsfRf2ld3I/AAAAAAAAAKs/7l9BA5rRTMM/s1600/2-readers-2-writers.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 4。</td></tr></tbody></table></div><p>上述图表的原始数据可在<a href="https://github.com/mjpt777/rw-concurrency/tree/master/data">此处</a>找到。</p><p><strong>分析</strong></p><p>结果让我真正吃惊的是 ReentrantReadWriteLock 的性能。除了在读取和写入很少的情况下存在巨大平衡的情况之外，我看不到这种实现的用途。我的主要收获是：</p><ol><li>StampedLock 是对现有锁实现的重大改进，尤其是随着阅读器线程数量的增加。</li><li>StampedLock 有一个复杂的 API。很容易错误地调用错误的锁定操作方法。</li><li>当争用仅来自 2 个线程时，同步是一个很好的通用锁实现。</li><li>ReentrantLock 是一个很好的通用锁实现，当线程数如<a href="http://mechanical-sympathy.blogspot.co.uk/2011/11/java-lock-implementations.html">先前发现</a>的那样增长时。</li><li>选择使用 ReentrantReadWriteLock 应该基于仔细和适当的测量。与所有重大决策一样，根据数据衡量和做出决策。</li><li>与基于锁的算法相比，无锁实现可以提供显着的吞吐量优势。</li></ol><p><strong>结论</strong></p><p>很高兴看到基于锁的算法中出现的无锁技术的影响。在写入器不更新时，读取时采用的乐观策略实际上是一种无锁算法。</p>]]></content>
      
      
      <categories>
          
          <category> concurrent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>simple-binary-encoding</title>
      <link href="/2022/09/28/simple-binary-encoding/"/>
      <url>/2022/09/28/simple-binary-encoding/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html">https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html</a><br>github <a href="https://github.com/real-logic/simple-binary-encoding">https://github.com/real-logic/simple-binary-encoding</a><br>wiki <a href="https://github.com/real-logic/simple-binary-encoding/wiki">https://github.com/real-logic/simple-binary-encoding/wiki</a></p></blockquote><p>金融系统通过以多种不同格式发送和接收大量消息进行通信。当人们使用像“巨大”这样的词时，我通常会想，“真的……有多少？” 因此，让我们量化金融业的“巨大”。来自金融交易所的市场数据馈送通常每秒可发出数万或数十万条消息，而像<a href="http://www.opradata.com/">OPRA</a>这样的聚合馈送峰值可达到每秒超过 1000 万条消息，并且数量逐年增长。此演示文稿提供了一个很好的<a href="https://fif.com/docs/2013_6_fifmd_capacity_stats.pdf">概述</a>。</p><p>在这个疯狂的世界中，我们仍然看到大量使用 ASCII 编码的表示形式，例如<a href="http://en.wikipedia.org/wiki/Financial_Information_eXchange">FIX</a>标签值，以及一些稍微健全的二进制编码表示形式，例如 <a href="http://en.wikipedia.org/wiki/FAST_protocol">FAST</a>. 有些市场甚至犯了将市场数据作为 XML 发送的罪行！好吧，我不能抱怨太多，因为他们有时为我提供了编写超快速 XML 解析器的可观收入。</p><p>去年，作为 FIX<a href="http://www.fixtradingcommunity.org/">社区</a>成员的 CME委托 29West LBM 名气的<a href="https://twitter.com/toddlmontgomery">Todd Montgomery</a>和我自己构建新的 FIX <a href="http://real-logic.github.io/simple-binary-encoding/">简单二进制编码的参考实现</a>(SBE) 标准。SBE 是一种编解码器，旨在解决低延迟交易中的效率问题，特别关注市场数据。CME 在 FIX 社区内工作，在提出如此高效的编码演示方面做得非常出色。对于过去的 FIX 标签值实现的罪恶，也许是一个合适的赎罪。Todd 和我致力于 Java 和 C++ 的实现，后来我们在 .Net 方面得到了<a href="http://weareadaptive.com/">Adaptive出色的</a><a href="https://twitter.com/olivierdeheurle">Olivier Deheurles</a>的帮助。与这样的团队一起解决一个很酷的技术问题是一项梦寐以求的工作。<strong>SBE 概述</strong> SBE 是一种<a href="http://en.wikipedia.org/wiki/OSI_model">OSI</a></p><p>用于以二进制格式编码/解码消息的第 6 层表示，以支持低延迟应用程序。在我描述的存在性能问题的许多应用程序中，消息编码/解码通常是最重要的成本。我见过许多应用程序在解析和转换 XML 和 JSON 上花费的 CPU 时间比执行业务逻辑要多得多。SBE 旨在使系统的这一部分尽可能高效。SBE 遵循许多<a href="https://github.com/real-logic/simple-binary-encoding/wiki/Design-Principles">设计原则</a>来实现这一目标。遵守这些设计原则有时意味着不会提供其他编解码器中可用的功能。例如，许多编解码器允许在消息中的任何字段位置对字符串进行编码；SBE 仅允许可变长度字段（例如字符串）作为在消息末尾分组的字段。</p><p>SBE 参考实现由一个编译器组成，该编译器将消息模式作为输入，然后生成特定于语言的存根。存根用于直接对来自缓冲区的消息进行编码和解码。SBE 工具还可以生成模式的二进制表示，可用于动态环境中消息的动态解码，例如日志查看器或网络嗅探器。</p><p>设计原则推动了编解码器的实现，确保消息通过内存流式传输，而无需回溯、复制或不必要的分配。<a href="http://mechanical-sympathy.blogspot.co.uk/2012/08/memory-access-patterns-are-important.html">内存访问模式</a>在高性能应用程序的设计中不应低估。任何语言的低延迟系统尤其需要考虑所有分配，以避免在回收中产生问题。这适用于托管运行时和本机语言。SBE 在所有三种语言实现中都是完全免费的。</p><p>应用这些设计原则的最终结果是编解码器的吞吐量比 Google 协议缓冲区 (GPB) 高约 16-25 倍，并且延迟非常低且可预测。这已在<a href="https://github.com/real-logic/simple-binary-encoding/tree/master/sbe-benchmarks/src/main">微基准测试</a>和实际应用程序使用中观察到。一个典型的市场数据消息可以在大约 25ns 内进行编码或解码，而在相同硬件上使用 GPB 的相同消息大约需要 1000ns。XML 和 FIX 标记值消息再次慢了几个数量级。</p><p>SBE 的最佳选择是作为结构化数据的编解码器，这些数据主要是固定大小的字段，即数字、位集、枚举和数组。虽然它确实适用于字符串和 blob，但我发现一些限制是可用性问题。这些用户最好使用更适合字符串编码的编解码器。</p><p><strong>消息结构</strong></p><p>消息必须能够按顺序读取或写入，以保持流式访问设计原则，即无需回溯。一些编解码器为必须间接访问的可变长度字段（例如字符串类型）插入位置指针。这种间接的代价是额外的指令加上失去硬件预取器的支持。SBE 的设计允许纯顺序访问和无副本本机访问语义。</p><div class="table-container"><table><thead><tr><th><a href="https://2.bp.blogspot.com/-97WBcDq_Gm8/U2dWpbKU3hI/AAAAAAAAARQ/DV0HAr9kAE8/s1600/SBE-msg-format.png"><img src="https://2.bp.blogspot.com/-97WBcDq_Gm8/U2dWpbKU3hI/AAAAAAAAARQ/DV0HAr9kAE8/s1600/SBE-msg-format.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1</td></tr></tbody></table></div><p>SBE 消息有一个公共标头，用于标识要遵循的消息正文的类型和版本。标头后面是消息的根字段，它们都是固定长度和静态偏移的。根字段与 C 中的结构非常相似。如果消息更复杂，则可以跟随一个或多个类似于根块的重复组。重复组可以嵌套其他重复组结构。最后，可变长度的字符串和 blob 出现在消息的末尾。字段也可以是可选的。可以在 <a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-tool/src/main/resources/fpl/SimpleBinary1-0.xsd">此处</a>找到描述 SBE 表示的 XML 模式。</p><p><strong>SbeTool 和编译器</strong></p><p>要使用 SBE，首先需要为您的消息定义一个模式。SBE 提供了一个独立于语言的类型系统，支持整数、浮点数、字符、数组、常量、枚举、位集、复合、重复的分组结构以及可变长度的字符串和 blob。</p><p>可以将消息模式输入<a href="https://github.com/real-logic/simple-binary-encoding/wiki/Sbe-Tool-Guide">SbeTool</a>并进行编译以生成多种语言的存根，或生成适用于即时解码消息的二进制元数据。</p><pre class="line-numbers language-none"><code class="language-none">java [-Doption&#x3D;value] -jar sbe.jar &lt;message-declarations-file.xml&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SbeTool 和编译器是用 Java 编写的。该工具目前可以在 Java、C++ 和 C# 中输出存根。</p><p><strong>使用存根编程</strong> 可以在 <a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/java/uk/co/real_logic/sbe/examples/ExampleUsingGeneratedStub.java">此处找到在带有支持代码的</a><a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/resources/example-schema.xml">模式</a></p><p>中定义的消息的完整示例 。生成的存根遵循享元模式，重复使用实例以避免分配。存根在偏移处包装缓冲区，然后按顺序和本机读取它。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 先写消息头MESSAGE_HEADER.wrap(directBuffer, bufferOffset, messageTemplateVersion)               .blockLength(CAR.sbeBlockLength())               .templateId(CAR.sbeTemplateId())               .schemaId(CAR.sbeSchemaId())               .version(CAR.sbeSchemaVersion ()); &#x2F;&#x2F; 然后写入消息体car.wrapForEncode(directBuffer, bufferOffset)    .serialNumber(1234)    .modelYear(2013)    .available(BooleanType.TRUE ) .code    (Model.A)    .putVehicleCode(VEHICLE_CODE, srcOffset);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过生成的存根以流畅的方式编写消息。每个字段显示为一对生成的编码和解码方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 读取头部并查找合适的模板来解码MESSAGE_HEADER.wrap(directBuffer, bufferOffset, messageTemplateVersion); final int templateId &#x3D; MESSAGE_HEADER.templateId(); final int actuatorBlockLength &#x3D; MESSAGE_HEADER.blockLength(); final int schemaId &#x3D; MESSAGE_HEADER.schemaId(); 最终 int actingVersion &#x3D; MESSAGE_HEADER.version(); &#x2F;&#x2F; 一旦找到模板，就可以对字段进行解码。car.wrapForDecode（directBuffer，bufferOffset，actingBlockLength，actingVersion）；final StringBuilder sb &#x3D; new StringBuilder(); sb.append(&quot;\ncar.templateId&#x3D;&quot;).append(car.sbeTemplateId()); sb.append(&quot;\ncar.schemaId&#x3D;&quot;).append(schemaId);sb.append(&quot;\ncar.schemaVersion&#x3D;&quot;).append(car.sbeSchemaVersion()); sb.append(&quot;\ncar.serialNumber&#x3D;&quot;).append(car.serialNumber()); sb.append(&quot;\ncar.modelYear&#x3D;&quot;).append(car.modelYear()); sb.append(&quot;\ncar.available&#x3D;&quot;).append(car.available()); sb.append(&quot;\ncar.code&#x3D;&quot;).append(car.code());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在所有语言中生成的代码提供的性能类似于在内存上强制转换 C 结构。</p><p><strong>动态解码</strong></p><p>编译器为输入 XML 消息模式生成中间表示 (IR)。此 IR 可以以 SBE 二进制格式序列化，以用于稍后对已存储的消息进行动态解码。它对于不会与存根一起编译的工具（例如网络嗅探器）也很有用。可以在<a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/java/uk/co/real_logic/sbe/examples/OtfExample.java">此处</a>找到使用的 IR 的完整示例。</p><p><strong>Direct Buffers</strong></p><p>SBE，通过 Agrona，通过 <a href="https://github.com/real-logic/Agrona/blob/master/src/main/java/org/agrona/MutableDirectBuffer.java">MutableDirectBuffer</a>类为 Java 提供抽象，以使用 byte[]、heap 或直接<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer的缓冲区</a> 缓冲区，以及从<a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html#allocateMemory(long">Unsafe.allocateMemory(long)</a>)或 JNI 返回的堆外内存地址。在低延迟应用程序中，消息通常通过<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html">MappedByteBuffer</a>在内存映射文件中进行编码/解码，因此可以由内核<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#transferTo(long, long, java.nio.channels.WritableByteChannel">传输</a>)到网络通道，从而避免用户空间复制。</p><p>C++ 和 C# 具有对直接内存访问的内置支持，并且不需要像 Java 版本那样的抽象。为 C# 添加了 DirectBuffer 抽象以支持 Endianess 并封装不安全的指针访问。</p><p><strong>消息扩展和版本控制</strong></p><p>SBE 模式带有允许消息扩展的版本号。可以通过在块末尾添加字段来扩展消息。为了向后兼容，不能删除或重新排序字段。</p><p>扩展字段必须是可选的，否则读取旧消息的较新模板将不起作用。模板携带 min、max、null、timeunit、字符编码等元数据，这些可通过存根上的静态（类级别）方法访问。</p><p><strong>字节排序和对齐</strong></p><p>消息模式允许通过指定偏移量来精确对齐字段。字段默认以 Little <a href="http://www.ietf.org/rfc/ien/ien137.txt">Endian编码</a>除非在模式中另有说明，否则形式。为了获得最佳性能，应使用字对齐边界上的字段的本机编码。在某些处理器上访问非对齐字段的代价可能非常大。对于对齐，必须考虑帧协议和内存中的缓冲区位置。</p><p><strong>消息协议</strong></p><p>我经常看到人们抱怨编解码器无法支持单个消息中的特定演示。然而，这通常可以通过消息协议来解决。协议是将交互拆分为其组成部分的好方法，这些部分通常可以组合用于系统之间的许多交互。例如，模式元数据的 IR 实现比单个消息的结构所能支持的更复杂。我们通过首先发送一个提供概述的模板消息来编码 IR，然后是一个消息流，每个消息都对来自编译器 IR 的标记进行编码。这允许设计一个非常快速的 OTF 解码器，它可以实现为一个线程解释器，其分支比典型的基于开关的状态机少得多。</p><p>协议设计是大多数开发人员似乎没有机会学习的领域。我觉得这是一个很大的损失。如此多的开发人员将诸如 ASCII 之类的“编码”称为“协议”这一事实非常有说服力。当一个人与像 Todd 这样一生都在成功设计协议的程序员一起工作时，协议的价值就显而易见了。</p><p><strong>存根性能</strong></p><p>与动态 OTF 解码相比，存根提供了显着的性能优势。对于访问原始字段，我们相信性能已达到通用工具所能达到的极限。生成的汇编代码与编译器生成的用于访问 C 结构的代码非常相似，即使是从 Java 中也是如此！</p><p>关于存根的一般性能，我们观察到 C++ 与 Java 相比具有非常小的优势，我们认为这是由于运行时插入的安全点检查。C# 版本稍微落后一点，因为它的运行时没有像 Java 运行时那样积极地使用内联方法。所有三种语言的存根都能够在数十纳秒内对典型的金融消息进行编码或解码。相对于应用程序逻辑的其余部分，这有效地使大多数应用程序的消息编码和解码几乎免费。</p><p><strong>反馈</strong></p><p>这是 SBE 的第一个版本，我们欢迎<a href="https://github.com/real-logic/simple-binary-encoding/issues?state=open">反馈</a>. 参考实现受 FIX 社区规范的约束。可能会影响规范，但请不要期望会接受明显违反<a href="https://github.com/FIXTradingCommunity/fix-simple-binary-encoding">规范</a>的拉取请求。已经讨论了对 Javascript、Python、Erlang 和其他语言的支持，非常受欢迎。</p><p><strong>更新：2014 年 5 月 8 日</strong></p><p>感谢 GPB 的创建者 Kenton Varda 的反馈，我们能够改进基准以从 GPB 中获得最佳性能。以下是 Java 基准测试的更改结果。</p><p>与初始结果相比，有关优化的 C++ GPB 示例显示吞吐量大约翻了一番。应该注意的是，与 C++ 相比，在 Java 中使用 GPB 时，您通常必须做相反的事情才能获得性能改进，例如分配对象而不是重用它们。</p><p><strong>GPB优化前：</strong></p><pre class="line-numbers language-none"><code class="language-none">Mode Thr Cnt Sec Mean Mean error Units      [exec] ucrprotobuf.CarBenchmark.testDecode thrpt 1 30 1 462.817 6.474 ops&#x2F;ms      [exec] ucrprotobuf.CarBenchmark.testEncode thrpt 1 30 1 326.018 2.972 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testDecode thrpt 1 30 1 1148.050 17.194 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testEncode thrpt 1 30 1 1242.252 12.248 ops&#x2F;ms      [exec] ucrsbe.CarBenchmark.testDecode thrpt 1 30 1 10436.476 102ucrsbe.ms      [exec] testEncode thrpt 1 30 1 11657.190 65.168 操作&#x2F;毫秒     [exec] ucrsbe.MarketDataBenchmark.testDecode thrpt 1 30 1 34078.646 261.775 ops&#x2F;ms      [exec] ucrsbe.MarketDataBenchmark.testEncode thrpt 1 30 1 29193.600 443.638 ops&#x2F;ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>GPB优化后：</strong></p><pre class="line-numbers language-none"><code class="language-none">Mode Thr Cnt Sec Mean Mean error Units      [exec] ucrprotobuf.CarBenchmark.testDecode thrpt 1 30 1 619.467 4.429 ops&#x2F;ms      [exec] ucrprotobuf.CarBenchmark.testEncode thrpt 1 30 1 433.711 10.364 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.test thrpt 1 30 1 2088.998 60.619 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testEncode thrpt 1 30 1 1316.123 19.816 ops&#x2F;ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>吞吐量 msg/ms - 在 GPB 优化之前</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>测试</td><td>协议缓冲区</td><td>SBE</td><td>比率</td></tr><tr><td>汽车编码</td><td>462.817</td><td>10436.476</td><td>22.52</td></tr><tr><td>汽车解码</td><td>326.018</td><td>11657.190</td><td>35.76</td></tr><tr><td>市场数据编码</td><td>1148.050</td><td>34078.646</td><td>29.68</td></tr><tr><td>市场数据解码</td><td>1242.252</td><td>29193.600</td><td>23.50</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>吞吐量 msg/ms - GPB 优化后</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>测试</td><td>协议缓冲区</td><td>SBE</td><td>比率</td></tr><tr><td>汽车编码</td><td>619.467</td><td>10436.476</td><td>16.85</td></tr><tr><td>汽车解码</td><td>433.711</td><td>11657.190</td><td>26.88</td></tr><tr><td>市场数据编码</td><td>2088.998</td><td>34078.646</td><td>16.31</td></tr><tr><td>市场数据解码</td><td>1316.123</td><td>29193.600</td><td>22.18</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 二进制编码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git如何移除某文件夹的版本控制</title>
      <link href="/2022/09/15/git-ru-he-yi-chu-mou-wen-jian-jia-de-ban-ben-kong-zhi/"/>
      <url>/2022/09/15/git-ru-he-yi-chu-mou-wen-jian-jia-de-ban-ben-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p>#目录结构如下</p><pre class="line-numbers language-none"><code class="language-none">project    bin    lib    src    ...... <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#执行如下的操作</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m &quot;add bin&#x2F; lib&#x2F; src&#x2F;&quot;git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>突然发现原来 <code>lib</code> 目录不需要提交到版本库，但是现在远程已经存在该目录，what should I do.（吐出去的东西还能收回来吗）</p><p>万能的 git 啊，help me！</p><p>功夫不负有心人，找到了解决问题的方法，其实就是 <code>git rm</code> 的命令行参数。</p><h2 id="git-rm-命令参数"><a href="#git-rm-命令参数" class="headerlink" title="git rm 命令参数"></a><code>git rm</code> 命令参数</h2><pre class="line-numbers language-none"><code class="language-none">-n --dry-run Don’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.-r Allow recursive removal when a leading directory name is given. --cached Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#解决方法</p><pre class="line-numbers language-none"><code class="language-none">git rm -r -n --cached &quot;bin&#x2F;&quot; &#x2F;&#x2F;-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。git rm -r --cached  &quot;bin&#x2F;&quot;      &#x2F;&#x2F;最终执行命令. git commit -m&quot; remove bin folder all file out of control&quot;    &#x2F;&#x2F;提交git push origin master   &#x2F;&#x2F;提交到远程服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时 <code>git status</code> 看到 bin / 目录状态变为<code>untracked</code> 可以修改<code>.gitignore</code> 文件 添加 <code>bin/</code> 并提交<code>.gitignore</code> 文件到远程服务器，这样就可以不对 bin 目录进行版本管理了。 以后需要的时候，只需要注释<code>.gitignore</code> 里<code>#bin/</code> 内容，重新执行 <code>git bin/</code>, 即可重新纳入版本管理。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Restart policies</title>
      <link href="/2022/08/29/docker-restart-policies/"/>
      <url>/2022/08/29/docker-restart-policies/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker重启策略"><a href="#Docker重启策略" class="headerlink" title="Docker重启策略"></a>Docker重启策略</h2><blockquote><p>参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.docker.com%2Fengine%2Freference%2Frun%2F%23restart-policies---restart">https://docs.docker.com/engine/reference/run/#restart-policies—-restart</a></p></blockquote><p>使用<code>--restart</code>Docker run 上的标志，您可以指定容器在退出时应该或不应该如何重新启动的重新启动策略。当容器上的重启策略处于活动状态时，它将显示为<code>Up</code> 或<code>Restarting</code>。</p><p>Docker 支持以下重启策略：</p><div class="table-container"><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td>不自动重启（默认模式）</td></tr><tr><td>on-failure[:max-retries]</td><td>重启因出错停止的容器（非0退出码）。可以通过指定max-retries来限定docker daemon的最大尝试重启次数</td></tr><tr><td>always</td><td>docker daemon会无限尝试重启退出的容器（无论以什么退出码退出）。手动停止容器后，容器策略不再生效。除非重启docker daemon</td></tr><tr><td>unless-stopped</td><td>与<code>always</code>类似，区别在于手动停止容器后，就算重启docker daemon，容器策略也不再生效。</td></tr></tbody></table></div><p>在每次重新启动之前添加一个增加的延迟（是先前延迟的两倍，从 100 毫秒开始），以防止服务器泛滥。这意味着守护进程将等待 100 毫秒，然后等待 200 毫秒、400、800、1600 等等，直到达到<code>on-failure</code>限制、最大延迟 1 分钟，或者当您<code>docker stop</code>或<code>docker rm -f</code>容器时。</p><p>如果容器重新启动成功（<strong>容器启动并运行至少 10 秒</strong>），则延迟将重置为其默认值 100 毫秒。</p><p><strong>您可以指定 Docker 在使用on-failure</strong>策略时尝试重新启动容器的最大次数。默认情况下，Docker 将永远尝试重新启动容器。容器的（尝试）重启次数可以通过<a href="https://docs.docker.com/engine/reference/commandline/inspect/"><code>docker inspect</code></a>. 例如，获取容器“my-container”的重启次数；</p><pre class="line-numbers language-none"><code class="language-none">$ docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; my-container# 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者，获取容器上次（重新）启动的时间；</p><pre class="line-numbers language-none"><code class="language-none">$ docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; my-container# 2015-03-04T23:47:07.691840179Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将<code>--restart</code>(restart policy) 与<code>--rm</code>(clean up) 标志结合使用会导致错误。在容器重新启动时，附加的客户端会断开连接。请参阅本页后面有关使用<a href="https://docs.docker.com/engine/reference/run/#clean-up---rm"><code>--rm</code>(clean up)</a>标志的示例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Repository</title>
      <link href="/2022/08/24/binary-repository/"/>
      <url>/2022/08/24/binary-repository/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://dzone.com/articles/easy-way-to-get-your-own-binary-repository">https://dzone.com/articles/easy-way-to-get-your-own-binary-repository</a></p></blockquote><p>根据<a href="https://en.wikipedia.org/wiki/Software_repository">维基百科</a>，<a href="https://dzone.com/articles/use-a-binary-repository-manager-and-keep-up-with-d">二进制存储库管理器 (BRM)</a>是“一种软件工具，旨在优化软件开发中使用和生成的二进制文件的下载和存储”，例如 .jar、.tar 或 .zip 档案。作为大多数<a href="https://en.wikipedia.org/wiki/DevOps_toolchain">DevOps 工具链</a>的关键组件，BRM 位于构建管道之后。这就是为什么它有时被称为“构建存储库”、“工件存储库”或“管道状态存储库”的原因。</p><p>传统的<a href="https://dzone.com/articles/devops-pipeline-end-to-end-with-pcf">DevOps 管道</a>需要自动验证、测试、打包和版本化到工件（二进制文件）中的源代码。然后，工件必须存储在源代码存储库之外，并可供持续交付管道的后续阶段使用。作为管理二进制文件和依赖项的中心点，以及用于构建内部开发软件促销的集成库，BRM 应该托管这些工件。</p><p><img src="https://dz2cdn1.dzone.com/storage/temp/16097179-1pipeline.jpg" alt="img"></p><p>几乎任何规模的软件项目都需要将其二进制工件保存在存储库中，以便程序员或确保<a href="https://dzone.com/articles/learn-how-to-setup-a-cicd-pipeline-from-scratch">持续集成 (CI)、交付 (CD) 和部署 (CD)</a>的工具能够访问它们。由于管理存储库的软件质量很重要，因此 BRM 应满足以下要求：</p><ul><li>可集成性——每种编程语言都有大量的构建自动化工具，例如用于 Java 的 Maven、用于 JavaScript 的 Npm 或用于 Ruby 的 Rake。还有很多持续集成工具，比如 Jenkins 或 Travis。由于自动化是 DevOps 最重要的方面，因此预计每个或大部分都有插件，从而能够与 BRM 无缝集成。</li><li>可用性——工件是软件开发过程的重要组成部分，它们必须在需要时立即可供程序员或构建工具使用，甚至没有微小的延迟，并以尽可能快的速度交付。</li><li>可扩展性——大多数构建工件都是大型二进制文件；其中一些可能大于 1Gb，例如 Docker 映像或 .war（生产就绪的 Java 档案）。BRM 必须能够维护大型数据集，几乎没有大小限制。</li><li>可靠性——必须尽可能排除因软件或硬件故障而损坏数据的能力。</li></ul><h3 id="Artipie"><a href="#Artipie" class="headerlink" title="Artipie"></a>Artipie</h3><p><a href="https://github.com/artipie">Artipie </a>是一个免费的二进制工件管理工具。Artipie 不仅仅是一个二进制工件 Web 服务器——它是一个工件管理构造函数，它包含许多内置在服务器组件中的组件。这是一个开源项目，始于 2020 年，并且正在积极发展。</p><h3 id="Artipie-HTTP-引擎"><a href="#Artipie-HTTP-引擎" class="headerlink" title="Artipie HTTP 引擎"></a><strong>Artipie HTTP 引擎</strong></h3><p>Artipie 引擎是一个 Java 应用程序，它公开了一个用于存储库访问和管理操作的 HTTP 端点。它将 HTTP 请求路由到存储库适配器并提供身份验证机制。Artipie HTTP 引擎基于<a href="https://dzone.com/articles/introduce-to-eclicpse-vertx">Vert.x</a>和<a href="https://dzone.com/articles/go-reactive-with-rx-java">RxJava</a>框架构建，通过异步、反应式和非阻塞操作为项目提供轻量级的灵活性和可扩展性。</p><p>Artipie 上传操作最常见的数据流如下：客户端正在向服务器发送一些二进制工件，服务器会找到负责的存储库适配器来处理请求；存储库适配器将流保存到存储；完成后，它会更新存储库的元数据（某些存储库的工作方式不同，例如，Docker 使用元数据作为路径）。</p><p><img src="https://dz2cdn1.dzone.com/storage/temp/16097192-3uploadaction.jpg" alt="img"></p><p>图 3. 使用 S3 实现存储的 Artipie Maven 存储库的上传操作</p><h3 id="存储库适配器"><a href="#存储库适配器" class="headerlink" title="存储库适配器"></a><strong>存储库适配器</strong></h3><p>存储库适配器是独立项目，旨在实现 API 以与特定包类型（npm、maven 等）的存储库客户端和元信息生成层进行交互。Artipie 引擎使用适配器来提供 BRM 功能。每个存储库适配器都封装存储 API 以访问二进制 blob 和元数据文件。</p><p>Artipie 支持以下类型的存储库：</p><ul><li>Docker - 用于镜像的私有 Docker 注册表。</li><li>Maven - Java、Kotlin、Groovy、Scala、Clojure 工件和各种类型的依赖项，如 .jar、.war、.klib 等。</li><li>NPM - JavaScript 代码共享和包存储。</li><li>PyPI - Python 包索引。</li><li>Anaconda - 为 Python、R、Lua、C、C++ 等构建数据科学包。</li><li>RPM - 用于 RHEL、PCLinuxOS、Fedora、AlmaLinux、CentOS、openSUSE、OpenMandriva、Oracle Linux 等的 .rpm 软件包存储库。</li><li>Gem - Ruby 的 RubyGem 托管服务.</li><li>Go - Go 包裹存储。</li><li>文件（二进制）存储 - 托管您喜欢的任何文件。</li><li>Helm - Helm 图表存储库。</li><li>NuGet - .NET 包的托管服务。</li><li>Debian - 基于 Debian 的 Linux 发行版的软件包存储库：Ubuntu、MX Linux、Mint、Raspberry Pi OS、Parrot OS 等。</li><li>Composer - PHP 包的包源。</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>存储库适配器将上传和创建的二进制文件放置在存储中。Artipie 具有抽象存储，它提供了对物理数据存储系统的抽象。简单性使得为几乎任何数据存储系统实现接口变得容易。它有两个主要操作：从存储中放入和获取项目以及一些附加功能，例如检查项目是否存在、列出存储项目或获取项目元数据。</p><p>目前，有以下存储实现：</p><ol><li>文件系统存储</li><li>Redis 存储</li><li>基于 S3 的存储</li></ol><p>抽象存储还提供了一个接口，可以实现该接口以支持您需要的任何类型的存储。</p><h2 id="开始使用-Artipie"><a href="#开始使用-Artipie" class="headerlink" title="开始使用 Artipie"></a><strong>开始使用 Artipie</strong></h2><p>使用 Artipie 有两种选择： </p><ul><li><a href="https://github.com/artipie/artipie#quickstart">使用 Docker Compose 运行 Artipie Docker 映像</a></li><li><a href="https://github.com/artipie/artipie/wiki">在 JVM 上运行 Artipie jar 存档</a></li></ul><h3 id="准备中"><a href="#准备中" class="headerlink" title="准备中"></a>准备中</h3><p>要运行 Artipie，您需要<a href="https://docker.com/get-started">安装 Docker</a>，然后您可以简单地克隆此存储库，并在路径上使用示例<code>C:\</code>，或按照以下步骤操作：</p><ol><li>为 Artipie 项目创建一个文件夹（例如<code>C:\artipie</code>）</li><li>为 Artipie 配置创建一个文件夹（例如<code>C:\artipie\config</code>），并将包含 Artipie 服务器配置的 yml 文件放在该文件夹中。在我的示例中，该文件称为<code>artipie.yml</code>. 您必须指定 Artipie 将找到所有存储库配置的路径。我将 Docker 存储库的配置路径指定为，因为在第 4 步中进行设置时<code>var/artipie/repo</code>，我将文件夹从本地 Windows 机器安装<code>C:\artipie\repo</code>到 Artipie Docker 容器中的目录。<code>/var/artipie/repo``docker-compose.yml</code></li></ol><pre class="line-numbers language-none"><code class="language-none">meta:  storage:    type: fs    path: &#x2F;var&#x2F;artipie&#x2F;repo #path to repository configurations  layout: flat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>为存储库配置文件（例如<code>C:\artipie\repo</code>）创建一个文件夹，然后将包含存储库配置的 yml 文件放入该文件夹。此文件的名称将是要创建的存储库的名称。例如，文件将被命名<code>my-docker.yml</code>，存储库将相应地命名为<strong>my-docker</strong>。要配置具有 FileStorage 类型的存储，设置 Artipie 将存储所有项目的路径就足够了。系统必须具有读写权限才能在此路径上创建文件。在我的示例中，路径将是<code>/var/artipie/images</code>.</li></ol><pre class="line-numbers language-none"><code class="language-none">repo:  type: docker  storage:    type: fs   #type &#x3D; FileStorage    path: &#x2F;var&#x2F;artipie&#x2F;images   #place where the data will be stored<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>使用以下说明创建文件<code>docker-compose.yml</code>：</li></ol><pre class="line-numbers language-none"><code class="language-none">version: &quot;3.3&quot;services:  artipie:    image: artipie&#x2F;artipie:latest    container_name: artipie    restart: unless-stopped    ports:      - &quot;8080:8080&quot;    volumes:      - &#x2F;C&#x2F;artipie&#x2F;repo:&#x2F;var&#x2F;artipie&#x2F;repo # mount folder with repository configuration      - &#x2F;C&#x2F;artipie&#x2F;config:&#x2F;etc&#x2F;artipie&#x2F; # mount folder with Artipie server configuration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> binary-repo </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Micrometer自定义业务监控指标</title>
      <link href="/2022/08/18/micrometer-zi-ding-yi-ye-wu-jian-kong-zhi-biao/"/>
      <url>/2022/08/18/micrometer-zi-ding-yi-ye-wu-jian-kong-zhi-biao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[原文链接] <a href="https://github.com/TFdream/blog/issues/340">https://github.com/TFdream/blog/issues/340</a></p><h1 id="SpringBoot-2-0-Micrometer-自定义业务指标监控"><a href="#SpringBoot-2-0-Micrometer-自定义业务指标监控" class="headerlink" title="SpringBoot 2.0 Micrometer 自定义业务指标监控"></a>SpringBoot 2.0 Micrometer 自定义业务指标监控</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2></blockquote><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，它提供了多种度量指标类型（Timers、Guauges、Counters等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus 等。我们可以通过 Micrometer 收集 Java 性能数据，配合 Prometheus 监控系统实时获取数据，并最终在 Grafana 上展示出来，从而很容易实现应用的监控。</p><h3 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h3><p>Micrometer 中有两个最核心的概念，分别是计量器（Meter）和计量器注册表（MeterRegistry）。计量器用来收集不同类型的性能指标信息，Micrometer 提供了如下几种不同类型的计量器：</p><ul><li>计数器（Counter）: 表示收集的数据是按照某个趋势（增加／减少）一直变化的，也是最常用的一种计量器，例如接口请求总数、请求错误总数、队列数量变化等。</li><li>计量仪（Gauge）: 表示搜集的瞬时的数据，可以任意变化的，例如常用的 CPU Load、Mem 使用量、Network 使用量、实时在线人数统计等，</li><li>计时器（Timer）: 用来记录事件的持续时间，这个用的比较少。</li><li>分布概要（Distribution summary）: 用来记录事件的分布情况，表示一段时间范围内对数据进行采样，可以用于统计网络请求平均延迟、请求延迟占比等。</li></ul><h3 id="1-2-MeterRegistry"><a href="#1-2-MeterRegistry" class="headerlink" title="1.2 MeterRegistry"></a>1.2 MeterRegistry</h3><p>Meter是收集关于你的应用的一系列指标的接口。Meter是由MeterRegistry创建的。每个支持的监控系统都必须实现MeterRegistry。Micrometer中包含一个SimpleMeterRegistry，它在内存中维护每个meter的最新值，并且不支持将数据导出到任何地方，主要用来进行本地开发和测试。<br>Micrometer 支持多个不同的监控系统。通过计量器注册表实现类 CompositeMeterRegistry 可以把多个计量器注册表组合起来，从而允许同时发布数据到多个监控系统。对于由这个类创建的计量器，它们所产生的数据会对 CompositeMeterRegistry中包含的所有计量器注册表都产生影响。</p><h3 id="1-3-Actuator"><a href="#1-3-Actuator" class="headerlink" title="1.3 Actuator"></a>1.3 Actuator</h3><p>你可以通过文末的参考文章获取它的详细概念和具体使用方法。这里只是简述下他的概念和使用方式，本文重点在micrometer。</p><p>Spring Boot Actuator是Spring Boot的一个组件，可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。<br>你可以访问 <a href="http://ip:端口/actuator">http://ip:端口/actuator</a> 查看系统中暴露的endpoint信息，也可以加上具体的 endpoint 查看他们的详细情况，例如 <a href="http://127.0.0.1:7001/actuator/health">http://127.0.0.1:7001/actuator/health</a> 查看健康信息。Spring Boot 2中的依赖actuator中集成的度量统计API使用的框架是Micrometer。官网</p><p>本文重点介绍/actuator/metrics，其他的就属于抛砖了。</p><h3 id="1-4-metrics"><a href="#1-4-metrics" class="headerlink" title="1.4 metrics"></a>1.4 metrics</h3><p>打开 ip:端口/actuator/metrics 网址就可以看到当前微服务的所有metrics，每一个metric都相当于influx数据库的一个measurement，也就是传统数据库的数据表的概念。</p><h2 id="2、自定义metrics"><a href="#2、自定义metrics" class="headerlink" title="2、自定义metrics"></a>2、自定义metrics</h2><p>本篇以监控线程池中的待执行任务数量监控为例</p><p>首先，添加以下依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 微服务运行监控  --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;micrometer-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;micrometer.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- 统计信息输出到 prometheus --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;micrometer-registry-prometheus&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;micrometer.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-两种常用指标类型-Metric-Type"><a href="#2-两种常用指标类型-Metric-Type" class="headerlink" title="2. 两种常用指标类型(Metric Type)"></a>2. 两种常用指标类型(Metric Type)</h3><p>gauge: 可增可减计数器，反应某值当前一刻状态。比如称重传感器的当前重量，温度传感器的当前温度。<br>方式一:</p><pre class="line-numbers language-none"><code class="language-none">Gauge.builder(&quot;lego.thread-pool.pending_task&quot;, new AtomicInteger(37), AtomicInteger::get)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-none"><code class="language-none">registry.gauge(&quot;lego.thread-pool.pending_task&quot;, Tags.of(&quot;site&quot;, &quot;SiteA&quot;, &quot;cab&quot;, &quot;cab01&quot;), new AtomicInteger(37));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两者等价</p><h3 id="3-接入到系统的方式"><a href="#3-接入到系统的方式" class="headerlink" title="3. 接入到系统的方式"></a>3. 接入到系统的方式</h3><p>方式一，业务系统埋点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class SampleBean &#123;    private final Counter counter;    public SampleBean(MeterRegistry registry) &#123;        this.counter &#x3D; registry.counter(&quot;request.counter&quot;);    &#125;    public void handleMessage(String message) &#123;        this.counter.increment();        &#x2F;&#x2F; handle message implementation    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：MeterBinder</p><p>SpringBoot中提供了MeterBinder接口用于申明与注册meterRegistry。自定义Metrics只需要实现MeterBinder接口，Spring会自动发现并完成后续的杂活。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * @author Ricky Fung *&#x2F;public class DynamicThreadPoolExecutorMetrics implements MeterBinder &#123;    private final Logger LOG &#x3D; LoggerFactory.getLogger(this.getClass());    @Autowired(required &#x3D; false)    private List&lt;DynamicThreadPoolExecutor&gt; executors &#x3D; Collections.EMPTY_LIST;    @Override    public void bindTo(MeterRegistry meterRegistry) &#123;        String localIp &#x3D; IpUtils.getLocalIp();        LOG.info(&quot;动态线程池-监控自动装配开始, localIp:&#123;&#125;, meterRegistry:&#123;&#125;&quot;, localIp, meterRegistry.getClass());        for (DynamicThreadPoolExecutor executor : executors) &#123;            String name &#x3D; executor.getName();            AtomicInteger pendingTask &#x3D; new AtomicInteger(0);            Gauge.builder(&quot;lego.thread-pool.pending_task&quot;, pendingTask, AtomicInteger::get)                    .tag(&quot;name&quot;, name)                    .tag(&quot;IP&quot;, localIp)                    .description(&quot;动态线程池待执行任务数&quot;)                    .register(meterRegistry);            Counter totalTask &#x3D; Counter.builder(&quot;lego.thread-pool.total_task&quot;)                    .tag(&quot;name&quot;, name)                    .tag(&quot;IP&quot;, localIp)                    .description(&quot;动态线程池累计提交任务数&quot;)                    .register(meterRegistry);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://dzone.com/articles/using-micrometer-with-spring-boot-2">Dzone - Using Micrometer With Spring Boot 2</a></li><li><a href="https://blog.autsoft.hu/defining-custom-metrics-in-a-spring-boot-application-using-micrometer/">Defining custom metrics in a Spring Boot application using Micrometer</a></li><li>[Monitoring Spring Boot Application With Micrometer, Prometheus And Grafana Using Custom Metrics](</li></ul>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
          <category> micrometer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegraf安装部署</title>
      <link href="/2022/06/30/telegraf-an-zhuang-bu-shu/"/>
      <url>/2022/06/30/telegraf-an-zhuang-bu-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu-和-Debian"><a href="#Ubuntu-和-Debian" class="headerlink" title="Ubuntu 和 Debian"></a><a href="https://docs.influxdata.com/telegraf/v1.23/install/#ubuntu--debian">Ubuntu 和 Debian</a></h3><p>使用以下命令从 InfluxData 存储库安装 Telegraf：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># influxdb.key GPG Fingerprint: 05CE15085FC09D18E99EFB22684A14CF2582E0C5wget -q https:&#x2F;&#x2F;repos.influxdata.com&#x2F;influxdb.keyecho &#39;23a1c8836f0afc5ed24e0486339d7cc8f6790b83886c4c96995b88a061c5bb5d influxdb.key&#39; | sha256sum -c &amp;&amp; cat influxdb.key | gpg --dearmor | sudo tee &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;influxdb.gpg &gt; &#x2F;dev&#x2F;nullecho &#39;deb [signed-by&#x3D;&#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;influxdb.gpg] https:&#x2F;&#x2F;repos.influxdata.com&#x2F;debian stable main&#39; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;influxdata.listsudo apt-get update &amp;&amp; sudo apt-get install telegraf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从<code>.deb</code>文件</strong>安装：</p><p>从<code>.deb</code>文件手动安装 Debian 软件包：</p><ol><li><p><a href="https://influxdata.com/downloads/">从下载页面</a><code>.deb</code>的 Telegraf 部分下载最新的 Telegraf版本。</p></li><li><p>运行以下命令（确保为下载的文件提供正确的版本号）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dpkg -i telegraf_1.23.0-1_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="配置Telegraf"><a href="#配置Telegraf" class="headerlink" title="配置Telegraf"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#configure-telegraf">配置Telegraf</a></h2><p>定义 Telegraf 将在配置文件中使用哪些插件。每个配置文件都需要至少一个启用的<a href="https://docs.influxdata.com/telegraf/v1.23/plugins/inputs/">输入插件</a>（指标来自哪里）和至少一个启用的<a href="https://docs.influxdata.com/telegraf/v1.23/plugins/outputs/">输出插件</a>（指标去哪里）。</p><p>以下示例生成包含所有可用插件的示例配置文件，然后使用<code>filter</code>标志启用特定插件。</p><p>有关<code>filter</code>其他标志的详细信息，请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/commands/">Telegraf 命令和标志</a>。</p><ol><li><p>运行以下命令创建配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --sample-config &gt; telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>找到配置文件。位置因您的系统而异：</p><ul><li>macOS<a href="http://brew.sh/">自制软件</a>：<code>/usr/local/etc/telegraf.conf</code></li><li>Linux debian 和 RPM 软件包：<code>/etc/telegraf/telegraf.conf</code></li><li>独立二进制文件：请参阅下一节了解如何创建配置文件</li></ul><blockquote><p><strong>注意：</strong>您还可以指定一个远程 URL 端点以从中提取配置文件。请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/configuration/#configuration-file-locations">配置文件位置</a>。</p></blockquote></li><li><p><code>vim</code>使用或 文本编辑器编辑配置文件。因为此示例使用<a href="https://github.com/influxdata/telegraf/blob/release-1.21/plugins/outputs/influxdb_v2/README.md">InfluxDB V2 输出插件</a>，我们需要将 InfluxDB URL、身份验证令牌、组织和存储桶详细信息添加到配置文件的这一部分。</p></li></ol><blockquote><p><strong>注意：</strong>有关更多配置文件选项，请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/configuration/">配置选项</a>。</p></blockquote><ol><li>对于此示例，使用标志指定两个输入 (<code>cpu</code>和<code>mem</code>) 。<code>--input-filter</code>将 InfluxDB 指定为带有<code>--output-filter</code>标志的输出。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --sample-config --input-filter cpu:mem --output-filter influxdb_v2 &gt; telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的配置将收集 CPU 和内存数据并将其发送到 InfluxDB V2。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#set-environment-variables">设置环境变量</a></h2><p>在配置文件的任何位置添加环境变量，方法是在它们前面加上<code>$</code>. 对于字符串，变量必须用引号引起来（例如，<code>&quot;$STR_VAR&quot;</code>）。对于数字和布尔值，变量必须不加引号（例如<code>$INT_VAR</code>，, <code>$BOOL_VAR</code>）。</p><p>您还可以使用 Linux<code>export</code>命令设置环境变量：<code>export password=mypassword</code></p><blockquote><p><strong>注意：</strong>我们建议对敏感信息使用环境变量。</p></blockquote><h3 id="示例：Telegraf-环境变量"><a href="#示例：Telegraf-环境变量" class="headerlink" title="示例：Telegraf 环境变量"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#example-telegraf-environment-variables">示例：Telegraf 环境变量</a></h3><p>在 Telegraf 环境变量文件 ( <code>/etc/default/telegraf</code>) 中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">USER&#x3D;&quot;alice&quot;INFLUX_URL&#x3D;&quot;https:&#x2F;&#x2F;us-west-2-1.aws.cloud2.influxdata.com&quot;INFLUX_SKIP_DATABASE_CREATION&#x3D;&quot;true&quot;INFLUX_PASSWORD&#x3D;&quot;monkey123&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#">InfluxDB 云还是 OSS？</a></p><p>在 Telegraf 配置文件 ( <code>/etc/telegraf.conf</code>) 中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[global_tags]  user &#x3D; &quot;$&#123;USER&#125;&quot;[[inputs.mem]][[outputs.influxdb]]  urls &#x3D; [&quot;$&#123;INFLUX_URL&#125;&quot;]  skip_database_creation &#x3D; $&#123;INFLUX_SKIP_DATABASE_CREATION&#125;  password &#x3D; &quot;$&#123;INFLUX_PASSWORD&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的环境变量将以下配置设置添加到 Telegraf：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[global_tags]  user &#x3D; &quot;alice&quot;[[outputs.influxdb]]  urls &#x3D; &quot;https:&#x2F;&#x2F;us-west-2-1.aws.cloud2.influxdata.com&quot;  skip_database_creation &#x3D; true  password &#x3D; &quot;monkey123&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#">InfluxDB 云还是 OSS？</a></p><h2 id="启动电报"><a href="#启动电报" class="headerlink" title="启动电报"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#start-telegraf">启动电报</a></h2><p>接下来，您需要启动 Telegraf 服务并将其定向到您的配置文件：</p><h3 id="macOS自制软件"><a href="#macOS自制软件" class="headerlink" title="macOS自制软件"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#macos-homebrewhttpbrewsh">macOS</a><a href="http://brew.sh/">自制软件</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --config telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux（sysvinit-和-upstart-安装）"><a href="#Linux（sysvinit-和-upstart-安装）" class="headerlink" title="Linux（sysvinit 和 upstart 安装）"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#linux-sysvinit-and-upstart-installations">Linux（sysvinit 和 upstart 安装）</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service telegraf start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux（系统安装）"><a href="#Linux（系统安装）" class="headerlink" title="Linux（系统安装）"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#linux-systemd-installations">Linux（系统安装）</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start telegraf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 系统监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Telegraf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基本数据类型</title>
      <link href="/2022/06/21/java-ji-ben-shu-ju-lei-xing/"/>
      <url>/2022/06/21/java-ji-ben-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p><p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/2020-10-27-code-mem.png" alt="img"></p><p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java 的两大数据类型:</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><hr><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 <strong>0</strong>；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： <strong>long a = 100000L</strong>，<strong>long b = -200000L</strong>。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p><strong>double：</strong></p><ul><li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p></li><li><p>浮点数的默认类型为 double 类型；</p></li><li><p>double类型同样不能表示精确的值，如货币；</p></li><li><p>默认值是 <strong>0.0d</strong>；</p></li><li><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">double   d1  &#x3D; 7D ;double   d2  &#x3D; 7.; double   d3  &#x3D;  8.0; double   d4  &#x3D;  8.D; double   d5  &#x3D;  12.9867; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p></li></ul><p><strong>boolean：</strong></p><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 <strong>false</strong>；</li><li>例子：boolean one = true。</li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 <strong>\u0000</strong>（十进制等效值为 0）；</li><li>最大值是 <strong>\uffff</strong>（即为 65535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter = ‘A’;。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrimitiveTypeTest &#123;        public static void main(String[] args) &#123;              &#x2F;&#x2F; byte              System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);              System.out.println(&quot;包装类：java.lang.Byte&quot;);              System.out.println(&quot;最小值：Byte.MIN_VALUE&#x3D;&quot; + Byte.MIN_VALUE);              System.out.println(&quot;最大值：Byte.MAX_VALUE&#x3D;&quot; + Byte.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; short              System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);              System.out.println(&quot;包装类：java.lang.Short&quot;);              System.out.println(&quot;最小值：Short.MIN_VALUE&#x3D;&quot; + Short.MIN_VALUE);              System.out.println(&quot;最大值：Short.MAX_VALUE&#x3D;&quot; + Short.MAX_VALUE);              System.out.println();                 &#x2F;&#x2F; int              System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);              System.out.println(&quot;包装类：java.lang.Integer&quot;);              System.out.println(&quot;最小值：Integer.MIN_VALUE&#x3D;&quot; + Integer.MIN_VALUE);              System.out.println(&quot;最大值：Integer.MAX_VALUE&#x3D;&quot; + Integer.MAX_VALUE);              System.out.println();              &#x2F;&#x2F; long              System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);              System.out.println(&quot;包装类：java.lang.Long&quot;);              System.out.println(&quot;最小值：Long.MIN_VALUE&#x3D;&quot; + Long.MIN_VALUE);              System.out.println(&quot;最大值：Long.MAX_VALUE&#x3D;&quot; + Long.MAX_VALUE);              System.out.println();            &#x2F;&#x2F; float              System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);              System.out.println(&quot;包装类：java.lang.Float&quot;);              System.out.println(&quot;最小值：Float.MIN_VALUE&#x3D;&quot; + Float.MIN_VALUE);              System.out.println(&quot;最大值：Float.MAX_VALUE&#x3D;&quot; + Float.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; double              System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);              System.out.println(&quot;包装类：java.lang.Double&quot;);              System.out.println(&quot;最小值：Double.MIN_VALUE&#x3D;&quot; + Double.MIN_VALUE);              System.out.println(&quot;最大值：Double.MAX_VALUE&#x3D;&quot; + Double.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; char              System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);              System.out.println(&quot;包装类：java.lang.Character&quot;);                  &#x2F;&#x2F; 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台              System.out.println(&quot;最小值：Character.MIN_VALUE&#x3D;&quot; + (int) Character.MIN_VALUE);              &#x2F;&#x2F; 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台              System.out.println(&quot;最大值：Character.MAX_VALUE&#x3D;&quot; + (int) Character.MAX_VALUE);       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译以上代码输出结果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE&#x3D;-128最大值：Byte.MAX_VALUE&#x3D;127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE&#x3D;-32768最大值：Short.MAX_VALUE&#x3D;32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE&#x3D;-2147483648最大值：Integer.MAX_VALUE&#x3D;2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE&#x3D;-9223372036854775808最大值：Long.MAX_VALUE&#x3D;9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE&#x3D;1.4E-45最大值：Float.MAX_VALUE&#x3D;3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE&#x3D;4.9E-324最大值：Double.MAX_VALUE&#x3D;1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE&#x3D;0最大值：Character.MAX_VALUE&#x3D;65535<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103 =3140，3.14E-3 就是 3.14 x 10-3 =0.00314。</p><p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p>下表列出了 Java 各个类型的默认值：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>数据类型</strong></th><th style="text-align:left"><strong>默认值</strong></th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">0L</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">0.0f</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">0.0d</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">‘u0000’</td></tr><tr><td style="text-align:left">String (or any object)</td><td style="text-align:left">null</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">false</td></tr></tbody></table></div><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>public class Test {    static boolean bool;    static byte by;    static char ch;    static double d;    static float f;    static int i;    static long l;    static short sh;    static String str;     public static void main(String[] args) {        System.out.println(“Bool :” + bool);        System.out.println(“Byte :” + by);        System.out.println(“Character:” + ch);        System.out.println(“Double :” + d);        System.out.println(“Float :” + f);        System.out.println(“Integer :” + i);        System.out.println(“Long :” + l);        System.out.println(“Short :” + sh);        System.out.println(“String :” + str);    } }</p><p>实例输出结果为：</p><pre class="line-numbers language-none"><code class="language-none">Bool     :falseByte     :0Character:Double   :0.0Float    :0.0Integer  :0Long     :0Short    :0String   :null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li></ul><hr><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。</p><p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p><pre class="line-numbers language-none"><code class="language-none">final double PI &#x3D; 3.1415927;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p><p>字面量可以赋给任何内置类型的变量。例如：</p><pre class="line-numbers language-none"><code class="language-none">byte a &#x3D; 68;char a &#x3D; &#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p><p>当使用字面量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：</p><pre class="line-numbers language-none"><code class="language-none">int decimal &#x3D; 100;int octal &#x3D; 0144;int hexa &#x3D;  0x64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p><pre class="line-numbers language-none"><code class="language-none">&quot;Hello World&quot;&quot;two\nlines&quot;&quot;\&quot;This is in quotes\&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>字符串常量和字符变量都可以包含任何 Unicode 字符。例如：</p><pre class="line-numbers language-none"><code class="language-none">char a &#x3D; &#39;\u0001&#39;;String a &#x3D; &quot;\u0001&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java语言支持一些特殊的转义字符序列。</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">字符含义</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行 (0x0a)</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车 (0x0d)</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符(0x0c)</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 (0x08)</td></tr><tr><td style="text-align:left">\0</td><td style="text-align:left">空字符 (0x0)</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">空格 (0x20)</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">反斜杠</td></tr><tr><td style="text-align:left">\ddd</td><td style="text-align:left">八进制字符 (ddd)</td></tr><tr><td style="text-align:left">\uxxxx</td><td style="text-align:left">16进制Unicode字符 (xxxx)</td></tr></tbody></table></div><hr><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级。</p><pre class="line-numbers language-none"><code class="language-none">低  ------------------------------------&gt;  高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据类型转换必须满足如下规则：</p><ul><li><p>\1. 不能对boolean类型进行类型转换。</p></li><li><p>\2. 不能把对象类型转换成不相关类的对象。</p></li><li><p>\3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>\4. 转换过程中可能导致溢出或损失精度，例如：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D;128;   byte b &#x3D; (byte)i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>\5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><pre class="line-numbers language-none"><code class="language-none">(int)23.7 &#x3D;&#x3D; 23;        (int)-45.89f &#x3D;&#x3D; -45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>public class ZiDongLeiZhuan{        public static void main(String[] args){            char c1=’a’;//定义一个char类型            int i1 = c1;//char自动类型转换为int            System.out.println(“char自动类型转换为int后的值等于”+i1);            char c2 = ‘A’;//定义一个char类型            int i2 = c2+1;//char 类型和 int 类型计算            System.out.println(“char类型和int计算后的值等于”+i2);        } }</p><p>运行结果为:</p><pre class="line-numbers language-none"><code class="language-none">char自动类型转换为int后的值等于97char类型和int计算后的值等于66<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解析：</strong>c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 <strong>i2=65+1=66</strong>。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li><p>\1. 条件是转换的数据类型必须是兼容的。</p></li><li><p>\2. 格式：(type)value type是要强制类型转换后的数据类型 实例：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>public class QiangZhiZhuanHuan{    public static void main(String[] args){        int i1 = 123;        byte b = (byte)i1;//强制类型转换为byte        System.out.println(“int强制类型转换为byte后的值等于”+b);    } }</p><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">int强制类型转换为byte后的值等于123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ul><li>1、 整数的默认类型是 int。</li><li>\2. 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li></ul><p>这一节讲解了 Java 的基本数据类型。下一节将探讨不同的变量类型以及它们的用法。</p>]]></content>
      
      
      <categories>
          
          <category> java基本数据类型 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式（Abstract Factory Pattern）</title>
      <link href="/2022/06/11/chou-xiang-gong-han-mo-shi-abstract-factory-pattern/"/>
      <url>/2022/06/11/chou-xiang-gong-han-mo-shi-abstract-factory-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况，<em>呵呵，这种情况是我们码农该考虑的</em>（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p><p><em>AbstractFactoryPatternDemo</em> 类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式的 UML 图"></a></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>为形状创建一个接口。</p><h4 id="Shape-java"><a href="#Shape-java" class="headerlink" title="Shape.java"></a>Shape.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Shape &#123;   void draw();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><h4 id="Rectangle-java"><a href="#Rectangle-java" class="headerlink" title="Rectangle.java"></a>Rectangle.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Rectangle implements Shape &#123;      @Override   public void draw() &#123;          System.out.println(&quot;Inside Rectangle::draw() method.&quot;);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Square-java"><a href="#Square-java" class="headerlink" title="Square.java"></a>Square.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Square implements Shape &#123;      @Override     public void draw() &#123;          System.out.println(&quot;Inside Square::draw() method.&quot;);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Circle-java"><a href="#Circle-java" class="headerlink" title="Circle.java"></a>Circle.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Circle implements Shape &#123;      @Override     public void draw() &#123;     System.out.println(&quot;Inside Circle::draw() method.&quot;);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>为颜色创建一个接口。</p><h4 id="Color-java"><a href="#Color-java" class="headerlink" title="Color.java"></a>Color.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Color &#123;     void fill(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h3><p>创建实现接口的实体类。</p><h4 id="Red-java"><a href="#Red-java" class="headerlink" title="Red.java"></a>Red.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Red implements Color &#123;      @Override     public void fill() &#123;          System.out.println(&quot;Inside Red::fill() method.&quot;);     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Green-java"><a href="#Green-java" class="headerlink" title="Green.java"></a>Green.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Green implements Color &#123;      @Override     public void fill() &#123;        System.out.println(&quot;Inside Green::fill() method.&quot;);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Blue-java"><a href="#Blue-java" class="headerlink" title="Blue.java"></a>Blue.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Blue implements Color &#123;      @Override     public void fill() &#123;          System.out.println(&quot;Inside Blue::fill() method.&quot;);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p><h4 id="AbstractFactory-java"><a href="#AbstractFactory-java" class="headerlink" title="AbstractFactory.java"></a>AbstractFactory.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractFactory &#123;    public abstract Color getColor(String color);    public abstract Shape getShape(String shape); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p><h4 id="ShapeFactory-java"><a href="#ShapeFactory-java" class="headerlink" title="ShapeFactory.java"></a>ShapeFactory.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShapeFactory extends AbstractFactory &#123;         @Override     public Shape getShape(String shapeType)&#123;         if(shapeType &#x3D;&#x3D; null)&#123;           return null;      &#125;            if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123;            return new Circle();        &#125;     else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123;            return new Rectangle();         &#125;     else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123;          return new Square();       &#125;          return null;    &#125;        @Override     public Color getColor(String color) &#123;          return null;   &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ColorFactory-java"><a href="#ColorFactory-java" class="headerlink" title="ColorFactory.java"></a>ColorFactory.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ColorFactory extends AbstractFactory &#123;        @Override    public Shape getShape(String shapeType)&#123;       return null;   &#125;       @Override    public Color getColor(String color) &#123;       if(color &#x3D;&#x3D; null)&#123;              return null;      &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123;        return new Red();         &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123;               return new Green();          &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123;            return new Blue();        &#125;         return null;    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p><h4 id="FactoryProducer-java"><a href="#FactoryProducer-java" class="headerlink" title="FactoryProducer.java"></a>FactoryProducer.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FactoryProducer &#123;     public static AbstractFactory getFactory(String choice)&#123;         if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123;              return new ShapeFactory();         &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123;         return new ColorFactory();      &#125;         return null;   &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><h4 id="AbstractFactoryPatternDemo-java"><a href="#AbstractFactoryPatternDemo-java" class="headerlink" title="AbstractFactoryPatternDemo.java"></a>AbstractFactoryPatternDemo.java</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class AbstractFactoryPatternDemo &#123;     public static void main(String[] args) &#123;          &#x2F;&#x2F;获取形状工厂         AbstractFactory shapeFactory &#x3D; FactoryProducer.getFactory(&quot;SHAPE&quot;);           &#x2F;&#x2F;获取形状为 Circle 的对象          Shape shape1 &#x3D; shapeFactory.getShape(&quot;CIRCLE&quot;);           &#x2F;&#x2F;调用 Circle 的 draw 方法      shape1.draw();           &#x2F;&#x2F;获取形状为 Rectangle 的对象          Shape shape2 &#x3D; shapeFactory.getShape(&quot;RECTANGLE&quot;);           &#x2F;&#x2F;调用 Rectangle 的 draw 方法        shape2.draw();                &#x2F;&#x2F;获取形状为 Square 的对象          Shape shape3 &#x3D; shapeFactory.getShape(&quot;SQUARE&quot;);          &#x2F;&#x2F;调用 Square 的 draw 方法          shape3.draw();          &#x2F;&#x2F;获取颜色工厂         AbstractFactory colorFactory &#x3D; FactoryProducer.getFactory(&quot;COLOR&quot;);           &#x2F;&#x2F;获取颜色为 Red 的对象          Color color1 &#x3D; colorFactory.getColor(&quot;RED&quot;);           &#x2F;&#x2F;调用 Red 的 fill 方法          color1.fill();           &#x2F;&#x2F;获取颜色为 Green 的对象          Color color2 &#x3D; colorFactory.getColor(&quot;GREEN&quot;);           &#x2F;&#x2F;调用 Green 的 fill 方法          color2.fill();           &#x2F;&#x2F;获取颜色为 Blue 的对象          Color color3 &#x3D; colorFactory.getColor(&quot;BLUE&quot;);           &#x2F;&#x2F;调用 Blue 的 fill 方法          color3.fill();    &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h3><p>执行程序，输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Inside Circle::draw() method.Inside Rectangle::draw() method.Inside Square::draw() method.Inside Red::fill() method.Inside Green::fill() method.Inside Blue::fill() method.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 抽象工厂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OmniPlan使用教程</title>
      <link href="/2022/06/02/omniplan-shi-yong-jiao-cheng/"/>
      <url>/2022/06/02/omniplan-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="使用检查器"><a href="#使用检查器" class="headerlink" title="使用检查器"></a>使用检查器</h1><p>之所以这么称呼，是因为它们提供用于<em>检查</em>您当前选择的工具，OmniPlan 3 中的检查器经过重新设计，拥有前所未有的更强功能、灵活性和易用性。</p><p>OmniPlan 的检查器位于主窗口右侧的工具条中。您可以点按并拖移检查器左边缘以隐藏检查器，为主视图提供更多屏幕空间；从窗口右侧拖入则可显示隐藏的检查器。“检查器”▸“显示/隐藏检查器”(<strong>Shift-Command-I</strong>) 也可以做到这点。</p><p>如果选择 OmniPlan 视图之一中的某个项目（通常是任务和网络视图中的任务、资源和日历视图中的资源，或样式视图中的样式），应用程序将自动切换到与所选项目类型最相关的检查器。当未选择任何项目时，会默认选择项目检查器，其他检查器中进行的编辑会影响整个项目的属性。</p><h2 id="项目检查器"><a href="#项目检查器" class="headerlink" title="项目检查器"></a>项目检查器</h2><p>项目检查器包含有关整个文稿的信息。它划分为三个部分，每个部分提供与项目结构和时间流相关的控制项。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_10_projectinspectorsummary.png" alt="项目检查器。"></p><ul><li><strong>项目信息</strong> — 有关整个项目的一般信息，例如项目的标题以及从开始日期还是结束日期安排项目。同时，也是进行安排间隔设置的位置。</li><li><strong>格式</strong> — 配置时间和货币单位。</li><li><strong>投入单位转换</strong> — 定义给定工作日、周、月和年中的工作时间。点按“编辑工作周”按钮转至“日历视图”并对您的工作时数进行调整。</li></ul><p>点按每个部分旁边的收折三角形来显示或隐藏其内容。</p><h3 id="编辑项目信息"><a href="#编辑项目信息" class="headerlink" title="编辑项目信息"></a>编辑项目信息</h3><p>项目检查器的“项目信息”部分介绍关于如何从头构建项目的基本知识。选定这些详细信息是理解项目范围和计划表的关键。</p><p><strong>选择特定或未确定的项目日期</strong></p><p>如果您不知道项目何时开始或结束，可以在项目检查器的“项目信息”部分中将开始日期标记为未确定。为了应用工作周，假定该项目在一周的第一天开始。项目和单个资源的正常工作周有效，但工作计划表例外（如节假日）无效。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_15_projectinspectorundetermineddates.png" alt="选择是以特定日期还是以未确定的日期处理项目。"></p><p>在未确定日期的项目中，所有日期都以“T 日”格式表示，T 表示项目的第一天，“T + x”中的 x 表示一段持续时间。例如，“T+2周 1天”表示项目开始后的 2 周又 1 天。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_16_tdayexample.png" alt="以未确定日期安排的项目。"></p><p>如果您将现有项目的开始或结束日期从未确定日期更改为实际日期，由于周末、休息日和其他例外的位置发生变化，该项目也可能会随之变化。</p><p><strong>开始日期和结束日期</strong></p><p>如果您知道项目何时开始或结束，可以在此处输入日期。如此一来，在日历视图中设置的所有工作时数和工作计划表例外都可正确应用，界面中会显示实际日期。如果您的项目具有开始日期，则任务会尽快从该日开始计划。如果项目具有结束日期，任务将尽晚地从该日向后计划。您可以在<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/11_inspectors.xhtml#thetaskinspector">任务检查器</a>中更改任务的日期和方向。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_11_projectinfostartend.png" alt="在项目检查器的“项目信息”部分中设置开始日期或结束日期。"></p><p><strong>注意</strong><br>通过设置项目的开始或结束日期可定义项目的<em>方向</em>：计划表是从开始日期向前还是从结束日期向后构建。在前一种情况中是尽快 (ASAP) 安排完成项目中的所有任务，而在后一种情况中是尽晚 (ALAP) 安排所有任务。<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/11_inspectors.xhtml#thetaskinspector">任务检查器</a>部分涵盖了更改个别任务的方向。</p><p>大多数项目中的任务都安排为尽快完成，这可帮助从已定义的“发布日期”向后计划项目，从而帮助确定何时应开始项目。</p><p><strong>安排间隔</strong></p><p>可以使用项目检查器“项目信息”部分中的“间隔”控制项，使 OmniPlan 将每个持续时间四舍五入到下一个整小时或整天。这个设置不仅用于显示目的，还会实际更改 OmniPlan 安排任务的精确度。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_18_projectinfogranularity.png" alt="项目检查器的“项目信息”部分中的间隔。"></p><p>根据预设，OmniPlan 使用<strong>精确安排</strong>：如果任务的投入为 58 分钟，开始于 8:00，则其会在甘特图上正好持续 58 分钟，其从属任务开始于 8:58，分级会让资源在 8:58 用于下一个任务，依此类推。任务的开始时间和结束时间会精确到秒。</p><p>使用<strong>每小时安排</strong>，开始时间和结束时间会发生在下一个整小时标记处。如果某个任务开始于 8:00，投入为 58 分钟（或者甚至 1 分钟）,则结束于 9:00；从属任务和资源分级的任务会开始于 9:00，依此类推。</p><p>使用<strong>每日安排</strong>，开始和结束时间总是工作日的开始或结束时间。58 分钟的任务会在一天结束时结束，从属任务和资源分级的任务会开始于第二天，依此类推。 </p><p>除了间隔设置之外，OmniPlan 不会忘记您输入的任何值。您还可以使用任何的精确度来指定任务的投入和资源单位，当您切换回精确安排时，OmniPlan 会存储那些值。</p><p><strong>快速查看预览设置</strong></p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_29_quicklookpreview.png" alt="项目检查器的“格式”部分。"></p><p>该检查器此部分的最后一个选项是个开关，可控制当保存项目时是否创建文稿快速查看预览。在大多数现代的 Mac 设备上，此流程不会明显影响您对应用程序的使用，但是如果您在保存时遇到性能问题，关闭快速查看预览可能对体验有所改进。</p><h3 id="选择时间和货币格式"><a href="#选择时间和货币格式" class="headerlink" title="选择时间和货币格式"></a>选择时间和货币格式</h3><p>可以使用项目检查器的“格式”部分来定义您的项目如何显示时间和货币的单位。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_17_projectinfoformats.png" alt="项目检查器的“格式”部分。"></p><ol><li>使用<strong>日期</strong>部分可选择所显示的日期中是否包含秒和/或钟点。请注意，这不会影响项目安排或持续时间；只会影响日期如何显示在整个项目的相应位置。</li><li>从下拉列表选择标准<strong>货币</strong>格式，或只需键入所选货币符号，该字段便会以适当的格式进行自动填充。</li><li>此处所选的时间单位用于显示<strong>持续时间</strong>和<strong>投入</strong>量。您可以使用时数、天数或任何最适用于您的方式来显示。请注意，如果您在持续时间字段中输入不带有任何单位的数字，则 OmniPlan 会假设您在这里使用所启用的最小单位。整个 OmniPlan 中时间单位的（持续时间和投入）缩写命名如下：<ul><li>s — 秒</li><li>m — 分</li><li>h — 时</li><li>d — 天</li><li>w — 周</li><li>mo — 月</li><li>y — 年</li></ul></li></ol><p>如果您不仅仅要自定持续时间显示，则可以使用上文<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/11_inspectors.xhtml#editingprojectinformation">项目信息</a>部分中的安排间隔设置，使 OmniPlan 以整小时或整日进行安排。请注意，甘特图和资源时间线中的日期标头也可以使用<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/14_prefs.xhtml#displaypreferences">显示预置</a>进行自定。</p><p><strong>注意</strong><br>如果某个值包含的时间单位太小而无法显示，则您会看到一个<strong>四舍五入的值</strong>。例如，如果您已经在项目检查器的“格式”部分中停用分钟的显示，而有一项任务于 9:00 开始，在 9:55 结束，则您看到的值是“&lt; 1h”。如果您想知道实际的值，可以在“格式”部分中启用较小的单位，或直接查看任务的开始和结束时间。如果您要编辑值，让其与您的单位相符合，可以直接删除大于号或小于号，该值即会更新。</p><h3 id="设置投入单位转换"><a href="#设置投入单位转换" class="headerlink" title="设置投入单位转换"></a>设置投入单位转换</h3><p>当您未使用每周 40 小时或一天八小时的标准单位，您可以使用项目检查器的“投入单位转换”部分自定项目工作时间的标准单位。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_19_projectinfoeuc.png" alt="项目检查器的“投入单位转换”部分。"></p><p>您的工作日可能是任何时数。这些转换因子决定如何将时数累加到较大的单位。</p><p>投入转换因子并不会更改项目的工作时数，而只是更改持续时间的输入和显示方式。要更改工作时数，请参访日历视图中的工作周区域。</p><p>决定想要的单位转换后，您可能需要编辑工作周以与新值相对应并确保安排了足够的人时。“投入单位转换”部分包含<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/08_calendarview.xhtml">日历视图</a>的方便链接，您可以在该视图中执行操作。</p><h2 id="里程碑检查器"><a href="#里程碑检查器" class="headerlink" title="里程碑检查器"></a>里程碑检查器</h2><p>可使用里程碑检查器管理里程碑以及其重要路径的显示。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_02_milestonesinspector.png" alt="里程碑检查器。"></p><p>使用每个里程碑旁边的复选框切换显示其在甘特图和网络视图中的重要路径。（还可以从工具栏中“重要路径”按钮旁的下拉菜单选择要显示的重要路径。）</p><p>首次选择显示给定里程碑的重要路径时，OmniPlan 将为其自动分配颜色；您可以通过点按<strong>显示此里程碑的重要路径</strong>开关旁边的颜色选择样本更改颜色。</p><p>选择<strong>考虑资源可用性</strong>使重要路径的显示不仅考虑到任务与宽延限制之间的相关性，而且还考虑了用于完成独立任务的必要资源是否可用。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_30_considerresourceavailability.png" alt="里程碑检查器。"></p><p>想要以最清晰的方式了解该检查器的工作原理便是创建一个包含两个独立任务的项目，然后将相同资源分配给这两个任务。对项目进行分级，您会看到第二个任务遵循第一个任务进行移动。此时显示重要路径将只会高亮显示第二个任务 <strong>(1)</strong>。选择考虑资源可用性将同时高亮显示<em>两者</em> <strong>(2)</strong>，这表示，尽管第二个任务不依赖第一个任务便可开始，但会受到完成该任务所需资源的限制。</p><p>重要路径的<strong>宽延限制</strong>可确定在任务被视为重要路径的一部分之前，该任务对于里程碑推动的紧迫程度。增加此处的时间值可扩大重要路径的范围，从而可能包含更多任务。换言之，值越大，任务之间感受到的时间缓冲舒适度越低。</p><h2 id="任务检查器"><a href="#任务检查器" class="headerlink" title="任务检查器"></a>任务检查器</h2><p>任务检查器包含有关任何当前所选任务（里程碑、群组和吊床任务都被视为任务）的信息。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_14_taskinspectorsummary.png" alt="任务检查器。"></p><ul><li><strong>任务信息</strong> — 有关所选任务的一般信息，例如任务的安排时间，以及任务将花费的时间。</li><li><strong>估算工作量（专业版）</strong> — 与 OmniPlan 专业版的<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/04_maintain.xhtml#usingsimulationstoestimatemilestonecompletionpro">模拟</a>功能配合使用，手动配置此处的估算工作量。</li><li><strong>任务计划表</strong> — 有关所选任务计划表的信息，如开始和结束日期，以及受分级影响的程度。</li><li><strong>任务相关性</strong> — 与此任务相关的相关性列表。</li><li><strong>任务分配</strong> — 分配给此任务的资源列表。</li></ul><h3 id="编辑任务信息"><a href="#编辑任务信息" class="headerlink" title="编辑任务信息"></a>编辑任务信息</h3><p>可使用任务检查器“任务信息”部分编辑定义任务类型和范围的关键属性。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_20_taskinspectorinfo.png" alt="任务检查器的“任务信息”部分。"></p><ol><li>任务<strong>名称</strong>与任务大纲中出现的任务名称相同。</li><li>您可以将正常任务的<strong>类型</strong>更改为<strong>里程碑</strong>（表示项目中重要时刻的零长度事件）、任务<strong>群组</strong>（此类型任务可包含子任务）或<strong><a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/06_taskview.xhtml#creatinghammocktasks">吊床任务</a></strong>（其持续时间取决于任务的完成情况以及后面任务的开始情况）。</li><li><strong>投入</strong>是完成此任务要花费的总工作量。<strong>持续时间</strong>是完成该工作要花费的时间。“投入”与“持续时间”取决于分配给任务的资源量，以及所分配资源的效率。请注意，如果您输入不带有任何单位的数字，则 OmniPlan 会假设您使用项目检查器“格式”部分中启用的最小单位。</li><li><strong>已完成</strong>数量是是任务进度的百分比。其也会在甘特图中显示为任务条上的阴影。您可以通过拖动滑块或在字段中输入时间对此进行调整。</li><li>任务<strong>成本</strong>是完成任务要花费的金额。资源是分配给任务的资源每次使用成本或每小时成本</li></ol><h3 id="估算任务工作量（专业版）"><a href="#估算任务工作量（专业版）" class="headerlink" title="估算任务工作量（专业版）"></a>估算任务工作量（专业版）</h3><p>OmniPlan 专业版的<strong>工作量估算</strong>功能与 <a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/04_maintain.xhtml#usingsimulationstoestimatemilestonecompletionpro">Monte Carlo 模拟</a>配合使用以预测里程碑完成情况的时效性。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_21_taskinspectoresteffort.png" alt="任务检查器的“估算工作量”部分。"></p><p>您可以使用工具栏中的<strong>模拟</strong>按钮，自动估算完成任何数量的所选任务所需的工作量。但是，如果您想精确控制完成方案中使用的工作量范围，任务检查器此部分的字段提供您想使用的任何值。</p><p><strong>警告</strong><br>对于 OmniPlan 3，整个应用程序（包括任务大纲中的“工作量”栏、任务检查器中的“工作量”字段等）的工作量值根据上文估算工作量字段中三个值的平均值计算。只要该平均值仍然等于现有值，它们在其他地方就会保持不变（所构建的模拟自动工作量估算功能可确保这点）。但是，在此处（或在关联的自定栏中）手动更改值<strong>将</strong>导致其他工作量值改变。</p><h3 id="安排任务"><a href="#安排任务" class="headerlink" title="安排任务"></a>安排任务</h3><p>任务检查器的“计划表”部分说明了任务在实际时间和相对于基线的时间所处的位置，以及其他临时限制和安排优先级。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_22_taskinspectorschedule.png" alt="任务检查器的“任务计划表”部分。"></p><ol><li><strong>实际</strong>开始和结束日期是任务在项目执行期间真正开始和结束的日期。您可以锁定这些日期以防意外编辑、相关性更改和分级。</li><li><strong>时限</strong>表示任务的最早开始时间和最晚结束时间。选择下面的某个日期字段以将日历图标显示在其右侧；点按该图标可呼出迷你日历，以便选择限制的日期和时间。</li><li><strong>基线</strong>开始和结束日期表示任务根据原始计划应该开始和结束的日期。如果您对项目使用<strong>设置基线</strong>命令，这些日期就会出现。</li><li><strong>差异</strong>显示实际日期与基线日期的差距。此差异会自动计算得出，您不需要亲自输入。</li><li>使用<strong>安排</strong>选择任务是“尽快”还是“尽晚”安排。</li><li>分级时，如果<strong>拆分</strong>允许，任务可划分为多个部分以最大化资源使用效率。否则任务将安排为连续的时间跨度。</li><li>使用<strong>分级</strong>控制项设置任务<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/06_taskview.xhtml#viewoptionsintaskview">优先级</a>；这可确定在分级资源时任务的分配顺序。<em>延迟</em>是分级过程中自动设定的值，标注了在等待资源可用期间任务延迟的时长。</li></ol><p><strong>注意</strong><br>可为个别任务和在<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/11_inspectors.xhtml#editingprojectinformation">项目级别</a>设置 ASAP 和 ALAP 安排。这也称为任务或项目<em>方向</em>设置。</p><p>尽管大多数项目中已定义开始日期的任务都安排为尽快开始，但是当稍后完成它们是有利的时候，个别任务可能受益于 ALAP 安排（例如，某些市场营销工作在开始前可能因某项产品得到尽量充分的开发而受益）。</p><h3 id="说明任务相关性"><a href="#说明任务相关性" class="headerlink" title="说明任务相关性"></a>说明任务相关性</h3><p>使用任务检查器的<strong>相关性</strong>部分可大致了解所选任务与项目中其他任务的关系，并可快速更改或移除相关性。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_23_taskinspectordependencies.png" alt="使用任务检查器检查相关性。"></p><p><strong>必要条件</strong>部分列出了必须先完成它们才能开始所选任务的任务，而<strong>相关性</strong>部分列出了必须先完成所选任务才能开始的任务。</p><p>使用每个任务行的弹出菜单可更改该任务与所选任务之间的<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/06_taskview.xhtml#typesofdependencies">相关性类型</a>，或点按任务右侧的 X 按钮可完全移除其与所选任务的关系。</p><h3 id="编辑资源分配"><a href="#编辑资源分配" class="headerlink" title="编辑资源分配"></a>编辑资源分配</h3><p>使用任务检查器的<strong>分配</strong>部分，可查看分配给任务的资源，更改资源贡献的投入量，从任务中移除现有资源以及添加新资源。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_24_taskinspectorassignments.png" alt="任务检查器的“分配”部分。"></p><ul><li>连按已分配资源的名称可切换到资源视图，并且资源检查器中已选中该资源。</li><li>连按“X%/X%”字段可将其打开进行编辑，这将更改贡献给所选任务的资源投入百分比。</li><li>点按资源旁边的 X 可移除其任务分配。</li><li>从底部的菜单中选择一个资源可按全部投入将其添加到任务。</li></ul><p><strong>注意</strong><br>如果将属于资源群组的资源分配给任务，其群组也会被分配，不过只是作为信息标记而已；群组没有投入属性，不能使其分配直接移除。当从给定任务中移除所有成员的分配时，以此方式显示的资源群组将消失。</p><h3 id="选择资源的分配方式"><a href="#选择资源的分配方式" class="headerlink" title="选择资源的分配方式"></a>选择资源的分配方式</h3><p>对于资源添加到任务或从任务中移除等任务相关工作，自动重新安排任务的方式取决于任务检查器的此部分中所选的设置。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_31_taskresourceallocation.png" alt="任务检查器的“资源分配”部分。"></p><p>更改资源分配时，可使用下列选项：</p><ul><li><p><strong>调整任务持续时间</strong></p><p>添加新资源会增加可用于完成它们的工作量，此选项使用该工作量缩短完成任务所需的时间量。相反也是如此，从任务中移除资源将增加其持续时间。</p></li><li><p><strong>调整任务工作量</strong></p><p>添加新资源会保持持续时间不变，而增加贡献于完成任务所需的总工作量的工作量 — 这表示将工作倾注于固定的时限内。移除资源表示以原计划的相同时间量完成任务所需的工作量更少。</p></li><li><p><strong>调整已分配的额度</strong></p><p>选中此选项后，无论资源分配情况如何，持续时间<em>和</em>工作量将保持不变。相反，添加新资源后，每个资源要求的工作量会全面地均匀减少（一个资源贡献 100% 的工作量，两个资源各贡献 50%，以此类推）。</p></li></ul><p>还可在此部分选择任务的<strong>会议任务类型</strong>。将任务指定为会议后，只有在其分配到的所有资源均有空时才会安排其时间 — 这对会议特别有用，当然对需要团队同时关注的任何其他任务亦是如此。</p><h2 id="资源检查器"><a href="#资源检查器" class="headerlink" title="资源检查器"></a>资源检查器</h2><p>资源检查器包含有关当前所选资源的信息。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_13_resourceinspectorsummary.png" alt="资源检查器。"></p><ul><li><strong>资源信息</strong> — 有关所选资源的一般信息，例如资源的可用程度和成本。</li><li><strong>资源分配</strong> — 分配此资源的任务列表。</li></ul><h3 id="编辑资源信息"><a href="#编辑资源信息" class="headerlink" title="编辑资源信息"></a>编辑资源信息</h3><p>资源检查器的“资源信息”部分包含有关用于完成项目的人员、设备或原材料的所有重要详细信息。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_25_resourceinspectorinfo.png" alt="资源检查器的“资源信息”部分。"></p><ol><li>资源<strong>名称</strong>与资源大纲中出现的资源名称相同。</li><li>您可以为人员资源分配<strong>电子邮件</strong>地址。如果该资源与“联系人”卡片相关，您可以在弹出菜单中选择要使用的地址。当然，您也总是可以直接输入地址。</li><li>点按<strong>齿轮</strong>按钮，可将此资源与“联系人”卡片相关联，在“联系人”中的卡片或发送电子邮件。</li><li>资源<strong>类型</strong>可以为“人员”、“工具”、“素材”或“群组”。</li><li><strong>单位</strong>值表示资源的可用程度。（对于素材来说，单位值则表示所需的数量。）</li><li><strong>效率</strong>是资源的投入与所花费时间的比率。</li><li><strong>开始</strong>和<strong>结束</strong>日期将确定资源可用的日期。</li><li><strong>每次使用成本</strong>是每次将资源分配给任务所需的金额。</li><li><strong>每小时成本</strong>是分配资源进行每小时投入所需的金额。</li><li><strong>总使用次数</strong>表示将此资源分配给任务的次数。</li><li><strong>总时数</strong>是资源分配给所有任务的投入总和。</li><li><strong>总成本</strong>是此资源全部使用次数和时数的总成本。</li></ol><p><strong>注意</strong><br>如果您在首次尝试使用齿轮菜单时不选择授予 OmniPlan 访问权限以与“通讯录”进行交互，您可以事后使用 Apple 的“系统偏好设置”▸“安全性与隐私”▸“隐私”选项卡向其授予权限。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_32_privacyprefs.png" alt="Apple 的“系统偏好设置”的“安全性与隐私”下的“隐私”选项卡。"></p><h3 id="查看资源分配情况"><a href="#查看资源分配情况" class="headerlink" title="查看资源分配情况"></a>查看资源分配情况</h3><p>使用资源检查器的<strong>分配</strong>部分，可快速查看分配给所有任务的特定资源（或者，如果选择了多个资源，则可查看任务分配的交汇情况）。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_26_resourceinspectorassignments.png" alt="资源检查器的“资源分配”部分。"></p><ul><li>连按已分配任务的名称可切换到任务视图，并且任务检查器中已选中该任务。</li><li>连按“X%/X%”字段可将其打开进行编辑，这将更改贡献给所选任务的资源投入百分比。</li><li>点按任务旁边的 X 按钮可将该任务从资源分配列表中移除。</li></ul><h2 id="样式检查器"><a href="#样式检查器" class="headerlink" title="样式检查器"></a>样式检查器</h2><p>样式检查器是影响当前选择的视觉样式的窗口，并可提供用于快速更改这些样式的工具。当您想编辑特定任务的外观或项目的自定选择时，这是快速为您的项目增添视觉冲击的绝佳方式；或者如果有地方看起来不好，您可以看到是哪些样式影响了效果，然后点按鼠标即可恢复秩序。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_12_styleinspectorsummary.png" alt="样式检查器。"></p><ul><li><strong>项目样式</strong> — 用于快速自定所选任务或资源的样式或者将已命名样式分配给所选任务或资源的工具。</li><li><strong>样式属性</strong> — 当前应用到所选项目及其来源的样式列表。</li></ul><p>如果您要设置整个项目的视觉主题，在<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/10_stylesview.xhtml">样式视图</a>中操作时，样式检查器还可用作编辑器。</p><h3 id="应用项目样式"><a href="#应用项目样式" class="headerlink" title="应用项目样式"></a>应用项目样式</h3><p>您将使用<a href="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/xhtml/10_stylesview.xhtml">样式视图</a>将样式应用到整个项目的各类项目，但是如果您想将特殊的已命名样式应用到个别项目，将其选中并从此处的下拉菜单中选择样式。如果稍后更改该样式，这些更改将更新您项目中所有样式的使用。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_27_styleinspectoritemstyle.png" alt="样式检查器中的项目样式。"></p><p>如果您只想将样式应用到某个项目，而不需要任何特殊的逻辑或更新，可以使用“项目样式”中的其他控制项来应用特殊样式。</p><ol><li>在主窗口中，选择要设置样式的项目或部分备注。</li><li>使用样式检查器“项目样式”部分中的控制项来设计所选项目的样式。</li></ol><p><strong>注意</strong><br>特殊样式优先于任何其他类型的样式。如果应用到项目的样式包括特殊样式，则特殊样式优先于任何已命名样式或结构化样式。</p><h3 id="查看样式属性"><a href="#查看样式属性" class="headerlink" title="查看样式属性"></a>查看样式属性</h3><p>样式检查器的“样式属性”部分显示有关应用到当前选择的任何自定文本样式的信息，并允许复制（将检查器中的样式票拖放至当前视图中的项目）和移除（点按检查器中样式右侧的 X 按钮）样式。它还指示样式是应用到某类项目（如任务群组）还是个别项目，并相应地应用更改。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_28_styleinspectorattributes.png" alt="样式检查器中的属性。"></p><h2 id="自定数据检查器"><a href="#自定数据检查器" class="headerlink" title="自定数据检查器"></a>自定数据检查器</h2><p>使用自定数据检查器保留您自己的项目信息，或单个任务和资源的信息。选择一个任务或资源以在此处向其添加自定数据；在未选择任何任务或资源的情况下添加自定数据将会把数据添加至整个项目。</p><p>自定数据会存储为键/值对。“键”类似于标签，标示您正存储的信息类型，“值”就是信息本身。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_07_customdatainspector.png" alt="使用自定数据检查器将自定数据添加至资源。"></p><p>例如，以下是您应如何记录人员的电话号码：</p><ul><li>在资源大纲中选择人员资源，并打开“自定数据”检查器。</li><li>然后点按检查器底部的加号按钮，创建新的键/值对。</li><li>将键命名为“电话号码”。</li><li>输入号码，作为所选资源的值。</li></ul><p>创建此资源的键之后，其他每个资源就都具有相同的键，您可以输入值。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_09_customdatacolumns.png" alt="将自定数据显示为资源大纲中的栏。"></p><p>您可以通过选择“显示”▸“显示选项”(<strong>Command-J</strong>)，将自定数据显示为任务和资源大纲中的栏，或者显示为甘特图和资源时间线中的标签。</p><h2 id="附件检查器"><a href="#附件检查器" class="headerlink" title="附件检查器"></a>附件检查器</h2><p>使用附件检查器，参考与项目或其中特定项目相关的文件。选择一个任务或资源以向其添加附件；在未选择任何任务或资源的情况下添加附件将会把附件添加至整个项目。</p><p><img src="https://support.omnigroup.com/doc-assets/OmniPlan-Mac/OmniPlan-Mac-v3.0.0.1/zh/EPUB/art/op3mac_ch11_08_attachmentsinspector.png" alt="使用资源附件检查器将文件附加至资源。"></p><p>要将文件链接到任务大纲或资源大纲中的项目：</p><ol><li>点按项目以进行选取。</li><li>在“附件”检查器中，点按附件清单下面的加号按钮，然后从出现的对话框中选择一个文件。如果您正在显示大纲中的附件栏，则还可以点按箭头图标，并从弹出菜单中选择“附加文件”，然后选择一个文件。或者使用最简单的方法，将文件拖移到附件清单中即可。</li><li>文件会出现在检查器的附件清单中。</li></ol><p>要附加文件到项目本身：</p><ol><li>确保主视图中没有选择任何对象。</li><li>在“附件”检查器中，点按附件清单下面的加号按钮，然后从出现的对话框中选择一个文件。或者，将文件拖移到附件清单中即可。</li><li>文件会出现在检查器的附件清单中。</li></ol><p>您可以在附件检查器中选择已附加的文件，然后点按“打开”按钮，或者从大纲项目行附件栏的弹出菜单中选择已附加的文件，来打开文件。</p><p><strong>警告</strong></p><blockquote><p><em>每个文件附件都是对磁盘中其他位置文件的参考。</em>如果您四处移动文件，则参考会尝试追踪新位置。但是如果您打算将项目发送给其他人，或者要将项目移动到另一台电脑，则其他文件不会自动跟随以供参考。在这种情况下，您应该将所有已附加的文件收集到一个文件夹中，附加到 OmniPlan 文件本身，并发送整个文件夹。</p></blockquote><p>您可以通过选择“显示”▸“显示选项”(<strong>Command-J</strong>)，或二次点按大纲栏标头并选择关联菜单中的附件，将附件显示为任务和资源大纲中的栏。</p>]]></content>
      
      
      <categories>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>禅道的数据库结构</title>
      <link href="/2022/06/02/shan-dao-de-shu-ju-ku-jie-gou/"/>
      <url>/2022/06/02/shan-dao-de-shu-ju-ku-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="禅道的数据库结构"><a href="#禅道的数据库结构" class="headerlink" title="禅道的数据库结构"></a>禅道的数据库结构</h2><blockquote><p>官网相关地址：<a href="https://www.zentao.net/book/zentaopmshelp/157.html?fullScreen=zentao">https://www.zentao.net/book/zentaopmshelp/157.html?fullScreen=zentao</a></p></blockquote><p>禅道的数据库命名都比较简明扼要，从字面意思应该都可以猜出来表的用途。如果还不是很清楚的话，可以到每个表对应的模块下面的语言文件里面查找。</p><p>最新版本可以在 禅道 <strong>后台—-二次开发—-数据库</strong> 中查看相应的表介绍。</p><h4 id="一、我的地盘相关的表"><a href="#一、我的地盘相关的表" class="headerlink" title="一、我的地盘相关的表"></a>一、我的地盘相关的表</h4><ul><li>zt_todo，待办事宜表。</li></ul><h4 id="二、产品相关的表"><a href="#二、产品相关的表" class="headerlink" title="二、产品相关的表"></a>二、产品相关的表</h4><ul><li>zt_product，记录了产品相关的信息。</li><li>zt_productplan，记录了产品的计划信息。</li><li>zt_story，是非常重要的一张表，记录了系统中所有的需求记录。</li><li>zt_storyspec，记录了需求的描述信息。</li><li>zt_storystage，记录需求的阶段信息。</li><li>zt_release，记录了产品的发布信息。这张表同时也和zt_build互相关联。</li><li>zt_branch，记录产品的分支和平台信息。</li></ul><h4 id="三、项目相关的表"><a href="#三、项目相关的表" class="headerlink" title="三、项目相关的表"></a>三、项目相关的表</h4><ul><li>zt_project，项目表。</li><li>zt_projectproduct，记录了项目和产品之间的关联关系。</li><li>zt_projectstory，记录了项目中需要做的需求列表。</li><li>zt_task，任务表。</li><li>zt_burn，燃尽图数据表。燃尽图就是根据这张表的数据画出来的。</li><li>zt_team，记录了项目中的团队成员。</li><li>zt_build，记录了项目中产品的版本列表。</li><li>zt_taskestimate，项目任务工时表。</li></ul><h4 id="四、测试相关的表"><a href="#四、测试相关的表" class="headerlink" title="四、测试相关的表"></a>四、测试相关的表</h4><ul><li>zt_bug，bug表，也是大家非常熟悉的一张表了。</li><li>zt_case，用例表。记录了所有的测试用例。</li><li>zt_casestep，则是记录了用例相关的步骤，包括历史。</li><li>zt_testtask，测试版本表，记录了历次的测试任务。</li><li>zt_testrun，则记录了每个测试任务所对应的用例执行情况。</li><li>zt_testresult，记录了每个用例历次执行的结果。</li><li>zt_testsuite，测试套件表。</li><li>zt_suitecase，套件用例表。</li><li>zt_testreport，测试报告表。</li></ul><h4 id="五、文档库相关的表"><a href="#五、文档库相关的表" class="headerlink" title="五、文档库相关的表"></a>五、文档库相关的表</h4><ul><li>zt_doclib，记录了自定义文档库列表。</li><li>zt_doc，则记录了所有的文档。</li><li>zt_doccontent，文档的内容表。</li></ul><h4 id="六、组织管理相关的表"><a href="#六、组织管理相关的表" class="headerlink" title="六、组织管理相关的表"></a>六、组织管理相关的表</h4><ul><li>zt_user，用户表。</li><li>zt_group，分组表。</li><li>zt_usergroup，用户和分组之间的对应关系。</li><li>zt_grouppriv，分组的权限。</li><li>zt_dept，部门结构表。</li><li>zt_userquery，用户自定义查询表。</li><li>zt_usertpl，用户的自定义模板表。</li><li>zt_usercontact，用户联系人表。</li><li>zt_company，这张表记录了当前公司的信息，也是顶级的一张表。</li></ul><h4 id="七、后台管理相关的表"><a href="#七、后台管理相关的表" class="headerlink" title="七、后台管理相关的表"></a>七、后台管理相关的表</h4><ul><li>zt_action，系统日志表。</li><li>zt_cron，定时任务表，记录计划任务。</li><li>zt_extension，插件表。</li><li>zt_history，操作历史表， 记录对任何一个对象的所有修改记录， 前后值的变化。</li><li>zt_lang，语言定义表。</li></ul><h4 id="八、其他模块相关的表"><a href="#八、其他模块相关的表" class="headerlink" title="八、其他模块相关的表"></a>八、其他模块相关的表</h4><ul><li>zt_module，也是非常重要的一张表，它维护了禅道系统中的模块划分数据，比如需求的模块划分。</li><li>zt_effort，日志表。</li><li>zt_entry，应用表。</li><li>zt_log，接口日志表。</li><li>zt_mailqueue，邮件列队表。</li><li>zt_module，模块表，记录模块信息。</li><li>zt_notify，提醒信息表，记录所有的提醒信息。</li><li>zt_score，积分表，记录积分信息。</li><li>zt_file，附件表。记录了所有的附件。</li><li>zt_block，区块表，记录我的地盘首页，产品主页，项目主页，测试主页的区块信息。</li><li>zt_config，系统配置表，记录所有的基本配置信息。</li><li>zt_webhook，记录webhook信息。</li><li>zt_webhookdatas，记录webhook的数据表。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 禅道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学-开区间和闭区间</title>
      <link href="/2022/05/28/shu-xue-kai-qu-jian-he-bi-qu-jian/"/>
      <url>/2022/05/28/shu-xue-kai-qu-jian-he-bi-qu-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://blog.csdn.net/qq_44309181/article/details/111311557">https://blog.csdn.net/qq_44309181/article/details/111311557</a>]</p></blockquote><p>开区间使用符号小括号<code>()</code>表示，闭区间使用符号中括号<code>[]</code>表示，闭区间包含了两个端点，而开区间则不包含两个端点 </p><p>开区间用 (a,b)来表示，闭区间用 [a,b]来表示。闭区间 包括了两个端点a和b，而开区间 不包含两个端点a和b。<br>    下面这个游戏是我以前的老师告诉我的。游戏的规则是：两个人分别在开区间（a,b）内取一个数，两个人取的数不许相同，谁取的数大，那么谁赢。这个 游戏显然是 谁先取谁输！具体一点，假设是在(0,1)这个区间来玩这个游戏。第一个人取的是0.9另一个只要取0.91就可以赢了；如果第一个人取的是 0.99另一个只要取0.991就行了。总之，不管第一个人怎么取，都会落败。如果这个游戏换在闭区间[0,1]上进行，结果完全颠倒了， 谁先取谁赢，因第一个人只要取1就可以了，第二个人因为不能取到这个数，那就输定了。</p><p>1）满足a≤x≤b的实数x的集合,<br>表示为[a,b],叫做闭区间;</p><p>2）满足a＜x＜b的实数x的集合,<br>表示为(a,b),叫做开区间;</p><p>3）满足a≤x＜b，a＜x≤b的实数x的集合,<br>分别表示为[a,b),(a,b],叫做半开区间.</p><p>这里实数a,b叫做区间的端点.<br>从上边的三个定义你就可以看出来，闭区间是有a,b两个端点的。</p><p>示例：</p><p>一共四种情况：</p><pre class="line-numbers language-none"><code class="language-none">(a,b)：区间范围内，不包含a和b[a,b]：区间范围内，包含a，也包含b(a,b]：区间范围内，不包含a，包含b[a,b)：区间范围内，包含a，不包含b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通常我们在程序中常听到的概念是左闭右开，也就是含左不含右，最常用的就是java中的字符串的截取方法sbuString，它采取的就是左闭右开策略</p>]]></content>
      
      
      <categories>
          
          <category> 数学目录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开闭区间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索算法</title>
      <link href="/2022/05/28/er-fen-sou-suo-suan-fa/"/>
      <url>/2022/05/28/er-fen-sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://labuladong.gitee.io/algo/1/10/">https://labuladong.gitee.io/algo/1/10/</a>]</p></blockquote><h3 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">int binarySearch(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; ...;    while(...) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target) &#123;            ...        &#125; else if (nums[mid] &lt; target) &#123;            left &#x3D; ...        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; ...        &#125;    &#125;    return ...;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节</strong>。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。</p><p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p><strong>另外提前说明一下，计算 <code>mid</code> 时需要防止溢出</strong>，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int binarySearch(int[] nums, int target) &#123;    int left &#x3D; 0;     int right &#x3D; nums.length - 1; &#x2F;&#x2F; 注意    while(left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if(nums[mid] &#x3D;&#x3D; target)            return mid;         else if (nums[mid] &lt; target)            left &#x3D; mid + 1; &#x2F;&#x2F; 注意        else if (nums[mid] &gt; target)            right &#x3D; mid - 1; &#x2F;&#x2F; 注意    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码可以解决力扣第 704 题「 <a href="https://leetcode.cn/problems/binary-search/">二分查找</a>」，但我们深入探讨一下其中的细节。</p><p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;</strong>？</p><p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(nums[mid] &#x3D;&#x3D; target)    return mid; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[right, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p><p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;...while(left &lt; right) &#123;    &#x2F;&#x2F; ...&#125;return nums[left] &#x3D;&#x3D; target ? left : -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断</strong>？</p><p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p><p>当然是去搜索区间 <code>[left, mid-1]</code> 或者区间 <code>[mid+1, right]</code> 对不对？<strong>因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除</strong>。</p><p><strong>3、此算法有什么缺陷</strong>？</p><p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p><p>这样的需求很常见，<strong>你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p><p>我们后续的算法就来讨论这两种二分查找的算法。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>以下是最常见的代码形式，其中的标记是需要注意的细节：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int left_bound(int[] nums, int target) &#123;    if (nums.length &#x3D;&#x3D; 0) return -1;    int left &#x3D; 0;    int right &#x3D; nums.length; &#x2F;&#x2F; 注意        while (left &lt; right) &#123; &#x2F;&#x2F; 注意        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target) &#123;            right &#x3D; mid;        &#125; else if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid; &#x2F;&#x2F; 注意        &#125;    &#125;    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1、为什么 while 中是 <code>&lt;</code> 而不是 <code>&lt;=</code></strong>?</p><p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code>。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p><p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p><blockquote><p>PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：<strong>刚才的 <code>right</code> 不是 <code>nums.length - 1</code>吗，为啥这里非要写成 <code>nums.length</code> 使得「搜索区间」变成左闭右开呢</strong>？</p><p>因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。</p></blockquote><p><strong>2、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p><p><a href="https://labuladong.gitee.io/algo/images/二分查找/1.jpg"><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be/1.jpg" alt="img"></a></p><p>对于这个数组，算法会返回索引 1。</p><p>这个索引 1 的含义可以解读为「<code>nums</code> 中小于 2 的元素有 1 个」。</p><p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 0，含义是：<code>nums</code> 中小于 1 的元素有 0 个。</p><p>再比如说 <code>nums = [2,3,5,7], target = 8</code>，算法会返回 4，含义是：<code>nums</code> 中小于 8 的元素有 4 个。</p><blockquote><p>PS：对于 <code>target</code> 不存在 <code>nums</code> 中的情况，函数的返回值还可以有多种理解方式，详见 <a href="https://labuladong.gitee.io/algo/2/18/27/">随机权重算法</a> 中对二分搜索的运用。</p></blockquote><p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 <code>[0, nums.length]</code>，所以我们简单添加两行代码就能在正确的时候 return -1：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while (left &lt; right) &#123;    &#x2F;&#x2F;...&#125;&#x2F;&#x2F; target 比所有数都大if (left &#x3D;&#x3D; nums.length) return -1;&#x2F;&#x2F; 类似之前算法的处理方式return nums[left] &#x3D;&#x3D; target ? left : -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样</strong>？</p><p>答：这个很好解释，因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步应该去 <code>mid</code> 的左侧或者右侧区间搜索，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。</p><p><strong>4、为什么该算法能够搜索左侧边界</strong>？</p><p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (nums[mid] &#x3D;&#x3D; target)    right &#x3D; mid;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 <code>[left, mid)</code> 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p><strong>5、为什么返回 <code>left</code> 而不是 <code>right</code></strong>？</p><p>答：都是一样的，因为 while 终止的条件是 <code>left == right</code>。</p><p><strong>6、能不能想办法把 <code>right</code> 变成 <code>nums.length - 1</code>，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了</strong>。</p><p>答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：</p><p>因为你非要让搜索区间两端都闭，所以 <code>right</code> 应该初始化为 <code>nums.length - 1</code>，while 的终止条件应该是 <code>left == right + 1</code>，也就是其中应该用 <code>&lt;=</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int left_bound(int[] nums, int target) &#123;    &#x2F;&#x2F; 搜索区间为 [left, right]    int left &#x3D; 0, right &#x3D; nums.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        &#x2F;&#x2F; if else ...    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 <code>left</code> 和 <code>right</code> 的更新逻辑如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (nums[mid] &lt; target) &#123;    &#x2F;&#x2F; 搜索区间变为 [mid+1, right]    left &#x3D; mid + 1;&#125; else if (nums[mid] &gt; target) &#123;    &#x2F;&#x2F; 搜索区间变为 [left, mid-1]    right &#x3D; mid - 1;&#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;    &#x2F;&#x2F; 收缩右侧边界    right &#x3D; mid - 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于 while 的退出条件是 <code>left == right + 1</code>，所以当 <code>target</code> 比 <code>nums</code> 中所有元素都大时，会存在以下情况使得索引越界：</p><p><a href="https://labuladong.gitee.io/algo/images/二分查找/2.jpg"><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be/2.jpg" alt="img"></a></p><p>因此，最后返回结果的代码应该检查越界情况：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target)    return -1;return left;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>至此，整个算法就写完了，完整代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int left_bound(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; nums.length - 1;    &#x2F;&#x2F; 搜索区间为 [left, right]    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; target) &#123;            &#x2F;&#x2F; 搜索区间变为 [mid+1, right]            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            &#x2F;&#x2F; 搜索区间变为 [left, mid-1]            right &#x3D; mid - 1;        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 收缩右侧边界            right &#x3D; mid - 1;        &#125;    &#125;    &#x2F;&#x2F; 检查出界情况    if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target) &#123;        return -1;    &#125;    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 <code>left</code> 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int right_bound(int[] nums, int target) &#123;    if (nums.length &#x3D;&#x3D; 0) return -1;    int left &#x3D; 0, right &#x3D; nums.length;        while (left &lt; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &#x3D;&#x3D; target) &#123;            left &#x3D; mid + 1; &#x2F;&#x2F; 注意        &#125; else if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid;        &#125;    &#125;    return left - 1; &#x2F;&#x2F; 注意&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1、为什么这个算法能够找到右侧边界</strong>？</p><p>答：类似地，关键点还是这里：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (nums[mid] &#x3D;&#x3D; target) &#123;    left &#x3D; mid + 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的左边界 <code>left</code>，使得区间不断向右靠拢，达到锁定右侧边界的目的。</p><p><strong>2、为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code>才对</strong>。</p><p>答：首先，while 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code>好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在锁定右边界时的这个条件判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 增大 left，锁定右侧边界if (nums[mid] &#x3D;&#x3D; target) &#123;    left &#x3D; mid + 1;    &#x2F;&#x2F; 这样想: mid &#x3D; left - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://labuladong.gitee.io/algo/images/二分查找/3.jpg"><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be/3.jpg" alt="img"></a></p><p>因为我们对 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，就是说 while 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p><p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，当然是为了锁定右侧边界，就不再赘述。</p><p><strong>3、为什么没有返回 -1 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办</strong>？</p><p>答：类似之前的左侧边界搜索，因为 while 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 <code>[0, nums.length]</code>，所以可以添加两行代码，正确地返回 -1：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">while (left &lt; right) &#123;    &#x2F;&#x2F; ...&#125;if (left &#x3D;&#x3D; 0) return -1;return nums[left-1] &#x3D;&#x3D; target ? (left-1) : -1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了</strong>。</p><p>答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int right_bound(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; nums.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid - 1;        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 这里改成收缩左侧边界即可            left &#x3D; mid + 1;        &#125;    &#125;    &#x2F;&#x2F; 这里改为检查 right 越界的情况，见下图    if (right &lt; 0 || nums[right] !&#x3D; target) &#123;        return -1;    &#125;    return right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当 <code>target</code> 比所有元素都小时，<code>right</code> 会被减到 -1，所以需要在最后防止越界：</p><p><a href="https://labuladong.gitee.io/algo/images/二分查找/4.jpg"><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be/4.jpg" alt="img"></a></p><p>至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？</p><h3 id="四、逻辑统一"><a href="#四、逻辑统一" class="headerlink" title="四、逻辑统一"></a>四、逻辑统一</h3><p>有了搜索左右边界的二分搜索，你可以去解决力扣第 34 题「 <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a>」，</p><p>接下来梳理一下这些细节差异的因果逻辑：</p><p><strong>第一个，最基本的二分查找算法</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">因为我们初始化 right &#x3D; nums.length - 1所以决定了我们的「搜索区间」是 [left, right]所以决定了 while (left &lt;&#x3D; right)同时也决定了 left &#x3D; mid+1 和 right &#x3D; mid-1因为我们只需找到一个 target 的索引即可所以当 nums[mid] &#x3D;&#x3D; target 时可以立即返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二个，寻找左侧边界的二分查找</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">因为我们初始化 right &#x3D; nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left &#x3D; mid + 1 和 right &#x3D; mid因为我们需找到 target 的最左侧索引所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回而要收紧右侧边界以锁定左侧边界<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第三个，寻找右侧边界的二分查找</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">因为我们初始化 right &#x3D; nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left &#x3D; mid + 1 和 right &#x3D; mid因为我们需找到 target 的最右侧索引所以当 nums[mid] &#x3D;&#x3D; target 时不要立即返回而要收紧左侧边界以锁定右侧边界又因为收紧左侧边界时必须 left &#x3D; mid + 1所以最后无论返回 left 还是 right，必须减一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，<strong>我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int binary_search(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; nums.length - 1;     while(left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid - 1;         &#125; else if(nums[mid] &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 直接返回            return mid;        &#125;    &#125;    &#x2F;&#x2F; 直接返回    return -1;&#125;int left_bound(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; nums.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid - 1;        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 别返回，锁定左侧边界            right &#x3D; mid - 1;        &#125;    &#125;    &#x2F;&#x2F; 最后要检查 left 越界的情况    if (left &gt;&#x3D; nums.length || nums[left] !&#x3D; target) &#123;        return -1;    &#125;    return left;&#125;int right_bound(int[] nums, int target) &#123;    int left &#x3D; 0, right &#x3D; nums.length - 1;    while (left &lt;&#x3D; right) &#123;        int mid &#x3D; left + (right - left) &#x2F; 2;        if (nums[mid] &lt; target) &#123;            left &#x3D; mid + 1;        &#125; else if (nums[mid] &gt; target) &#123;            right &#x3D; mid - 1;        &#125; else if (nums[mid] &#x3D;&#x3D; target) &#123;            &#x2F;&#x2F; 别返回，锁定右侧边界            left &#x3D; mid + 1;        &#125;    &#125;    &#x2F;&#x2F; 最后要检查 right 越界的情况    if (right &lt; 0 || nums[right] !&#x3D; target) &#123;        return -1;    &#125;    return right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><p>1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。</p><p>2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 <code>nums[mid] == target</code> 时做修改即可，搜索右侧时需要减一。</p><p>4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 <code>nums[mid] == target</code> 条件处的代码和返回的逻辑即可，</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netdata—NAS性能监控工具</title>
      <link href="/2022/05/28/netdata-nas-xing-neng-jian-kong-gong-ju/"/>
      <url>/2022/05/28/netdata-nas-xing-neng-jian-kong-gong-ju/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网地址[<a href="https://learn.netdata.cloud/docs/get-started#install-on-linux-with-one-line-installer">https://learn.netdata.cloud/docs/get-started#install-on-linux-with-one-line-installer</a>]<br>内网访问地址,各位看官就不要试了[<a href="http://192.168.0.192:19999/">http://192.168.0.192:19999/</a>]</p></blockquote><h2 id="使用单行安装程序在-Linux-上安装"><a href="#使用单行安装程序在-Linux-上安装" class="headerlink" title="使用单行安装程序在 Linux 上安装"></a>使用单行安装程序在 Linux 上<a href="https://learn.netdata.cloud/docs/get-started#install-on-linux-with-one-line-installer">安装</a></h2><p>在 Linux 节点（物理、虚拟、容器、物联网）上安装 Netdata的<strong>推荐</strong>方法是我们的单行 <a href="https://learn.netdata.cloud/docs/agent/packaging/installer/methods/kickstart">kickstart 脚本</a>。此脚本自动安装依赖项并从其源代码构建 Netdata。</p><p>复制脚本，将其粘贴到节点的终端中，然后点击<code>Enter</code>开始安装过程。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">wget -O /tmp/netdata-kickstart.sh https://my-netdata.io/kickstart.sh &amp;&amp; sh /tmp/netdata-kickstart.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你想要自动更新吗？<code>default: enabled</code></p><p>您想要夜间版本还是稳定版本？<code>default: nightly</code></p><p>您想提供<a href="https://learn.netdata.cloud/docs/agent/anonymous-statistics">匿名统计数据吗？</a> <code>default: enabled</code></p><h2 id="启动、停止或重新启动-Netdata-代理"><a href="#启动、停止或重新启动-Netdata-代理" class="headerlink" title="启动、停止或重新启动 Netdata 代理"></a>启动、停止或重新启动 Netdata 代理</h2><p>安装 Netdata 代理时，<a href="https://learn.netdata.cloud/docs/agent/daemon">守护程序</a>配置为在引导时启动、停止和重新启动/关闭。</p><p>您通常需要<em>重新启动</em>代理以加载新的或正在编辑的配置文件。<a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#reload-health-configuration">健康配置</a>文件是唯一的例外，因为它们可以在不重新启动整个代理的情况下重新加载。</p><p><code>netdata</code>在进程启动收集器和数据库引擎之前，停止或重新启动 Netdata 代理将导致存储的指标出现间隙。</p><h2 id="使用systemctl-service-init-d或"><a href="#使用systemctl-service-init-d或" class="headerlink" title="使用systemctl, service,init.d或"></a>使用<code>systemctl</code>, <code>service</code>,<code>init.d</code><a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#using-systemctl-service-or-initd">或</a></h2><p>这是启动、停止或重新启动 Netdata 守护程序的推荐方法。</p><ul><li>要<strong>启动</strong>Netdata，请运行<code>sudo systemctl start netdata</code>.</li><li>要<strong>停止</strong>Netdata，请运行<code>sudo systemctl stop netdata</code>.</li><li>要<strong>重新启动</strong>Netdata，请运行<code>sudo systemctl restart netdata</code>.</li></ul><p>如果上述命令失败，或者您知道您使用的是非 systemd 系统，请尝试使用以下<code>service</code>命令：</p><ul><li><strong>服务</strong>：<code>sudo service netdata start</code>，，，<code>sudo service netdata stop</code>_<code>sudo service netdata restart</code></li></ul><h2 id="使用netdata"><a href="#使用netdata" class="headerlink" title="使用netdata"></a><a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#using-netdata">使用</a><code>netdata</code></h2><p>使用该<code>netdata</code>命令（通常位于<code>/usr/sbin/netdata</code>）启动 Netdata 守护程序。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo netdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果您以这种方式启动守护程序，请使用<code>sudo killall netdata</code>.</p><h2 id="使用netdatacli"><a href="#使用netdatacli" class="headerlink" title="使用netdatacli"></a><a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#using-netdatacli">使用</a><code>netdatacli</code></h2><p>Netdata 代理还附带一个能够执行关闭的<a href="https://learn.netdata.cloud/docs/agent/cli">CLI 工具。</a>使用上面列出的首选方法启动代理备份。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo netdatacli shutdown-agent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重新加载健康配置"><a href="#重新加载健康配置" class="headerlink" title="重新加载健康配置"></a>重新加载健康<a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#reload-health-configuration">配置</a></h2><p>您无需在更改健康配置文件（例如特定健康实体）之间重新启动 Netdata 代理。相反，使用<a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#using-netdatacli"><code>netdatacli</code></a>和<code>reload-health</code>选项来防止度量收集中的空白。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo netdatacli reload-health<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果<code>netdatacli</code>在您的系统上不起作用，请向守护程序发送<code>SIGUSR2</code>信号，该守护程序会重新加载运行状况配置，而无需重新启动整个过程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">killall -USR2 netdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="强制停止停滞或无响应的进程netdata"><a href="#强制停止停滞或无响应的进程netdata" class="headerlink" title="强制停止停滞或无响应的进程netdata"></a>强制停止停滞或无响应的<a href="https://learn.netdata.cloud/docs/configure/start-stop-restart#force-stop-stalled-or-unresponsive-netdata-processes">进程</a><code>netdata</code></h2><p>在极少数情况下，Netdata 代理可能会停止或无法正确关闭套接字，从而阻止新进程启动。在这些情况下，请尝试以下三个命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl stop netdatasudo killall netdataps aux| grep netdata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>的输出<code>ps aux</code>应该显示没有<code>netdata</code>或关联的进程正在运行。您现在可以使用<code>service netdata start</code>或适合您系统的方法再次启动 Netdata 代理。</p>]]></content>
      
      
      <categories>
          
          <category> 系统监控 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主机异常重启排查</title>
      <link href="/2022/05/26/zhu-ji-yi-chang-chong-qi-pai-cha/"/>
      <url>/2022/05/26/zhu-ji-yi-chang-chong-qi-pai-cha/</url>
      
        <content type="html"><![CDATA[<h3 id="排查资源使用情况："><a href="#排查资源使用情况：" class="headerlink" title="排查资源使用情况："></a>排查资源使用情况：</h3><p>一般云计算平台或者传统的 IDC 主机都会有相应的监控平台</p><p>通过分析历史的 CPU 、MEM、磁盘 IO、带宽大小等数值分析是不是因为资源占用异常导致的系统重启</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9bdff0e5-b108-4c0e-acf6-e32a530a6405%2FUntitled.png?table=block&amp;id=2c2847ae-7f32-4b91-ada5-72f36160a668&amp;spaceId=60e00767-57f7-487f-ba8b-b4272c0929a9&amp;width=1440&amp;userId=&amp;cache=v2" alt="img"></p><p>或者登录机器</p><ul><li>通过 free 命令查看内存信息</li></ul><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">$free                           total        used        free      shared  buff&#x2F;cache   available Mem:        3880172      187996     1974484         544     1717692     3407556 Swap:             0           0           0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>top 命令查看占用较高内存 CPU 的进程有无异常</li></ul><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">$top - 18:17:43 up 26 days,  7:19,  1 user,  load average: 0.00, 0.01, 0.05 Tasks:  94 total,   1 running,  93 sleeping,   0 stopped,   0 zombie %Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st KiB Mem :  3880172 total,  1973048 free,   189016 used,  1718108 buff&#x2F;cache KiB Swap:        0 total,        0 free,        0 used.  3406504 avail Mem   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    1 root      20   0   43576   3964   2580 S   0.0  0.1   1:26.70 systemd    2 root      20   0       0      0      0 S   0.0  0.0   0:00.68 kthreadd    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker&#x2F;0:0H    6 root      20   0       0      0      0 S   0.0  0.0   0:04.58 ksoftirqd&#x2F;0    7 root      rt   0       0      0      0 S   0.0  0.0   0:07.54 migration&#x2F;0    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh    9 root      20   0       0      0      0 S   0.0  0.0   2:26.47 rcu_sched   10 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 lru-add-drain   11 root      rt   0       0      0      0 S   0.0  0.0   0:06.27 watchdog&#x2F;0   12 root      rt   0       0      0      0 S   0.0  0.0   0:05.24 watchdog&#x2F;1   13 root      rt   0       0      0      0 S   0.0  0.0   0:07.68 migration&#x2F;1   14 root      20   0       0      0      0 S   0.0  0.0   0:04.44 ksoftirqd&#x2F;1   16 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker&#x2F;1:0H   18 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kdevtmpfs   19 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 netns   20 root      20   0       0      0      0 S   0.0  0.0   0:00.48 khungtaskd   21 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 writeback   22 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kintegrityd   23 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset   24 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset   25 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 bioset   26 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kblockd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 <strong>netstat -ant | awk ‘{split($5, arr, “:”); print arr[1]}’ | sort | uniq -c |sort -nr | head</strong> 命令查看建立连接数</li></ul><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">$netstat -ant | awk &#39;&#123;split($5, arr, &quot;:&quot;); print arr[1]&#125;&#39; | sort | uniq -c |sort -nr | head      12 0.0.0.0      10 58.33.27.210      7 180.164.153.113      1 169.254.0.55<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 iostat vmstat 或 lsof 查看系统盘的 IO 情况， 找到异常读写的进程</p><h3 id="通过-linux-系统日志排查"><a href="#通过-linux-系统日志排查" class="headerlink" title="通过 linux 系统日志排查"></a>通过 linux 系统日志排查</h3><p> 系统日志通常在 /var/log 下：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">&#x2F;var&#x2F;log&#x2F;message 记录Linux操作系统常见的系统和服务错误信息 &#x2F;var&#x2F;log&#x2F;secure 与安全相关的日志信息 &#x2F;var&#x2F;log&#x2F;maillog 与邮件相关的日志信息 &#x2F;var&#x2F;log&#x2F;cron 与定时任务相关的日志信息 &#x2F;var&#x2F;log&#x2F;spooler 与UUCP和news设备相关的日志信息 &#x2F;var&#x2F;log&#x2F;boot.log 守护进程启动和停止相关的日志消息 &#x2F;var&#x2F;log&#x2F;wtmp 永久记录每个用户登录、注销及系统的启动、停机的事件 &#x2F;var&#x2F;run&#x2F;utmp 记录当前正在登录系统的用户信息；&#x2F;var&#x2F;log&#x2F;btmp 记录失败的登录尝试信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通常我们主要分析操作系统日志 <strong>/var/log/message</strong></li></ul><p>执行 <strong>grep -E -i -r “panic|error|exception|shutdown” /var/log/message</strong></p><p>看看得到的信息是否有异常的情况</p><p>例如出现下面类似的日志说明有人通过控制台或者电源键进行了关机</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">Mar 01 23:12:34 hostname shutdown: shutting down for system halt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还可以通过 <strong>grep -iv ‘: starting|kernel: .<em>: Power Button|watching system buttons|Stopped Cleaning Up|Started Crash recovery kernel’ \  /var/log/messages /var/log/syslog /var/log/apcupsd</em> \  | grep -iw ‘recover[a-z]<em>|power[a-z]</em>|shut[a-z ]*down|rsyslogd|ups’</strong>     得到更多相关的日志</p><p>当发生意外断电或者硬件故障的时候，文件系统不会被正常的卸载所以下次主机启动的时候你会看到类似下面的日志：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">EXT4-fs ... INFO: recovery required ...  Starting XFS recovery filesystem ... systemd-fsck: ... recovering journal systemd-journald: File &#x2F;var&#x2F;log&#x2F;journal&#x2F;...&#x2F;system.journal corrupted or uncleanly shut down, renaming and replacing.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当用户通过电源键进行关机时会得到下面类似的日志：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">systemd-logind: Power key pressed. systemd-logind: Powering Off... systemd-logind: System is powering down.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="主机重启历史和登录情况分析"><a href="#主机重启历史和登录情况分析" class="headerlink" title="主机重启历史和登录情况分析"></a>主机重启历史和登录情况分析</h3><p>通过<em> last reboot</em>  查看最近系统重启的信息：第一行个时间是重启时间-8 第二个是当前时间</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 21:56 - 14:40  (-7:-15) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 21:49 - 14:40  (-7:-8) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 21:41 - 14:40  (-7:00) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 21:25 - 14:40  (-6:-44) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 21:15 - 14:40  (-6:-34) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 20:57 - 14:40  (-6:-16) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 20:53 - 14:40  (-6:-13) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 20:49 - 14:40  (-6:-8) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 20:39 - 14:40  (-5:-58) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 18:41 - 14:40  (-4:00) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 17:57 - 14:40  (-3:-16) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 17:23 - 14:40  (-2:-42) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 17:11 - 14:40  (-2:-30) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 16:54 - 14:40  (-2:-13) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 16:27 - 14:40  (-1:-46) reboot   system boot  3.10.0-957.5.1.e Fri Dec  4 15:44 - 14:40  (-1:-3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>last 命令参数说明：</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">-a将登录系统的主机名称或IP地址，显示在最后一行 -d将IP地址转换成主机名称 -f指定记录文件，默认是显示&#x2F;var&#x2F;log目录下的wtmp文件的记录，但&#x2F;var&#x2F;log目录下得btmp能显示的内容更丰富，可以显示远程登录，例如ssh登录 ，包括失败的登录请求。 -i显示特定ip登录的情况。跟踪用 -oRead an old-type wtmp file (written by linux-libc5 applications). -n&lt;显示列数&gt;或-&lt;显示列数&gt; 　设置列出名单的显示列数 -wDisplay full user and domain names in the output -R不显示登入系统的主机名称或IP（省略 hostname 的栏位） -t显示YYYYMMDDHHMMSS之前的信息 -x显示系统关闭、用户登录和退出的历史<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <strong>last -n 5 -a -i</strong> 排查最近异常登录情况, 排除入侵问题</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">root     pts&#x2F;5        Fri Dec  4 14:42   still logged in    58.33.27.210 root     pts&#x2F;3        Fri Dec  4 14:38   still logged in    58.33.27.210 root     pts&#x2F;3        Fri Dec  4 14:23 - 14:23  (00:00)     123.123.6.205 root     pts&#x2F;4        Fri Dec  4 14:12 - 14:43  (00:31)     192.168.0.67 root     pts&#x2F;3        Fri Dec  4 14:08 - 14:20  (00:12)     1.202.240.26<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结合-Kdump-和-crash-工具排查"><a href="#结合-Kdump-和-crash-工具排查" class="headerlink" title="结合 Kdump 和 crash 工具排查"></a>结合 Kdump 和 crash 工具排查</h3><ul><li>Kdump</li></ul><p>kdump是一种kernel crash dump的机制，它可以在内核crash时保存系统的内存信息用于后续的分析。kdump是基于kexec的。</p><p>crash是一个用于交互式地分析正在运行的Linux系统或者kernel crash后的core dump数据的工具。</p><p>dump的工作原理图：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F12213811-6b74-4231-973c-1eab31a4a544%2FUntitled.png?table=block&amp;id=f74ed7cb-08d7-41e1-92f6-e82d93d85f15&amp;spaceId=60e00767-57f7-487f-ba8b-b4272c0929a9&amp;width=2380&amp;userId=&amp;cache=v2" alt="img"></p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F66ac2ba3-6d56-492b-86a0-8804553d3fdf%2FUntitled.png?table=block&amp;id=b93c8475-e7c2-4084-895f-e1a808683263&amp;spaceId=60e00767-57f7-487f-ba8b-b4272c0929a9&amp;width=3390&amp;userId=&amp;cache=v2" alt="img"></p><ul><li>crash</li></ul><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fcrash-utility%2Fcrash">crash</a>是redhat的工程师开发的，主要用来离线分析linux内核转存文件，它整合了gdb工具，功能非常强大。可以查看堆栈，dmesg日志，内核数据结构，反汇编等等。crash支持多种工具生成的转存文件格式，如kdump，LKCD，netdump和diskdump，而且还可以分析虚拟机Xen和Kvm上生成的内核转存文件。同时crash还可以调试运行时系统，直接运行crash即可，ubuntu下内核映象存放在/proc/kcore。</p><p>使用这两个工具来排除异常重启问题必须符合后续还会继续发生异常重启的情况，这个时候我们通过</p><p>kdump 工具保存内核在crash时的系统内存信息用于后续的分析；kdump 默认会在/var/crash/ 目录下保存生成的crash 信息</p><p>通过crash 命令分析 </p><pre class="line-numbers language-none"><code class="language-none">crash &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;modules&#x2F;xxx&#x2F;vmlinux &#x2F;var&#x2F;crash&#x2F;xxx&#x2F;vmcore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 crash 调试转储文件，需要在命令行输入两个参数：debug kernel 和 dump file，其中 dump file 是内核 crash 时生成的 dump 文件的名称，debug kernel 是由内核调试信息包安装的，不同的发行版名称略有不同，以 RHEL为例：</p><p>debug kernel 文件需要额外安装 kernel-debuginfo 才会有</p><p>通常我们使用 yum 进行安装</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">yum install http:&#x2F;&#x2F;debuginfo.centos.org&#x2F;7&#x2F;x86_64&#x2F;kernel-debuginfo-common-x86_64-3.10.0-957.10.1.el7.x86_64.rpm yum install http:&#x2F;&#x2F;debuginfo.centos.org&#x2F;7&#x2F;x86_64&#x2F;kernel-debuginfo-3.10.0-957.10.1.el7.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">$crash &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;modules&#x2F;3.10.0-514.el7.x86_64&#x2F;vmlinux &#x2F;var&#x2F;crash&#x2F;127.0.0.1-2019-07-21-17\:07\:17&#x2F;vmcore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令后可以看到 crash 工具分析报告的摘要</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">crash 7.1.5-2.el7 Copyright (C) 2002-2016  Red Hat, Inc.Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation Copyright (C) 1999-2006  Hewlett-Packard Co Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited Copyright (C) 2006, 2007  VA Linux Systems Japan K.K. Copyright (C) 2005, 2011  NEC Corporation Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc. Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc. This program is free software, covered by the GNU General Public License,and you are welcome to change it and&#x2F;or distribute copies of it under certain conditions.  Enter &quot;help copying&quot; to see the conditions. This program has absolutely no warranty.  Enter &quot;help warranty&quot; for details.  GNU gdb (GDB) 7.6 Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot; and &quot;show warranty&quot; for details. This GDB was configured as &quot;x86_64-unknown-linux-gnu&quot;...       KERNEL: &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;modules&#x2F;3.10.0-514.el7.x86_64&#x2F;vmlinux     DUMPFILE: &#x2F;var&#x2F;crash&#x2F;127.0.0.1-2019-07-21-17:07:17&#x2F;vmcore  [PARTIAL DUMP]         CPUS: 56         DATE: Sun Jul 21 17:07:00 2019       UPTIME: 8 days, 03:43:48  LOAD AVERAGE: 1.98, 1.73, 1.73        TASKS: 4444     NODENAME: hyhive      RELEASE: 3.10.0-514.el7.x86_64      VERSION: #1 SMP Tue Nov 22 16:42:41 UTC 2016      MACHINE: x86_64  (2600 Mhz)       MEMORY: 255.9 GB        PANIC: &quot;BUG: unable to handle kernel paging request at ffff8800fc14dfb0&quot;          PID: 21793      COMMAND: &quot;sh&quot;         TASK: ffff883f97751f60  [THREAD_INFO: ffff8830e1b50000]          CPU: 49        STATE: TASK_RUNNING (PANIC) crash&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 crash 工具内我们可以输入 help 看到所有 crash 的子命令</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">crash&gt; help *              files          mach           repeat         timer           alias          foreach        mod            runq           tree            ascii          fuser          mount          search         union           bt             gdb            net            set            vm              btop           help           p              sig            vtop            dev            ipcs           ps             struct         waitq           dis            irq            pte            swap           whatis          eval           kmem           ptob           sym            wr              exit           list           ptov           sys            q               extend         log            rd             task           crash version: 7.1.9-2   gdb version: 7.6 For help on any command above, enter &quot;help &lt;command&gt;&quot;. For help on input options, enter &quot;help input&quot;. For help on output options, enter &quot;help output&quot;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><p>bt显示内核堆栈跟踪</p><pre class="line-numbers language-Shell" data-language="Shell"><code class="language-Shell">crash&gt; btPID: 3320   TASK: ffff88017092dee0  CPU: 0   COMMAND: &quot;qemu-kvm-2.6&quot; #0 [ffff88007b2aba48] machine_kexec at ffffffff8105c4cb #1 [ffff88007b2abaa8] __crash_kexec at ffffffff81104a32 #2 [ffff88007b2abb78] crash_kexec at ffffffff81104b20 #3 [ffff88007b2abb90] oops_end at ffffffff816880f8 #4 [ffff88007b2abbb8] no_context at ffffffff8167829a #5 [ffff88007b2abc08] __bad_area_nosemaphore at ffffffff81678330 #6 [ffff88007b2abc50] bad_area_nosemaphore at ffffffff8167849a #7 [ffff88007b2abc60] __do_page_fault at ffffffff8168afbe #8 [ffff88007b2abcc0] do_page_fault at ffffffff8168b165 #9 [ffff88007b2abcf0] page_fault at ffffffff81687388​    [exception RIP: unknown or invalid address]​    RIP: 00007ffd81487700  RSP: ffff88007b2abda0  RFLAGS: 00010002​    RAX: ffff880175733e38  RBX: 0000000075733f28  RCX: 0000000000000000​    RDX: 0000000000000000  RSI: 0000000000000003  RDI: ffff880175733e38​    RBP: ffff88007b2abde0   R8: 0000000000000000   R9: 0000000000000000​    R10: 00000000000103c0  R11: 0000000000000293  R12: ffffffff81a93648​    R13: 000055deb2c80ef8  R14: 0000000000000000  R15: 0000000000000003​    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018#10 [ffff88007b2abda0] __wake_up_common at ffffffff810ba588#11 [ffff88007b2abde8] __wake_up at ffffffff810bd4f9#12 [ffff88007b2abe20] __vga_put at ffffffff8143535e#13 [ffff88007b2abe48] vga_put at ffffffff814356ff#14 [ffff88007b2abe70] vfio_pci_vga_rw at ffffffffc04a8e54 [vfio_pci]#15 [ffff88007b2abed0] vfio_pci_rw at ffffffffc04a55c1 [vfio_pci]#16 [ffff88007b2abee0] vfio_pci_read at ffffffffc04a594c [vfio_pci]#17 [ffff88007b2abef0] vfio_device_fops_read at ffffffffc048b233 [vfio]#18 [ffff88007b2abf00] vfs_read at ffffffff81200b9c#19 [ffff88007b2abf30] sys_pread64 at ffffffff81201c32#20 [ffff88007b2abf80] system_call_fastpath at ffffffff8168fe49​    RIP: 00007feac42e1fc3  RSP: 00007feab9b6b908  RFLAGS: 00000206​    RAX: 0000000000000011  RBX: ffffffff8168fe49  RCX: 0000000000000025​    RDX: 0000000000000001  RSI: 00007feab9b6b700  RDI: 000000000000002b​    RBP: 0000000000000001   R8: 0000000000000008   R9: 00000000000000ff​    R10: 00000800000003da  R11: 0000000000000293  R12: 0000000000000000​    R13: 000000000000001a  R14: 0000000000000001  R15: 0000559178fb02b0​    ORIG_RAX: 0000000000000011  CS: 0033  SS: 002b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ps显示系统中进程的状态</p><pre class="line-numbers language-Plain" data-language="Plain"><div class="caption"><span>Text</span></div><code class="language-Plain">crash&gt; ps | grep RU      0      0   0  ffffffff819c9480  RU   0.0       0      0  [swapper&#x2F;0]      0      0   1  ffff880177609fa0  RU   0.0       0      0  [swapper&#x2F;1]&gt;     0      0   2  ffff88017760af70  RU   0.0       0      0  [swapper&#x2F;2]      0      0   3  ffff88017760bf40  RU   0.0       0      0  [swapper&#x2F;3]&gt;  1889   1880   3  ffff8801727b3f40  RU   0.3  386192  21456  X&gt;  3320   3200   0  ffff88017092dee0  RU  47.7 3914004 2986980  qemu-kvm-2.6&gt;  3652   1879   1  ffff880053795ee0  RU   0.0  106640   2640  qemu-imgcrash&gt; ps | grep 3200   2276   1914   0  ffff880063320000  IN   0.0  784512   3096  gmain   3200   1879   1  ffff880174086eb0  IN   0.0   76728   1792  uniqb-runtime   3311   3200   1  ffff88017705cf10  IN  47.7 3914004 2986980  qemu-kvm-2.6   3316   3200   1  ffff88004f888fd0  IN  47.7 3914004 2986980  qemu-kvm-2.6   3319   3200   0  ffff88004f88bf40  IN  47.7 3914004 2986980  qemu-kvm-2.6&gt;  3320   3200   0  ffff88017092dee0  RU  47.7 3914004 2986980  qemu-kvm-2.6   3321   3200   3  ffff88017092af70  IN  47.7 3914004 2986980  qemu-kvm-2.6   3322   3200   1  ffff880170929fa0  IN  47.7 3914004 2986980  qemu-kvm-2.6   3323   3200   0  ffff88017092cf10  IN  47.7 3914004 2986980  qemu-kvm-2.6   3325   3200   3  ffff8800631d2f70  IN  47.7 3914004 2986980  qemu-kvm-2.6   3331   3200   0  ffff8801745daf70  IN  47.7 3914004 2986980  threaded-ml   3333   3200   3  ffff88004f88af70  IN  47.7 3914004 2986980  qemu-kvm-2.6   3334   3200   2  ffff880174082f70  IN  47.7 3914004 2986980  qemu-kvm-2.6   3337   3200   2  ffff880174080fd0  IN  47.7 3914004 2986980  qemu-kvm-2.6   3651   3200   3  ffff880077a30fd0  UN   0.0  142040   1680  sum<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vm显示当前上下文的虚拟内存信息</p><p>通过分析 crash 中的异常进程和堆栈信息可以更进一步发现异常重启的真正原因</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>top命令按内存和cpu排序</title>
      <link href="/2022/05/26/top-ming-ling-an-nei-cun-he-cpu-pai-xu/"/>
      <url>/2022/05/26/top-ming-ling-an-nei-cun-he-cpu-pai-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://www.cnblogs.com/jiqing9006/p/9270504.html">https://www.cnblogs.com/jiqing9006/p/9270504.html</a>]</p></blockquote><h1 id="top命令按内存和cpu排序"><a href="#top命令按内存和cpu排序" class="headerlink" title="top命令按内存和cpu排序"></a>top命令按内存和cpu排序</h1><p>目录</p><ul><li>[按进程的CPU使用率排序]</li><li>[按进程的内存使用率排序]</li></ul><h3 id="按进程的CPU使用率排序"><a href="#按进程的CPU使用率排序" class="headerlink" title="按进程的CPU使用率排序"></a>按进程的CPU使用率排序</h3><p>运行top命令后，键入大写P。</p><p>有两种途径：</p><p>a) 打开大写键盘的情况下，直接按P键</p><p>b) 未打开大写键盘的情况下，Shift+P键</p><h3 id="按进程的内存使用率排序"><a href="#按进程的内存使用率排序" class="headerlink" title="按进程的内存使用率排序"></a>按进程的内存使用率排序</h3><p>运行top命令后，键入大写M。</p><p>有两种途径：</p><p>a) 打开大写键盘的情况下，直接按M键</p><p>b) 未打开大写键盘的情况下，Shift+M键</p><p>按Enter键可以查看，及时的情况。</p><p>TOP交互命令如下</p><pre class="line-numbers language-x86asm" data-language="x86asm"><code class="language-x86asm">c： 显示完整的命令d： 更改刷新频率f： 增加或减少要显示的列(选中的会变成大写并加*号)F： 选择排序的列h： 显示帮助画面H： 显示线程i： 忽略闲置和僵死进程k： 通过给予一个PID和一个signal来终止一个进程。（默认signal为15。在安全模式中此命令被屏蔽）l:  显示平均负载以及启动时间（即显示影藏第一行）m： 显示内存信息M： 根据内存资源使用大小进行排序N： 按PID由高到低排列o： 改变列显示的顺序O： 选择排序的列，与F完全相同P： 根据CPU资源使用大小进行排序q： 退出top命令r： 修改进程的nice值(优先级)。优先级默认为10，正值使优先级降低，反之则提高的优先级s： 设置刷新频率（默认单位为秒，如有小数则换算成ms）。默认值是5s，输入0值则系统将不断刷新S： 累计模式（把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+ ）T： 根据进程使用CPU的累积时间排序t： 显示进程和CPU状态信息（即显示影藏CPU行）u： 指定用户进程W： 将当前设置写入~&#x2F;.toprc文件，下次启动自动调用toprc文件的设置&lt;： 向前翻页&gt;： 向后翻页?： 显示帮助画面1(数字1)： 显示每个CPU的详细情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器宕机原因排查思路</title>
      <link href="/2022/05/26/fu-wu-qi-dang-ji-yuan-yin-pai-cha-si-lu/"/>
      <url>/2022/05/26/fu-wu-qi-dang-ji-yuan-yin-pai-cha-si-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-真假死机"><a href="#1-真假死机" class="headerlink" title="1.真假死机"></a>1.真假死机</h3><p>  真死机</p><p>　　服务器确确实实宕机了，导致服务不可用，无法访问。</p><p>  假死机</p><p>　　由于硬件资源暂时性地被消耗殆尽，因而无法对外部指令进行响应的现象，比如CPU和内存被占满，表明有软件正在大量的占用服务器的内存和CPU，或者网站处于访问高峰期，带宽资源跑满等，这时只需要等待一定的时间，待服务器腾出更多的硬件资源即可恢复正常，如果长时间恢复不了，可能需要我们手动处理下，比如杀死进程。</p><p>　　那么，如何解决这个问题呢？第一，要从网站着手，看看是不是网站程序有不合理的地方，数据查询，是否有死循环。尽可能的用html静态网页显示，减轻数据库的压力。第二，升级服务器硬件配置，例如：加大服务器内存，升级服务器CPU，加大服务器带宽，这样就可以解决服务器假死机的问题。</p><h3 id="2-宕机可能原因"><a href="#2-宕机可能原因" class="headerlink" title="2.宕机可能原因"></a>2.宕机可能原因</h3><p>访问量过高，超出系统承载能力，包括正常的短暂性突增，或者异常访问，比如黑客攻击等；<br>服务器配置过低，导致即便访问量不算太高也超出了系统承载能力，需要提高配置；<br>应用程序本身存在bug，比如死循环，消耗系统资源的逻辑导致资源耗尽；<br>某些系统参数配置不合理，比如fd个数或允许连接数过低等；<br>多线程造成的死锁现象，互相等待对方释放资源；<br>服务器硬件故障，比如内存故障，需要更换；<br>系统内核bug，比如软死锁等，需要升级内核；<br>当然，也有可能是人为误操作导致的；</p><h3 id="3-排查思路"><a href="#3-排查思路" class="headerlink" title="3.排查思路　　"></a>3.排查思路　　</h3><p>  首先判断是真死还是假死，如果假死，那等一段时间或手动杀死进程即可，如果真死则需要进一步排查；</p><p>  查看系统日志 /var/log/messages，分析宕机时间前后的系统日志，看看是否有明显的报错，比如oom或内核bug；</p><p>  如果启用了kdump，也可以查看宕机生成的crash文件，默认/var/crash目录下，注意生成时间是否对应；</p><p>  查看监控数据，在宕机前有没有指标异常，比如CPU或内存突增，可能短暂突发上量超过系统承载能力；</p><p>  也有可能是硬件故障，可以看下/var/log/dmesg，或者登录远控查看系统日志，比如内存故障等，可能需要更换；</p><h3 id="4-如何处理"><a href="#4-如何处理" class="headerlink" title="4.如何处理"></a>4.如何处理</h3><p>  首先恢复业务、</p><p>  分析问题，排查原因、</p><p>  制定解决方案、</p><p>  完善监控，及时发现、</p><p>  复盘总结，避免再次发生，</p><p>  经验积累，知识库</p><h3 id="5-没有办法的办法"><a href="#5-没有办法的办法" class="headerlink" title="5.没有办法的办法"></a>5.没有办法的办法</h3><p>  万能的重启</p><p>所有日志文件</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;var&#x2F;log&#x2F;messages — 包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var&#x2F;log&#x2F;messages日志中。&#x2F;var&#x2F;log&#x2F;dmesg — 包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们&#x2F;var&#x2F;log&#x2F;boot.log — 包含系统启动时的日志。&#x2F;var&#x2F;log&#x2F;daemon.log — 包含各种系统后台守护进程日志信息。&#x2F;var&#x2F;log&#x2F;dpkg.log – 包括安装或dpkg命令清除软件包的日志。&#x2F;var&#x2F;log&#x2F;kern.log – 包含内核产生的日志，有助于在定制内核时解决问题。&#x2F;var&#x2F;log&#x2F;lastlog — 记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。&#x2F;var&#x2F;log&#x2F;maillog &#x2F;var&#x2F;log&#x2F;mail.log — 包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。&#x2F;var&#x2F;log&#x2F;user.log — 记录所有等级用户信息的日志&#x2F;var&#x2F;log&#x2F;Xorg.x.log — 来自X的日志信息&#x2F;var&#x2F;log&#x2F;alternatives.log – 更新替代信息都记录在这个文件中&#x2F;var&#x2F;log&#x2F;btmp – 记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f &#x2F;var&#x2F;log&#x2F;btmp | more“&#x2F;var&#x2F;log&#x2F;cups — 涉及所有打印信息的日志&#x2F;var&#x2F;log&#x2F;anaconda.log — 在安装Linux时，所有安装信息都储存在这个文件中&#x2F;var&#x2F;log&#x2F;yum.log — 包含使用yum安装的软件包信息&#x2F;var&#x2F;log&#x2F;cron — 每当cron进程开始一个工作时，就会将相关信息记录在这个文件中&#x2F;var&#x2F;log&#x2F;secure — 包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里&#x2F;var&#x2F;log&#x2F;wtmp或&#x2F;var&#x2F;log&#x2F;utmp — 包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等&#x2F;var&#x2F;log&#x2F;faillog – 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中&#x2F;var&#x2F;log&#x2F;httpd&#x2F;或&#x2F;var&#x2F;log&#x2F;apache2 — 包含服务器access_log和error_log信息&#x2F;var&#x2F;log&#x2F;lighttpd&#x2F; — 包含light HTTPD的access_log和error_log&#x2F;var&#x2F;log&#x2F;mail&#x2F; – 这个子目录包含邮件服务器的额外日志&#x2F;var&#x2F;log&#x2F;prelink&#x2F; — 包含.so文件被prelink修改的信息&#x2F;var&#x2F;log&#x2F;audit&#x2F; — 包含被 Linux audit daemon储存的信息&#x2F;var&#x2F;log&#x2F;samba&#x2F; – 包含由samba存储的信息&#x2F;var&#x2F;log&#x2F;sa&#x2F; — 包含每日由sysstat软件包收集的sar文件&#x2F;var&#x2F;log&#x2F;sssd&#x2F; – 用于守护进程安全服务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 系统日志 </category>
          
          <category> 硬件故障 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Spring 介绍 WebSockets</title>
      <link href="/2022/05/25/shi-yong-spring-jie-shao-websockets/"/>
      <url>/2022/05/25/shi-yong-spring-jie-shao-websockets/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址：[<a href="https://www.baeldung.com/websockets-spring">https://www.baeldung.com/websockets-spring</a>]</p></blockquote><h3 id="通过参考Learn-Spring-课程开始使用-Spring-5-和-Spring-Boot-2-："><a href="#通过参考Learn-Spring-课程开始使用-Spring-5-和-Spring-Boot-2-：" class="headerlink" title="通过参考Learn Spring\课程开始使用 Spring 5 和 Spring Boot 2 ："></a><strong><em>通过参考Learn Spring\</em>课程开始使用 Spring 5 和 Spring Boot 2 ：</strong></h3><p><strong><a href="https://www.baeldung.com/ls-course-start">&gt;&gt; 学习春天</a></strong></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h2><p>在本文中，我们将创建一个简单的 Web 应用程序，该应用程序使用Spring Framework 4.0 引入的<strong>新 WebSocket 功能实现消息传递。</strong></p><p>WebSockets 是Web 浏览器和服务器之间的<strong>双向</strong>、<strong>全双工</strong>、<strong>持久连接。</strong>建立 WebSocket 连接后，连接将保持打开状态，直到客户端或服务器决定关闭此连接。</p><p>一个典型的用例可能是当应用程序涉及多个用户相互通信时，例如在聊天中。我们将在示例中构建一个简单的聊天客户端。</p><h2 id="2-Maven依赖"><a href="#2-Maven依赖" class="headerlink" title="2.Maven依赖"></a><strong>2.Maven依赖</strong></h2><p>由于这是一个基于 Maven 的项目，我们首先将所需的依赖项添加到<em>pom.xml</em>中：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-websocket<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.2.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-messaging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.2.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，由于我们将使用<em>JSON</em>来构建消息正文，因此我们需要添加<em>Jackson</em>依赖项。这允许 Spring 将我们的 Java 对象转换为 JSON 或从<em>JSON</em>转换：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.10.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.10.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果您想获得上述库的最新版本，请在<a href="https://search.maven.org/classic/">Maven Central</a>上查找它们。</p><h2 id="3-在-Spring-中启用-WebSocket"><a href="#3-在-Spring-中启用-WebSocket" class="headerlink" title="3. 在 Spring 中启用 WebSocket"></a><strong>3. 在 Spring 中启用 WebSocket</strong></h2><p>首先要做的是启用 WebSocket 功能。为此，我们需要向应用程序添加配置并使用<em>@EnableWebSocketMessageBroker</em>注释此类。</p><p>顾名思义，它启用了由消息代理支持的 WebSocket 消息处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableWebSocketMessageBrokerpublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123;    @Override    public void configureMessageBroker(MessageBrokerRegistry config) &#123;        config.enableSimpleBroker(&quot;&#x2F;topic&quot;);        config.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;);    &#125;    @Override    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;         registry.addEndpoint(&quot;&#x2F;chat&quot;);         registry.addEndpoint(&quot;&#x2F;chat&quot;).withSockJS();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们可以看到<em>configureMessageBroker</em>方法用于<strong>配置消息代理</strong>。首先，我们启用内存中的消息代理将消息传送回客户端，目的地为前缀为“/topic”。</p><p>我们通过指定“ / app”前缀来完成我们的 简单<em>配置，以过滤针对应用程序注释方法的目标（通过@MessageMapping</em>）。</p><p><em>registerStompEndpoints</em>方法注册“ /chat”端点，启用<strong>Spring 的<a href="https://stomp.github.io/stomp-specification-1.2.html#Abstract">STOMP</a>支持</strong>。请记住，为了弹性，我们还在此处添加了一个无需 SockJS 即可工作的端点。</p><p>此端点以“/app”为前缀，是<em>ChatController.send()</em>方法映射到处理的端点。</p><p>它还<strong>启用了<a href="https://github.com/sockjs/sockjs-protocol">SockJS</a>回退选项，</strong>因此如果 WebSocket 不可用，则可以使用替代消息传递选项。这很有用，因为并非所有浏览器都支持 WebSocket，并且可能会被限制性网络代理排除。</p><p>回退让应用程序使用 WebSocket API，但在运行时必要时优雅地降级为非 WebSocket 替代方案。</p><h2 id="4-创建消息模型"><a href="#4-创建消息模型" class="headerlink" title="4. 创建消息模型"></a><strong>4. 创建消息模型</strong></h2><p>现在我们已经设置了项目并配置了 WebSocket 功能，我们需要创建要发送的消息。</p><p><em>端点将接受包含发件人姓名和正文为JSON</em>对象的 STOMP 消息中的文本的消息。</p><p>消息可能如下所示：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>    <span class="token string-property property">"from"</span><span class="token operator">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>    <span class="token string-property property">"text"</span><span class="token operator">:</span> <span class="token string">"Hello!"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为了对携带文本的消息进行建模，我们可以创建一个带有<em>from</em>和<em>text</em>属性的简单 Java 对象：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Message &#123;    private String from;    private String text;    &#x2F;&#x2F; getters and setters&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，Spring 将使用<em>Jackson</em>库将我们的模型对象与 JSON 进行转换。</p><h2 id="5-创建一个消息处理控制器"><a href="#5-创建一个消息处理控制器" class="headerlink" title="5. 创建一个消息处理控制器"></a><strong>5. 创建一个消息处理控制器</strong></h2><p>正如我们所见，Spring 使用 STOMP 消息传递的方法是将控制器方法与配置的端点相关联。这是通过<em>@MessageMapping</em>注释实现的。</p><p>端点和控制器之间的关联使我们能够在需要时处理消息：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@MessageMapping(&quot;&#x2F;chat&quot;)@SendTo(&quot;&#x2F;topic&#x2F;messages&quot;)public OutputMessage send(Message message) throws Exception &#123;    String time &#x3D; new SimpleDateFormat(&quot;HH:mm&quot;).format(new Date());    return new OutputMessage(message.getFrom(), message.getText(), time);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>F或我们示例的目的 ，我们将创建另一个名为<em>OutputMessage</em>的模型对象来表示发送到配置的目标的输出消息。我们使用发送者和从传入消息中获取的消息文本填充我们的对象，并使用时间戳来丰富它。</p><p>处理完我们的消息后，我们将其发送到使用<em>@SendTo</em>注释定义的适当目的地。<em>“ /topic/messages</em> ”目的地的所有订阅者都将收到该消息。</p><h2 id="6-创建浏览器客户端"><a href="#6-创建浏览器客户端" class="headerlink" title="6.创建浏览器客户端"></a><strong>6.创建浏览器客户端</strong></h2><p>在服务器端进行配置后，我们将使用<strong><a href="https://github.com/sockjs/sockjs-client">sockjs-client</a>库</strong>构建一个与我们的消息传递系统交互的简单 HTML 页面。</p><p>首先，我们需要导入<em>sockjs</em>和<em>stomp</em> Javascript 客户端库。接下来，我们可以创建一个<em>connect()</em>函数来打开与我们的端点的通信，一个<em>sendMessage()</em>函数来发送我们的 STOMP 消息和一个<em>disconnect()</em>函数来关闭通信：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Chat WebSocket<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>resources/js/sockjs-0.3.4.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>resources/js/stomp.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">            <span class="token keyword">var</span> stompClient <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        <span class="token keyword">function</span> <span class="token function">setConnected</span><span class="token punctuation">(</span><span class="token parameter">connected</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'connect'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>disabled <span class="token operator">=</span> connected<span class="token punctuation">;</span>                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'disconnect'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>disabled <span class="token operator">=</span> <span class="token operator">!</span>connected<span class="token punctuation">;</span>                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'conversationDiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>visibility                   <span class="token operator">=</span> connected <span class="token operator">?</span> <span class="token string">'visible'</span> <span class="token operator">:</span> <span class="token string">'hidden'</span><span class="token punctuation">;</span>                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'response'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">var</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SockJS</span><span class="token punctuation">(</span><span class="token string">'/chat'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stompClient <span class="token operator">=</span> Stomp<span class="token punctuation">.</span><span class="token function">over</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>                  stompClient<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">frame</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">setConnected</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Connected: '</span> <span class="token operator">+</span> frame<span class="token punctuation">)</span><span class="token punctuation">;</span>                    stompClient<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">'/topic/messages'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">messageOutput</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">showMessageOutput</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>messageOutput<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token keyword">function</span> <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>stompClient <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    stompClient<span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">setConnected</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Disconnected"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token keyword">function</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">var</span> from <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'from'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">var</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>                stompClient<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"/app/chat"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                   <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string-property property">'from'</span><span class="token operator">:</span>from<span class="token punctuation">,</span> <span class="token string-property property">'text'</span><span class="token operator">:</span>text<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token keyword">function</span> <span class="token function">showMessageOutput</span><span class="token punctuation">(</span><span class="token parameter">messageOutput</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">var</span> response <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'response'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">var</span> p <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span>style<span class="token punctuation">.</span>wordWrap <span class="token operator">=</span> <span class="token string">'break-word'</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>messageOutput<span class="token punctuation">.</span>from <span class="token operator">+</span> <span class="token string">": "</span>                   <span class="token operator">+</span> messageOutput<span class="token punctuation">.</span>text <span class="token operator">+</span> <span class="token string">" ("</span> <span class="token operator">+</span> messageOutput<span class="token punctuation">.</span>time <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                response<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token special-attr"><span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>from<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Choose a nickname<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>connect<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Connect<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>disconnect<span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>disabled<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>                    Disconnect                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>conversationDiv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Write a message...<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>sendMessage<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value javascript language-javascript"><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>Send<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>response<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-测试示例"><a href="#7-测试示例" class="headerlink" title="7. 测试示例"></a><strong>7. 测试示例</strong></h2><p>为了测试我们的示例，我们可以打开几个浏览器窗口并访问聊天页面：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">http://localhost:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完成后，我们可以通过输入昵称并点击连接按钮来加入聊天。如果我们撰写并发送消息，我们可以在所有加入聊天的浏览器会话中看到它。</p><p>查看屏幕截图以查看示例：</p><p><a href="https://www.baeldung.com/wp-content/uploads/2016/05/websockets-chat.png"><img src="https://www.baeldung.com/wp-content/uploads/2016/05/websockets-chat.png" alt="img"></a></p><h2 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a><strong>8. 结论</strong></h2><p>在本教程中，我们探索了Spring 的 WebSocket 支持。我们已经看到了它的服务器端配置，并使用<em>sockjs</em>和<em>stomp</em> Javascript 库构建了一个简单的客户端对应物。</p><p>示例代码可以在<a href="https://github.com/eugenp/tutorials/tree/master/spring-websockets">GitHub 项目</a>中找到。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建之在文章中插入图片</title>
      <link href="/2022/05/25/hexo-bo-ke-da-jian-zhi-zai-wen-zhang-zhong-cha-ru-tu-pian/"/>
      <url>/2022/05/25/hexo-bo-ke-da-jian-zhi-zai-wen-zhang-zhong-cha-ru-tu-pian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a>]</p></blockquote><p>在写文章时，常常有配图说明的需求。Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p><h3 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h3><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>当Hexo项目中只用到少量图片时，可以将图片统一放在<code>source/images</code>文件夹中，通过markdown语法访问它们。</p><pre class="line-numbers language-none"><code class="language-none">source&#x2F;images&#x2F;image.jpg![](&#x2F;images&#x2F;image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p>图片除了可以放在统一的<code>images</code>文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置<code>_config.yml</code>来生成。</p><pre class="line-numbers language-none"><code class="language-none">_config.ymlpost_asset_folder: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>_config.yml</code>文件中的配置项<code>post_asset_folder</code>设为<code>true</code>后，执行命令<code>$ hexo new post_name</code>，在<code>source/_posts</code>中会生成文章<code>post_name.md</code>和同名文件夹<code>post_name</code>。将图片资源放在<code>post_name</code>中，文章就可以使用相对路径引用图片资源了。</p><pre class="line-numbers language-none"><code class="language-none">_posts&#x2F;post_name&#x2F;image.jpg![](image.jpg)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p><pre class="line-numbers language-none"><code class="language-none">_posts&#x2F;post_name&#x2F;image.jpg&#123;% asset_img image.jpg This is an image %&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CDN引用"><a href="#CDN引用" class="headerlink" title="CDN引用"></a>CDN引用</h3><p>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如<a href="http://cloudinary.com/">Cloudinary</a>提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>curl命令的转换</title>
      <link href="/2022/05/25/curl-ming-ling-de-zhuan-huan/"/>
      <url>/2022/05/25/curl-ming-ling-de-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://www.jianshu.com/p/84bf836ce1c1">https://www.jianshu.com/p/84bf836ce1c1</a>]</p></blockquote><h2 id="一、curl转不同语言代码"><a href="#一、curl转不同语言代码" class="headerlink" title="一、curl转不同语言代码"></a>一、curl转不同语言代码</h2><h2 id="二、Postman-导入导出-curl-命令详细步骤"><a href="#二、Postman-导入导出-curl-命令详细步骤" class="headerlink" title="二、Postman 导入导出 curl 命令详细步骤"></a>二、Postman 导入导出 curl 命令详细步骤</h2><h3 id="浏览器复制curl"><a href="#浏览器复制curl" class="headerlink" title="浏览器复制curl"></a>浏览器复制curl</h3><p><img src="/images/step-1.png" alt="img"></p><h3 id="一、直接上地址，网站有教程"><a href="#一、直接上地址，网站有教程" class="headerlink" title="一、直接上地址，网站有教程"></a>一、直接上地址，网站有教程</h3><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcurl.trillworks.com%2F%23">https://curl.trillworks.com/#</a></p><h3 id="二、接口调试的时候经常会使用到。"><a href="#二、接口调试的时候经常会使用到。" class="headerlink" title="二、接口调试的时候经常会使用到。"></a>二、接口调试的时候经常会使用到。</h3><h4 id="1-postman导入curl"><a href="#1-postman导入curl" class="headerlink" title="1.postman导入curl"></a>1.postman导入curl</h4><p>1）打开 postman ， 点击左上角的 Import ， 选择 Raw Text ，点击 Continue</p><p><img src="/images/step-2.png" alt="img"><br>2）点击 Import<br>3）所有参数都已经配置好了，点击 send 发送请求</p><h4 id="2-postman导出curl"><a href="#2-postman导出curl" class="headerlink" title="2.postman导出curl"></a>2.postman导出curl</h4><p>1）在右侧 CODE 点击</p><p><img src="/images/step-3.png" alt="img"></p><p>2）选择 CURL（其他语言也可）</p>]]></content>
      
      
      <categories>
          
          <category> curl </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED flows 操作</title>
      <link href="/2022/05/25/node-red-flows-cao-zuo/"/>
      <url>/2022/05/25/node-red-flows-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="POST-flows"><a href="#POST-flows" class="headerlink" title="POST /flows"></a>POST /flows</h1><blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://nodered.org/docs/api/admin/methods/post/flows/">https://nodered.org/docs/api/admin/methods/post/flows/</a>]</p></blockquote><p>Set the active flow configuration.</p><p>需要权限：<code>flows.write</code></p><h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><div class="table-container"><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:left">价值</th></tr></thead><tbody><tr><td style="text-align:left"><code>Authorization</code></td><td style="text-align:left"><code>Bearer [token]</code>- 如果启用了身份验证</td></tr><tr><td style="text-align:left"><code>Content-type</code></td><td style="text-align:left"><code>application/json</code></td></tr><tr><td style="text-align:left"><code>Node-RED-API-Version</code></td><td style="text-align:left">（<em>自 0.15.0 起</em>）正在使用的 api 版本。<code>v1</code>如果未设置，则默认为。</td></tr><tr><td style="text-align:left"><code>Node-RED-Deployment-Type</code></td><td style="text-align:left"><code>full</code>, <code>nodes</code>,<code>flows</code>或<code>reload</code></td></tr></tbody></table></div><p>标<code>Node-RED-Deployment-Type</code>头用于定义执行的部署类型。</p><ul><li><code>full</code>- 在新配置开始之前，所有现有节点都已停止。如果未提供标头，这是默认行为。</li><li><code>nodes</code>- 在应用新配置之前，仅停止已修改的节点。</li><li><code>flows</code>- 在应用新配置之前，仅停止包含修改节点的流。</li><li><code>reload</code>- 从存储中重新加载流并重新启动所有节点（从 Node-RED 0.12.2 开始）</li></ul><h3 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h3><p>请求正文的格式将取决于所使用的 Node-RED API 版本：</p><h4 id="v1-节点对象数组"><a href="#v1-节点对象数组" class="headerlink" title="v1- 节点对象数组"></a><code>v1</code>- 节点对象数组</h4><pre class="line-numbers language-none"><code class="language-none">[  &#123;    &quot;type&quot;: &quot;tab&quot;,    &quot;id&quot;: &quot;396c2376.c693dc&quot;,    &quot;label&quot;: &quot;Sheet 1&quot;  &#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="v2-流响应对象"><a href="#v2-流响应对象" class="headerlink" title="v2- 流响应对象"></a><code>v2</code>- 流响应对象</h4><p>该<code>rev</code>属性（如果提供）应反映由 返回的流的修订<code>GET /flows</code>。</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="设置节点凭据"><a href="#设置节点凭据" class="headerlink" title="设置节点凭据"></a>设置节点凭据</h4><p>有两种方法可以通过此请求提供凭据。数组中的各个节点对象<code>flows</code>可以包含一个<code>credentials</code>属性，该属性包含该节点的凭据。</p><p>或者，顶级对象可以包括一个<code>credentials</code>属性，该属性具有各个节点的凭据，或者一个完整的加密集。</p><p><strong>内联节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;,        &quot;credentials&quot;: &#123;            &quot;user&quot;: &quot;my-username&quot;,            &quot;pass&quot;: &quot;my-password&quot;        &#125;      &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>单独的节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ],    &quot;credentials&quot;: &#123;        &quot;396c2376.c693dc&quot;: &#123;            &quot;user&quot;: &quot;my-username&quot;,            &quot;pass&quot;: &quot;my-password&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加密节点凭据：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;abc-123&quot;,    &quot;flows&quot;: [      &#123;        &quot;type&quot;: &quot;tab&quot;,        &quot;id&quot;: &quot;396c2376.c693dc&quot;,        &quot;label&quot;: &quot;Sheet 1&quot;      &#125;    ],    &quot;credentials&quot;: &#123;        &quot;$&quot;: &quot;beea417990012379ca6d4116bd1fda5bOWbwy7UnQvccxAEH1V1pSEETTfSNerYGvP4Aai6RT&#x2F;DNpnjCCP&#x2F;fdzildzlJhFjYcRKdO1Q&#x3D;&quot;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>}</p><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><div class="table-container"><table><thead><tr><th style="text-align:left">状态码</th><th style="text-align:left">原因</th><th style="text-align:left">回复</th></tr></thead><tbody><tr><td style="text-align:left"><code>200</code></td><td style="text-align:left"><code>v2</code>成功</td><td style="text-align:left"><code>rev</code>活动流的新特性。见下文。</td></tr><tr><td style="text-align:left"><code>204</code></td><td style="text-align:left"><code>v1</code>成功</td><td style="text-align:left"><em>没有任何</em></td></tr><tr><td style="text-align:left"><code>400</code></td><td style="text-align:left">API 版本无效</td><td style="text-align:left">错误<a href="https://nodered.org/docs/api/admin/errors">响应</a></td></tr><tr><td style="text-align:left"><code>401</code></td><td style="text-align:left">未经授权</td><td style="text-align:left"><em>没有任何</em></td></tr><tr><td style="text-align:left"><code>409</code></td><td style="text-align:left">版本不匹配</td><td style="text-align:left">错误<a href="https://nodered.org/docs/api/admin/errors">响应</a>。见下文。</td></tr></tbody></table></div><p>如果<code>v1</code>正在使用 API，则成功的请求不包含响应正文。</p><p>如果<code>v2</code>正在使用 API，则请求应包括<code>rev</code>设置为<code>rev</code>请求者已知的最新值的属性。如果此值与<code>rev</code>运行时中活动流的值匹配，则请求将成功。</p><p>如果不匹配，这表明运行时正在使用更新版本的流，并且请求被拒绝并带有<code>409</code>状态代码。这允许请求者解决任何差异并重新提交请求。</p><p>如果请求者希望强制部署，<code>rev</code>则应从请求中省略该属性。</p><p>请求成功时，响应会提供新<code>rev</code>值：</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;rev&quot;: &quot;def-456&quot;,&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em>注意</em>：该<code>rev</code>属性是一个字符串，但不应对其格式做出其他假设。</p>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node-RED api Authentication</title>
      <link href="/2022/05/25/node-red-api-authentication/"/>
      <url>/2022/05/25/node-red-api-authentication/</url>
      
        <content type="html"><![CDATA[<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p><code>adminAuth</code>使用文件中的属性保护 Node-RED 管理 API <code>settings.js</code> 。<a href="https://nodered.org/docs/user-guide/runtime/securing-node-red">安全</a>部分描述了应该如何配置该属性。</p><p>如果未设置该属性，则对 Node-RED 具有网络访问权限的任何人都可以访问 Node-RED 管理 API。</p><h3 id="Step-0-检查身份验证方案"><a href="#Step-0-检查身份验证方案" class="headerlink" title="Step 0 - 检查身份验证方案"></a>Step 0 - 检查身份验证方案</h3><p><code>/auth/login</code>用于返回活动身份验证方案的 HTTP GET 。</p><p><em>*curl example</em>:*：</p><pre class="line-numbers language-none"><code class="language-none">curl http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在当前版本的 API 中，有两种可能的结果：</p><h5 id="无主动身份验证"><a href="#无主动身份验证" class="headerlink" title="无主动身份验证"></a>无主动身份验证</h5><pre class="line-numbers language-none"><code class="language-none">&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无需提供任何进一步的身份验证信息即可发出所有 API 请求。</p><h5 id="基于凭据的身份验证"><a href="#基于凭据的身份验证" class="headerlink" title="基于凭据的身份验证"></a>基于凭据的身份验证</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;credentials&quot;,  &quot;prompts&quot;: [    &#123;      &quot;id&quot;: &quot;username&quot;,      &quot;type&quot;: &quot;text&quot;,      &quot;label&quot;: &quot;Username&quot;    &#125;,    &#123;      &quot;id&quot;: &quot;password&quot;,      &quot;type&quot;: &quot;password&quot;,      &quot;label&quot;: &quot;Password&quot;    &#125;  ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>API 由访问令牌保护。</p><h3 id="Step-1-获取访问令牌"><a href="#Step-1-获取访问令牌" class="headerlink" title="Step 1 - 获取访问令牌"></a>Step 1 - 获取访问令牌</h3><p>HTTP POST<code>/auth/token</code>用于交换用户凭据以获取访问令牌。</p><p>必须提供以下参数：</p><ul><li><code>client_id</code>- 识别客户。目前，必须是<code>node-red-admin</code>或<code>node-red-editor</code>。</li><li><code>grant_type</code>- 一定是<code>password</code></li><li><code>scope</code>- 请求的权限的空格分隔列表。目前，必须是<code>*</code>或<code>read</code>。</li><li><code>username</code>- 要验证的用户名</li><li><code>password</code>- 验证密码</li></ul><p><em>curl example</em>：</p><pre class="line-numbers language-curl" data-language="curl"><code class="language-curl">curl http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;token --data &#39;client_id&#x3D;node-red-admin&amp;grant_type&#x3D;password&amp;scope&#x3D;*&amp;username&#x3D;admin&amp;password&#x3D;password&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果成功，响应将包含访问令牌：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;access_token&quot;: &quot;A_SECRET_TOKEN&quot;,  &quot;expires_in&quot;:604800,  &quot;token_type&quot;: &quot;Bearer&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Step-2-使用访问令牌"><a href="#Step-2-使用访问令牌" class="headerlink" title="Step 2 - 使用访问令牌"></a>Step 2 - 使用访问令牌</h3><p>然后，所有后续 API 调用都应在标头中提供此令牌<code>Authorization</code> 。</p><p><em>curl example</em>：</p><pre class="line-numbers language-curl" data-language="curl"><code class="language-curl">curl -H &quot;Authorization: Bearer A_SECRET_TOKEN&quot; http:&#x2F;&#x2F;localhost:1880&#x2F;settings<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="撤销令牌"><a href="#撤销令牌" class="headerlink" title="撤销令牌"></a>撤销令牌</h3><p>要在不再需要令牌时撤销令牌，应通过 HTTP POST 将其发送到<code>/auth/revoke</code>：</p><p><em>卷曲示例</em>：</p><pre class="line-numbers language-none"><code class="language-none">curl --data &#39;token&#x3D;A_SECRET_TOKEN&#39; -H &quot;Authorization: Bearer A_SECRET_TOKEN&quot; http:&#x2F;&#x2F;localhost:1880&#x2F;auth&#x2F;revoke<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bearer Token 的使用方法</title>
      <link href="/2022/05/25/bearer-token-de-shi-yong-fang-fa/"/>
      <url>/2022/05/25/bearer-token-de-shi-yong-fang-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址[<a href="https://blog.yorkxin.org/posts/oauth2-6-bearer-token.html">https://blog.yorkxin.org/posts/oauth2-6-bearer-token.html</a>]</p></blockquote><p>這篇不屬於 OAuth 2.0 規格書（RFC 6749）本身，而是屬於另一份 spec <em><a href="https://tools.ietf.org/html/rfc6750">RFC 6750: The OAuth 2.0 Authorization Framework: Bearer Token Usage</a></em> 。我認為它存在的目的是「示範一下 Token 的用法，並且定義下來，讓大家可以參考」，因為 OAuth 2.0 規格書沒有明確規定「Token 長什麼樣子」，甚至「Resource Server 如何拒絕非法的 Token」（指 API）都沒定義，只規定了怎麼拿取、怎麼撤銷、怎麼流通。</p><p>實際上，即使有定義這個 Bearer Token ，各大網站的 API 也並非都使用這種 Token ，我看到有明確說明使用 Bearer Token 的像是 Twitter API，其他的要不是非使用 “Bearer” 關鍵字，就是沒有明確指出何種 Token （其實也不需要，因為在那些網站 Token 只有一種用途）。</p><p>不過即使如此，對於我打算實作的 API ，我也是準備使用 Bearer Token 的，因為夠 naïve 。如果你跟我一樣沒有自己刻 Token 的能力，就用 Bearer Token 就好了。</p><p>當然， RFC 6750 我也有轉成 <a href="https://gist.github.com/yorkxin/6591290">Markdown 好讀版</a>。</p><h2 id="Bearer-Token-的用途"><a href="#Bearer-Token-的用途" class="headerlink" title="Bearer Token 的用途"></a>Bearer Token 的用途</h2><p>OAuth 2.0 (<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>) 定義了 Client 如何取得 Access Token 的方法。Client 可以用 Access Token 以 Resource Owner 的名義來向 Resource Server 取得 Protected Resource ，例如我 (Resource Owner) 授權一個手機 App (Client) 以我 (Resource Owner) 的名義去 Facebook (Resource Server) 取得我的朋友名單 (Protected Resource)。OAuth 2.0 定義 Access Token 是 Resource Server 用來認證的唯一方式，有了這個， Resource Server 就不需要再提供其他認證方式，例如帳號密碼。</p><p>然而在 RFC 6749 裡面只定義抽象的概念，細節如 Access Token 格式、怎麼傳到 Resource Server ，以及 Access Token 無效時， Resource Server 怎麼處理，都沒有定義。所以在 RFC 6750 另外定義了 Bearer Token 的用法。Bearer Token 是一種 Access Token ，由 Authorization Server 在 Resource Owner 的允許下核發給 Client ，Resource Server 只要認這個 Token 就可以認定 Client 已經經由 Resource Owner 的許可，不需要用密碼學的方式來驗證這個 Token 的真偽。關於 Token 被偷走的安全性問題，此 Spec 裡面也有提到。</p><p><em>本段參考 Abstract 及 Section 1</em></p><h2 id="Bearer-Token-的格式"><a href="#Bearer-Token-的格式" class="headerlink" title="Bearer Token 的格式"></a>Bearer Token 的格式</h2><pre class="line-numbers language-none"><code class="language-none">Bearer XXXXXXXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中 <code>XXXXXXXX</code> 的格式為 b64token ，ABNF 的定義：</p><pre class="line-numbers language-none"><code class="language-none">b64token &#x3D; 1*( ALPHA &#x2F; DIGIT &#x2F; &quot;-&quot; &#x2F; &quot;.&quot; &#x2F; &quot;_&quot; &#x2F; &quot;~&quot; &#x2F; &quot;+&quot; &#x2F; &quot;&#x2F;&quot; ) *&quot;&#x3D;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>寫成 Regular Expression 即是：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;[A-Za-z0-9\-\._~\+\&#x2F;]+&#x3D;*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>本段參考 Section 2.1</em></p><h2 id="Client-向-Resource-Server-出示-Access-Token-的方式"><a href="#Client-向-Resource-Server-出示-Access-Token-的方式" class="headerlink" title="Client 向 Resource Server 出示 Access Token 的方式"></a>Client 向 Resource Server 出示 Access Token 的方式</h2><p>三種</p><h3 id="1-放在-HTTP-Header-裡面"><a href="#1-放在-HTTP-Header-裡面" class="headerlink" title="(1) 放在 HTTP Header 裡面"></a>(1) 放在 HTTP Header 裡面</h3><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;resource HTTP&#x2F;1.1Host: server.example.comAuthorization: Bearer mF_9.B5f-4.1JqM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Resource Server 必須支援這個方式。</p><p><em>本段參考 Section 2.2</em></p><h3 id="2-放在-Request-Body-裡面（Form-之類的）"><a href="#2-放在-Request-Body-裡面（Form-之類的）" class="headerlink" title="(2) 放在 Request Body 裡面（Form 之類的）"></a>(2) 放在 Request Body 裡面（Form 之類的）</h3><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;resource HTTP&#x2F;1.1Host: server.example.comContent-Type: application&#x2F;x-www-form-urlencodedaccess_token&#x3D;mF_9.B5f-4.1JqM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前提：</p><ul><li>Header 要有 <code>Content-Type: application/x-www-form-urlencoded</code>。</li><li>Body 格式要符合 <a href="https://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#h-17.13.4.1">W3C HTML 4.01 定義 application/x-www-form-urlencoded</a>。</li><li>Body 要只有一個 part （不可以是 multipart）。</li><li>Body 要編碼成只有 ASCII chars 的內容。</li><li>Request method 必須是一種有使用 request-body 的，也就是說不能用 <code>GET</code> 。</li></ul><p>就是送表單嘛，但不可以是 <code>multipart/form-data</code> 這種（通常用來上傳檔案）。</p><p>Resource Server 可以但不一定要支援這個方式。</p><p><em>本段參考 Section 2.3</em></p><h3 id="3-放在-URI-裡面的一個-Query-Parameter-（不建議）"><a href="#3-放在-URI-裡面的一個-Query-Parameter-（不建議）" class="headerlink" title="(3) 放在 URI 裡面的一個 Query Parameter （不建議）"></a>(3) 放在 URI 裡面的一個 Query Parameter （不建議）</h3><p>規定要使用 <code>access_token</code> 這個 parameter ，例：</p><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;resource?access_token&#x3D;mF_9.B5f-4.1JqM HTTP&#x2F;1.1Host: server.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然而因為 URL 可以被 proxy 抄走（如 log）或存在瀏覽器的歷史記錄裡面，為了防 replay ，最好這樣做：</p><ul><li>Client 送 <code>Cache-Control: no-store</code> header</li><li>Server 回 <code>2xx</code> 的時候，送 <code>Cache-Control: private</code> header</li></ul><p><strong>Spec 不建議使用這種方法</strong>，如果真的沒辦法送 header 也沒辦法透過 request-body 送，再來考慮這種。</p><p>Resource Server 可以但不一定要支援這個方式。</p><p><em>本段參考 Section 2.4</em></p><h2 id="Resource-Server-向-Client-提示「認證不過，拒絕存取」的方式"><a href="#Resource-Server-向-Client-提示「認證不過，拒絕存取」的方式" class="headerlink" title="Resource Server 向 Client 提示「認證不過，拒絕存取」的方式"></a>Resource Server 向 Client 提示「認證不過，拒絕存取」的方式</h2><p>拒絕存取的情況，例如沒給 Access Token 或是給了但不合法（如空號、過期、Resource Owner 沒許可 Client 拿取此資料），則 Resource Server 必須在回應裡包含 <code>WWW-Authenticate</code> 的 header 來提示錯誤。這個 header 定義在 <a href="https://tools.ietf.org/html/rfc2617#section-3.2.1">RFC 2617 Section 3.2.1</a>。<code>WWW-Authenticate</code> 的值，使用的 auth-scheme 是 <code>Bearer</code> ，隨後一個空格，接著要有至少一個 auth-param 。</p><p>範例：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 401 UnauthorizedWWW-Authenticate: Bearer realm&#x3D;&quot;example&quot;,                  error&#x3D;&quot;invalid_token&quot;,                  error_description&#x3D;&quot;The access token expired&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>以下這些 auth-params 是 <code>WWW-Authenticate</code> 會用到的：</p><div class="table-container"><table><thead><tr><th>參數名</th><th>必/選</th><th>填什麼/意義</th></tr></thead><tbody><tr><td>realm</td><td>選用</td><td>見下文</td></tr><tr><td>scope</td><td>選用</td><td>提示所需權限，見下文</td></tr><tr><td>error</td><td>選用</td><td>有出示 Access Token 則最好有這個</td></tr></tbody></table></div><h3 id="realm"><a href="#realm" class="headerlink" title="realm"></a><code>realm</code></h3><p>用 <code>realm</code> 來指出需要授權才能存取的範圍，意義跟 <a href="https://tools.ietf.org/html/rfc2617">HTTP Authentication</a> 的 <code>realm</code> 一樣。<code>realm</code> 只能出現一次。</p><h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a><code>scope</code></h3><p>用 <code>scope</code> 來指出「要拿這個 Resource 需要出示具有哪些 scope 的 Access Token 」：</p><ul><li>要區分大小寫。</li><li>要以空白分隔。</li><li>可以用哪些 scope ，是看 Authorization Server 怎麼定義，Spec 不定義，也沒有登錄中心。</li><li>順序不重要。</li><li>是給程式看的，不是設計給使用者看的。</li></ul><p><code>scope</code> 還可以在向 Authorization Server 索取新 Access Token 的時候使用。</p><p><code>scope</code> 值只能出現一次。實際寫在 <code>scope</code> 裡面的單一個 scope 必須只能用以下的字元，定義在 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.4">RFC 6749 附錄 A.4</a> ：</p><pre class="line-numbers language-none"><code class="language-none">\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。空格當然也不能用，因為是用來區分不同 scopes 的。</p><h3 id="error"><a href="#error" class="headerlink" title="error"></a><code>error</code></h3><p>如果 Client 出示了 Access Token 但認證失敗，則最好加上 <code>error</code> 這個 auth-param ，用來告訴 Client 為何認證失敗。此外還可以加上 <code>error_description</code> 用自然語言來告訴開發者為什麼錯誤，但這個不該給使用者看到。此外也可以加上 <code>error_uri</code> 用來提供一個網址，裡面用自然語言解釋錯誤訊息。這三個 auth-param 都只能最多出現一次。</p><p>如果 request 沒有出示 Access Token （例如 Client 不知道需要認證，或是使用了不支援的認證方式（例如不支援 URI parameter）），則 response 不應該帶 <code>error</code> 或任何錯誤訊息。</p><p><code>error</code> 的值的意義以及推薦使用的 HTTP response code 如下：</p><div class="table-container"><table><thead><tr><th>值</th><th>Status Code</th><th>意義/用途</th></tr></thead><tbody><tr><td>invalid_request</td><td>400 Bad Request</td><td>沒提供必要的參數、提供了不支援的參數、提供了錯誤的參數值、同樣的參數出現多次、使用一種以上的方法來出示 Access Token （如放在 header 裡又放在 form 裡）、或是其他無法解讀 request 的情況。</td></tr><tr><td>invalid_token</td><td>401 Unauthorized</td><td>Access Token 過期、被收回授權、無法解讀、或其他 Access Token 不合法的情況。這種情況下， Client 可以重新申請一個 Access Token 並且用新的 Access Token 來重試 request 。</td></tr><tr><td>insufficient_scope</td><td>403 Forbidden</td><td>這個 request 需要出示比 Client 出示的 Access Token 代表的 scopes 還要更多的 scopes 。這種情況下，可以另外提供 <code>scope</code> auth-param 來具體指出需要哪些 scopes 。</td></tr></tbody></table></div><p><code>error</code> 和 <code>error_description</code> 的值必須只能用以下的字元，定義在 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.7">RFC 6749 附錄 A.7</a> 和 <a href="https://tools.ietf.org/html/rfc6749#appendix-A.8">RFC 6749 附錄 A.8</a>：</p><pre class="line-numbers language-none"><code class="language-none">\x20-\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即空格 (\x20) 再加上可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。</p><p><code>error_uri</code> 的值必須符合 <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a> 的定義，即是只能用以下的字元（同 <code>scope</code> 裡面的單一 scope）：</p><pre class="line-numbers language-none"><code class="language-none">\x21, \x23-\x5b, \x5d-\x7e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即可見的 US-ASCII 字元裡面，除了雙引號 <code>&quot;</code> (\x22) 和反斜線 <code>\</code> (\x5c) 以外。</p><p><em>本段參考 Section 3 及 Section 3.1</em></p><h2 id="Authorization-Server-給-Client-核發-Access-Token-的範例"><a href="#Authorization-Server-給-Client-核發-Access-Token-的範例" class="headerlink" title="Authorization Server 給 Client 核發 Access Token 的範例"></a>Authorization Server 給 Client 核發 Access Token 的範例</h2><p>既然是 OAuth 2.0 的 access token ，就通常是循 <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 的 spec</a> 來核發，範例如下：</p><pre class="line-numbers language-none"><code class="language-none">HTTP&#x2F;1.1 200 OKContent-Type: application&#x2F;json;charset&#x3D;UTF-8Cache-Control: no-storePragma: no-cache&#123;  &quot;access_token&quot;:&quot;mF_9.B5f-4.1JqM&quot;,  &quot;token_type&quot;:&quot;Bearer&quot;,  &quot;expires_in&quot;:3600,  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>本段參考 Section 4</em></p><h2 id="安全性問題與對策"><a href="#安全性問題與對策" class="headerlink" title="安全性問題與對策"></a>安全性問題與對策</h2><p>RFC 6750 是基於 OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a> 來寫的，所以在該 spec 裡面提過的安全性問題就不再提及。</p><p>原文將問題與問題對策分開成 Section 5.1 和 Section 5.2 ，我為了方便筆記，所以合併在一起。以下「壞人」的原文是 <em>attacker</em>。</p><h3 id="一般對策"><a href="#一般對策" class="headerlink" title="一般對策"></a>一般對策</h3><p>大部份的安全性問題可以透過數位簽章或是 MAC (Message Authentication Code) 來防護。</p><p>Authorization Server 必須有實作 TLS，版本則隨時間推移而不同。 spec 作成的時候， TLS 最新版是 1.2 ，但實務上很少使用，1.0 才是最為廣泛利用的。</p><h3 id="偽造或竄改-Access-Token-的問題"><a href="#偽造或竄改-Access-Token-的問題" class="headerlink" title="偽造或竄改 Access Token 的問題"></a>偽造或竄改 Access Token 的問題</h3><p>壞人可能會偽造或竄改既有的 Access Token （竄改指的是修改授權範圍或授權參數），讓 Resource Server 給予 Client 不適當的存取權。例如，壞人可能會延長 Token 的過期時間。或是惡意的 Client 變造聲明來看到它不應該看到的東西，例如，告訴使用者只拿取公開的個人資料，卻在取得授權時，另外拿了朋友名單。</p><p><em>Section 5.1 &gt; Token manufacture/modification</em></p><h4 id="對策"><a href="#對策" class="headerlink" title="對策"></a>對策</h4><p>對於 Bearer Token ，可以只加一個參照用的 id 來間接指到真正的授權資訊，而不是直接燒在 Token 裡面。這種間接參照用的 id ，必須要難以被猜到；但使用間接參照，因為要間接檢查授權資訊，所以可能會導致 Resource Server 和 Authorization Server 之間有額外的動作※。這種機制的細節，spec 裡面沒有定義。</p><p>Spec 沒有定義 token 的編碼方式，所以不提及保護 Token 的完整性 (integrity) 的詳細建議。若要實作保護完整性的措施，則該實作方式必須要可以防止 Token 被竄改。</p><p>※：原文是 <em>“between a server and the token issuer”</em></p><h3 id="Access-Token-傳輸過程外洩、曝露敏感資料的問題"><a href="#Access-Token-傳輸過程外洩、曝露敏感資料的問題" class="headerlink" title="Access Token 傳輸過程外洩、曝露敏感資料的問題"></a>Access Token 傳輸過程外洩、曝露敏感資料的問題</h3><p>Token 傳輸過程可能被監聽而外洩，或 Token 本身可能會包含敏感資料※。</p><p>※在 Section 5.1 原文提及 “token disclosure” 的時候，僅提及曝露敏感資料，沒提及傳輸過程的外洩，然而 5.2 裡面關於 “token disclosure” 的對策，有一併提及傳輸過程外洩（中間人攻擊、監聽等），所以我寫這一段時，同時提及傳輸外洩以及曝露敏感資料。</p><p><em>Section 5.1 &gt; Token disclosure</em></p><h4 id="對策-1"><a href="#對策-1" class="headerlink" title="對策"></a>對策</h4><p>為了防範 Token 在傳輸過程外洩，必須用 TLS 來實作機密防護，且該實作方式必須要使用有提供機密防護和完整性防護的加密方式，如此就能要求 Client 與 Authorization Server 和 Client 與 Resource Server 之間的通訊要有機密防護和完整性防護。因為 TLS 是這份 spec 裡面規定一定要實作的，所以利用 TLS 來達成通訊過程的機密防護和完整性防護，是比較偏好的做法。</p><p>如果要防止 Client 取得 Token 的內容，那麼除了 TLS 之外，還必須實作 Token 加密。</p><p>要進一步防範 Token 外洩，則 Client 在發 request 的時候，還必須要驗證 TLS 的憑證鏈 (certificate chain) ，包括檢查憑證有沒有被撤銷（Certificate Revocation List, RFC 5280）。</p><p>Cookie 通常是明文傳輸的 (in the clear)，所以任何寫在裡面的資訊都有外洩的風險。所以， Bearer Token 絕對不可以存放在明文傳輸 cookie 裡面。詳見 RFC 6265 (HTTP State Management Mechanism) 裡面關於 cookie 的安全性問題。</p><p>某些部署方式，好比說利用 Load Balancer 的，TLS 傳輸在抵達 Resource Server 之前就結束了。這樣子會導致 Token 在前端 Load Balaner 和後端實體 Resrouce Server 之間，沒有加密保護。這種情況下，必須實作足夠的手段※，來確保前端和後端 server 之間的資料保密。Token 加密也是一種方式。</p><p>※ 原文為 <em>sufficient measures</em>，我不會翻譯…</p><h3 id="挪用-Access-Token-的問題"><a href="#挪用-Access-Token-的問題" class="headerlink" title="挪用 Access Token 的問題"></a>挪用 Access Token 的問題</h3><p>壞人可能會把某個專門給 Resource Server A 的 Access Token ，挪用到 Resource Server B ，使得 B 誤信該 Access Token 可以拿來存取 B 的資料。</p><p><em>Section 5.1 &gt; Token redirect</em></p><h4 id="對策-2"><a href="#對策-2" class="headerlink" title="對策"></a>對策</h4><p>要防止 Token 被挪用，則這件事很重要：Authorization Server 核發的 Token 裡面要附上被核發人的資訊（通常是一或多部 Resource Server）。同時，也建議限制 Token 可以使用的 scope 範圍。</p><h3 id="二度利用-Access-Token-的問題"><a href="#二度利用-Access-Token-的問題" class="headerlink" title="二度利用 Access Token 的問題"></a>二度利用 Access Token 的問題</h3><p>壞人使用之前就存在的 Access Token 來存取 Reseouce Server （即：Token 被偷去用）。</p><p><em>Section 5.1 &gt; Token replay</em></p><h3 id="對策-3"><a href="#對策-3" class="headerlink" title="對策"></a>對策</h3><p>要防止 Token 被偷走並且拿來二度利用，建議採用以下方案：</p><ol><li>Token 的存活時間必須被限制住。一種手段是在 Token 受保護的區段裡面，設一個合法期間。使用短時效的 Token （如一小時以下）可以降低 Token 外洩的風險。</li></ol><ul><li>Token 在 Client ↔ Authorization Server 、 Client ↔ Resource Server 之間交換的時候，必須要實作機密防護。如此一來，就算在傳輸途徑上監聽，也無法獲得 Token ，也就無法二度利用。</li><li>Client 要向 Resource Server 出示 Token 的時候，Client 必須驗證 Resource Server 的真實身份，如 RFC 2818 (TLS) 的 Section 3.1 裡面所述。注意，Client 必須要驗證 TLS 憑證的憑證鏈 (certificate chain)。若 Resource Server 未經授權且未通過認證，或是憑證鏈驗證失敗，這時候向它出示 Token ，會導致敵手取得 Token 並且得到未經授權的權限來存取受保護的 resource。</li></ul><h2 id="安全性建議的總結"><a href="#安全性建議的總結" class="headerlink" title="安全性建議的總結"></a>安全性建議的總結</h2><p><em>Section 5.3 Summary of Recommendations</em></p><h3 id="要藏好-Bearer-Token"><a href="#要藏好-Bearer-Token" class="headerlink" title="要藏好 Bearer Token"></a>要藏好 Bearer Token</h3><p>Client 實作必須確保 Bearer Token 不會外洩給無關人士，因為他們可以以此來存取受保護的 resources。利用 Bearer Token 時，這是首要的安全性考量，且優先於其他更細節的建議。</p><h3 id="要驗證-TLS-的憑證鏈"><a href="#要驗證-TLS-的憑證鏈" class="headerlink" title="要驗證 TLS 的憑證鏈"></a>要驗證 TLS 的憑證鏈</h3><p>當 Client 發 request 索取受保護的 resources 的時候，Client 必須驗證 TLS 的憑證鏈。若做不到的話，可能會引發 DNS 劫持，導致 Token 被壞人偷走。</p><h3 id="全程使用-TLS-https"><a href="#全程使用-TLS-https" class="headerlink" title="全程使用 TLS (https)"></a>全程使用 TLS (https)</h3><p>當 Clients 利用 Bearer Token 發 request 時，Client 必須一直使用 TLS (RFC5246) (https) 或同等的安全傳輸。若做不到的話， Token 會曝露在各種攻擊方式，讓壞人可以得到意料之外的存取權。</p><h3 id="不要把-Bearer-Token-存在-Cookie"><a href="#不要把-Bearer-Token-存在-Cookie" class="headerlink" title="不要把 Bearer Token 存在 Cookie"></a>不要把 Bearer Token 存在 Cookie</h3><p>絕對不可以把 Bearer Token 存在可以明文傳輸 (sent in the clear) 的 Cookie 裡面（明文傳輸是 cookie 傳輸的預設方式）。若存在 Cookie 裡面，必須要小心 Cross-Site Request Forgery 。</p><h3 id="要核發短時效的-Bearer-Token"><a href="#要核發短時效的-Bearer-Token" class="headerlink" title="要核發短時效的 Bearer Token"></a>要核發短時效的 Bearer Token</h3><p>核發 Token 的伺服器最好是核發短時效的 Bearer Token （一小時以內），尤其是發給跑在瀏覽器裡面的 Client ，或是其他容易發生資訊外洩的場合。利用短時效的 Bearer Token 可以降低 Token 外洩時的衝擊。</p><h3 id="要核發有區分使用範圍的-Bearer-Token"><a href="#要核發有區分使用範圍的-Bearer-Token" class="headerlink" title="要核發有區分使用範圍的 Bearer Token"></a>要核發有區分使用範圍的 Bearer Token</h3><p>Token 伺服器最好要核發包含 audience restriction, scoping their use to the intended replying party, or set of relying party 的 Token 。</p><h3 id="不要用-Page-URL-來傳送-Bearer-Token"><a href="#不要用-Page-URL-來傳送-Bearer-Token" class="headerlink" title="不要用 Page URL 來傳送 Bearer Token"></a>不要用 Page URL 來傳送 Bearer Token</h3><p>Bearer Token 最好不要從 URL 來傳送（例如 query parameter），而最好是從有保密措施的 HTTP header 或是 body 來傳輸※。瀏覽器、伺服器等軟體可能不會把歷史記錄或資料結構給妥善加密。如果 Bearer Token 透過 URL 傳輸，則壞人就有可能可以從歷史記錄取得之。</p><p>※ <em>“be passed in HTTP message headers or message bodies for which confidentiality measures are taken”</em></p><hr><h2 id="OAuth-2-0-系列文目錄"><a href="#OAuth-2-0-系列文目錄" class="headerlink" title="OAuth 2.0 系列文目錄"></a>OAuth 2.0 系列文目錄</h2><ul><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-1-introduction/">(1) 世界觀</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-2-cilent-registration/">(2) Client 的註冊與認證</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-3-endpoints/">(3) Endpoints 的規格</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-1-auth-code-grant-flow/">(4.1) Authorization Code Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-2-implicit-grant-flow/">(4.2) Implicit Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-3-resource-owner-credentials-grant-flow/">(4.3) Resource Owner Credentials Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-4-4-client-credentials-grant-flow/">(4.4) Client Credentials Grant Flow 細節</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-5-issuing-tokens/">(5) 核發與換發 Access Token</a></li><li><strong><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-6-bearer-token/">(6) Bearer Token 的使用方法</a> ← You Are Here</strong></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-7-security-considerations/">(7) 安全性問題</a></li><li><a href="https://blog.yorkxin.org/posts/2013/09/30/oauth2-implementation-differences-among-famous-sites/">各大網站 OAuth 2.0 實作差異</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OAuth </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法速查表</title>
      <link href="/2022/05/25/markdown-yu-fa-su-cha-biao/"/>
      <url>/2022/05/25/markdown-yu-fa-su-cha-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法速查表"><a href="#Markdown-语法速查表" class="headerlink" title="Markdown 语法速查表"></a>Markdown 语法速查表</h1><p>Markdown 语法参考手册 / 速查表。</p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>此 Markdown 语法速查表提供了所有 Markdown 语法元素的快速参考。但是此速查表无法涵盖所有极限用法，因此，如果您需要某些语法元素的详细信息，请参阅我们的 <a href="https://www.markdown.xyz/basic-syntax">基本语法</a> 和 <a href="https://www.markdown.xyz/extended-syntax">扩展语法</a> 手册。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>这些是 John Gruber 的原始设计文档中列出的元素。所有 Markdown 应用程序都支持这些元素。</p><div class="table-container"><table><thead><tr><th>元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><a href="https://www.markdown.xyz/basic-syntax/#headings">标题（Heading）</a></td><td><code># H1## H2### H3</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#bold">粗体（Bold）</a></td><td><code>**bold text**</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#italic">斜体（Italic）</a></td><td><code>*italicized text*</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#blockquotes-1">引用块（Blockquote）</a></td><td><code>&gt; blockquote</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#ordered-lists">有序列表（Ordered List）</a></td><td><code>1. First item2. Second item3. Third item</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#unordered-lists">无序列表（Unordered List）</a></td><td><code>- First item- Second item- Third item</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#code">代码（Code）</a></td><td><code>code</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#horizontal-rules">分隔线（Horizontal Rule）</a></td><td><code>---</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#links">链接（Link）</a></td><td><code>[title](https://www.example.com)</code></td></tr><tr><td><a href="https://www.markdown.xyz/basic-syntax/#images">图片（Image）</a></td><td><code>![alt text](image.jpg)</code></td></tr></tbody></table></div><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>这些元素通过添加额外的功能扩展了基本语法。但是，并非所有 Markdown 应用程序都支持这些元素。</p><div class="table-container"><table><thead><tr><th>元素</th><th>Markdown 语法</th></tr></thead><tbody><tr><td><a href="https://www.markdown.xyz/extended-syntax/#tables">表格（Table）</a></td><td>&#124; Syntax &#124; Description &#124;<br>&#124; —————- &#124; —————- &#124;<br>&#124; Header &#124; Title &#124;<br>&#124; Paragraph &#124; Text &#124;</td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#fenced-code-blocks">代码块（Fenced Code Block）</a></td><td><code>&#123; &quot;firstName&quot;: &quot;John&quot;, &quot;lastName&quot;: &quot;Smith&quot;, &quot;age&quot;: 25&#125;</code></td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#footnotes">脚注（Footnote）</a></td><td><code>Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote.</code></td></tr><tr><td><a href="https://www.markdown.xyz/extended-syntax/#heading-ids">标题编号（Heading ID）</a></td><td>`### My Great Heading </td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 扩展语法</title>
      <link href="/2022/05/25/markdown-kuo-zhan-yu-fa/"/>
      <url>/2022/05/25/markdown-kuo-zhan-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-扩展语法"><a href="#Markdown-扩展语法" class="headerlink" title="Markdown 扩展语法"></a>Markdown 扩展语法</h1><p>构建在 Markdown 基本语法上的扩展功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>即便 John Gruber 的原始设计文档中所列出的 <a href="https://www.markdown.xyz/basic-syntax">Markdown 基本语法</a> 已经囊括了许多满足日常所需的元素，但对于某些人来说仍然不够。这就是 Markdown 扩展语法出现的缘由。</p><p>一些个人和组织通过添加表格（tables）、代码块（code blocks）、语法高亮、将 URL 自动转换为链接和脚注（footnotes）等额外的元素来扩展 Markdown 的基本语法。这些额外添加的元素可以通过使用构建于 Markdown 之上的轻量级标记语言或通过向兼容的 Markdown 解析器添加扩展来启用这些新元素。</p><h2 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h2><p>并非所有的 Markdown 应用程序都支持扩展语法。你需要确认你所使用的应用程序是否支持你所需要使用的扩展语法。如果不支持，则有可能是需要开启相应的扩展模块。</p><h3 id="轻量级标记语言"><a href="#轻量级标记语言" class="headerlink" title="轻量级标记语言"></a>轻量级标记语言</h3><p>目前有几种轻量级标记语言是 Markdown 的 <em>超集</em> 。它们支持 Gruber 的基本语法，并在其基础上添加了一些额外的元素，例如表格（tables）、代码块（code blocks）、语法高亮、将 URL 自动转换为链接和脚注（footnotes）。许多流行的 Markdown 应用程序能够支持以下列出的某个轻量级标记语言：</p><ul><li><a href="https://commonmark.org/">CommonMark</a></li><li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown (GFM)</a></li><li><a href="https://michelf.ca/projects/php-markdown/extra/">Markdown Extra</a></li><li><a href="https://fletcherpenney.net/multimarkdown/">MultiMarkdown</a></li><li><a href="https://rmarkdown.rstudio.com/">R Markdown</a></li></ul><h3 id="Markdown-解析器"><a href="#Markdown-解析器" class="headerlink" title="Markdown 解析器"></a>Markdown 解析器</h3><p>目前可用的 <a href="https://github.com/markdown/markdown.github.com/wiki/Implementations">Markdown 解析器有数十个</a> 。其中许多都可以通过添加扩展模块的方式来支持 Markdown 扩展语法。请查看你所使用的 Markdown 解析器的文档以了解更多信息。</p><h2 id="表格（Tables）"><a href="#表格（Tables）" class="headerlink" title="表格（Tables）"></a>表格（Tables）</h2><p>如需添加表格，请使用三个或更多个连字符（<code>---</code>）来为每个列创建表头，并使用管道符（<code>|</code>）来分隔每个列。为兼容考虑，你还应该在行的两侧添加管道符。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>单元格（cell）宽度是可变的，如下所示。渲染效果相同。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax | Description || --- | ----------- || Header | Title || Paragraph | Text |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong> 使用连字符（hyphens）和管道符（pipes）创建表格会很乏味。若要加快进度，请试一试 <a href="https://www.tablesgenerator.com/markdown_tables">Markdown 表格生成器</a>。使用图形界面生成表格，然后将生成的 Markdown 格式的文本复制粘贴到文件中即可。</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>通过在标题行中的连字符（hyphens）的左侧或右侧或两侧添加冒号（<code>:</code>），可以将对应列中的文本向左或向右或居中对齐。</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description | Test Text     || :---        |    :----:   |          ---: || Header      | Title       | Here&#39;s this   || Paragraph   | Text        | And more      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><h3 id="格式化表格中的文本"><a href="#格式化表格中的文本" class="headerlink" title="格式化表格中的文本"></a>格式化表格中的文本</h3><p>你可以为表格中的文本设置格式。例如，可以添加 <a href="https://www.markdown.xyz/basic-syntax/#links">链接（links）</a>、<a href="https://www.markdown.xyz/basic-syntax/#code-1">代码（code）</a> （注意，只能为单词或短语添加反引号 (```) ，不能添加 <a href="https://www.markdown.xyz/basic-syntax/#code-blocks">代码块（code blocks）</a>）以及 <a href="https://www.markdown.xyz/basic-syntax/#emphasis">强调（emphasis）</a>。</p><p>不支持的格式包括标题（headings）、块引用（blockquotes）、列表（lists）、水平分割线（horizontal rules）、图片（images）或 HTML 标记。</p><h3 id="转义表格中出现的管道符（Pipe-Characters）"><a href="#转义表格中出现的管道符（Pipe-Characters）" class="headerlink" title="转义表格中出现的管道符（Pipe Characters）"></a>转义表格中出现的管道符（Pipe Characters）</h3><p>如需在表格中显示管道符 (<code>|</code>)，你可以使用管道符的 HTML 字符编码（<code>|</code>）来实现。</p><h2 id="围栏代码块（Fenced-Code-Blocks）"><a href="#围栏代码块（Fenced-Code-Blocks）" class="headerlink" title="围栏代码块（Fenced Code Blocks）"></a>围栏代码块（Fenced Code Blocks）</h2><p>Markdown 的基本语法允许你通过缩进四个空格或一个制表符来创建 <a href="https://www.markdown.xyz/basic-syntax#code-blocks">代码块</a> 。如果你觉得不方便，可以试试围栏代码块（fenced code blocks）。根据 Markdown 解析器或编辑器的不同，代码块的前后可以使用三个反引号（<code>````）或三个波浪号（</code>~~~`）来标记围栏代码块。这有什么优势吗？你不必费力缩进任何行了！</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong> 需要在代码块中显示反引号（backticks）吗？请参见 <a href="https://www.markdown.xyz/basic-syntax/#escaping-backticks">这一章节</a> 以了解如何对其进行转义。</p><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>许多 Markdown 解析器都支持围栏代码块的语法高亮功能。此功能允许你为编写代码所用的编程语言添加带颜色的语法高亮显示。如需添加语法高亮，请在围栏代码块前的反引号旁指定所用的编程语言。</p><pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;json&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;&#96;&#96;&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;  &quot;firstName&quot;: &quot;John&quot;,  &quot;lastName&quot;: &quot;Smith&quot;,  &quot;age&quot;: 25&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="脚注（Footnotes）"><a href="#脚注（Footnotes）" class="headerlink" title="脚注（Footnotes）"></a>脚注（Footnotes）</h2><p>脚注（Footnotes）允许你添加注释（notes）和引用（references），而不会使文档正文混乱。当你创建脚注时，带有链接的上标数字会出现在你引用脚注的位置。 读者可以单击链接以跳转至页面底部的脚注内容处。</p><p>要创建一个脚注的引用，请在方括号中添加一个插入符（caret）以及一个标识符，标识符可以是数字或单词，但不能包含空格或制表符。标识符的作用仅是将脚注的引用和脚注本身进行关联，在输出中，脚注按顺序编号。</p><p>另一种创建脚注的方式是在方括号内添加一个插入符（caret）以及一个数字，后面跟着冒号和文本，即（<code>[^1]: My footnote.</code>）。这种方式让你不必在文档末尾添加脚注。你可以将脚注放到除列表（lists）、块引用（block quotes）和表格（tables）之外的任何位置上。</p><pre class="line-numbers language-none"><code class="language-none">Here&#39;s a simple footnote,[^1] and here&#39;s a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here&#39;s one with multiple paragraphs and code.    Indent paragraphs to include them in the footnote.    &#96;&#123; my code &#125;&#96;    Add as many paragraphs as you like.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p>Here’s a simple footnote,<a href="https://www.markdown.xyz/extended-syntax/#fn:1">1</a> and here’s a longer one.<a href="https://www.markdown.xyz/extended-syntax/#fn:bignote">2</a></p><ol><li><p>This is the first footnote. <a href="https://www.markdown.xyz/extended-syntax/#fnref:1">↩</a></p></li><li><p>Here’s one with multiple paragraphs and code.</p><p>Indent paragraphs to include them in the footnote.</p><p><code>&#123; my code &#125;</code></p><p>Add as many paragraphs as you like. <a href="https://www.markdown.xyz/extended-syntax/#fnref:bignote">↩</a></p></li></ol><h2 id="自定义标题的-ID"><a href="#自定义标题的-ID" class="headerlink" title="自定义标题的 ID"></a>自定义标题的 ID</h2><p>许多 Markdown 解析器都支持为 <a href="https://www.markdown.xyz/basic-syntax/#headings">标题（headings）</a> 自定义 ID，某些 Markdown 解析器会自动为标题添加 ID。通过添加自定义 ID， 能够让你直接链接到这个标题，并且还能使用 CSS 修改其样式。如需为标题添加自定义 ID，请将自定义 ID 用花括号括起来并与标题一起放在同一行。</p><pre class="line-numbers language-none"><code class="language-none">### My Great Heading &#123;#custom-id&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的 HTML 如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&lt;h3 id&#x3D;&quot;custom-id&quot;&gt;My Great Heading&lt;&#x2F;h3&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>###链接到标题的 ID</p><p>你可以在文档中创建一个 <a href="https://www.markdown.xyz/basic-syntax/#links">标准链接</a> ，其后是井号（<code>#</code>）和自定义的标题 ID ，从而链接到这个标题。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>[Heading IDs](#heading-ids)</code></td><td><code>&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;</code></td><td><a href="https://www.markdown.xyz/extended-syntax/#heading-ids">Heading IDs</a></td></tr></tbody></table></div><p>其它网站也可以通过将自定义的标题 ID 添加到网页的完整的 URL 后面来链接到对应的标题（例如，<code>[Heading IDs](https://www.markdown.xyz/extended-syntax#heading-ids)</code>）。</p><h2 id="定义列表（Definition-Lists）"><a href="#定义列表（Definition-Lists）" class="headerlink" title="定义列表（Definition Lists）"></a>定义列表（Definition Lists）</h2><p>某些 Markdown 解析器允许你创建术语（terms）及其相应的定义（definitions）的列表，即 <em>定义列表（definition lists）</em>。要创建定义列表，请在第一行键入术语，然后在下一行中键入冒号，冒号后跟着空格和此术语的具体定义。</p><pre class="line-numbers language-none"><code class="language-none">First Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的 HTML 如下所示：</p><pre class="line-numbers language-none"><code class="language-none">&lt;dl&gt;  &lt;dt&gt;First Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is the definition of the first term.&lt;&#x2F;dd&gt;  &lt;dt&gt;Second Term&lt;&#x2F;dt&gt;  &lt;dd&gt;This is one definition of the second term. &lt;&#x2F;dd&gt;  &lt;dd&gt;This is another definition of the second term.&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><ul><li><p>First Term</p><p>This is the definition of the first term.</p></li><li><p>Second Term</p><p>This is one definition of the second term.</p><p>This is another definition of the second term.</p></li></ul><h2 id="删除线（Strikethrough）"><a href="#删除线（Strikethrough）" class="headerlink" title="删除线（Strikethrough）"></a>删除线（Strikethrough）</h2><p>你可以贯穿单词的中心放一条横线从而删除这些单词。其效果看起来是这样的： <del>like this</del>。此功能允许你标记某些单词是错误的，不应该出现在文档中。在单词前面和后面分别放置两个波浪号（<code>~~</code>） 来表示删除这些单词。</p><pre class="line-numbers language-none"><code class="language-none">~~The world is flat.~~ We now know that the world is round.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><p><del>The world is flat.</del> We now know that the world is round.</p><h2 id="任务列表（Task-Lists）"><a href="#任务列表（Task-Lists）" class="headerlink" title="任务列表（Task Lists）"></a>任务列表（Task Lists）</h2><p>任务列表（task lists 或者 checklists）允许你创建带有复选框的项目列表。在支持任务列表的 Markdown 应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项前面添加破折号（<code>-</code>）和中间带空格的方括号（<code>[ ]</code>）。要选中复选框，请在方括号中间添加一个 <code>x</code> ，即（<code>[x]</code>）。</p><pre class="line-numbers language-none"><code class="language-none">- [x] Write the press release- [ ] Update the website- [ ] Contact the media<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p><img src="https://www.markdown.xyz/assets/images/tasklist.png" alt="Markdown task list"></p><h2 id="表情符号（Emoji）"><a href="#表情符号（Emoji）" class="headerlink" title="表情符号（Emoji）"></a>表情符号（Emoji）</h2><p>有两种方式可以将表情符号添加到 Markdown 文档中：将表情符号复制并粘贴到 Markdown 格式的文本中，或者键入 <em>表情符号的简码（emoji shortcodes）</em>。</p><h3 id="复制并粘贴表情符号"><a href="#复制并粘贴表情符号" class="headerlink" title="复制并粘贴表情符号"></a>复制并粘贴表情符号</h3><p>在大多数情况下，你可以简单地从 <a href="https://emojipedia.org/">Emojipedia</a> 等来源复制表情符号，然后将其粘贴到文档中。许多 Markdown 应用程序就会自动以 Markdown 格式的文本来显示表情符号。从 Markdown 应用程序导出的 HTML 和 PDF 文件也是可以显示表情符号的。</p><p><strong>提示：</strong> 如果你使用的是静态站点生成器，请确保 <a href="https://www.w3.org/International/tutorials/tutorial-char-enc/">HTML 页面的字符编码为 UTF-8</a>。</p><h3 id="使用表情符号的简码（Shortcodes）"><a href="#使用表情符号的简码（Shortcodes）" class="headerlink" title="使用表情符号的简码（Shortcodes）"></a>使用表情符号的简码（Shortcodes）</h3><p>某些 Markdown 应用程序允许你通过键入表情符号的简码（shortcodes）来插入表情符号。简码以冒号开头和结尾，两个冒号中间是表情符号的名称。</p><pre class="line-numbers language-none"><code class="language-none">Gone camping! :tent: Be back soon.That is so funny! :joy:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下所示：</p><p>Gone camping! ⛺ Be back soon.</p><p>That is so funny! 😂</p><p><strong>注意：</strong> 你可以使用这个 <a href="https://gist.github.com/rxaviers/7360908">表情符号简码列表</a>，但请记住，表情符号的简码随着 Markdown 应用程序的不同而不同。有关详细信息，请参阅你所使用的 Markdown 应用程序的文档。</p><h2 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight"></a>Highlight</h2><p>This isn’t common, but some Markdown processors allow you to highlight text. The result looks like this. To highlight words, use two equal signs (<code>==</code>) before and after the words.</p><pre class="line-numbers language-none"><code class="language-none">I need to highlight these &#x3D;&#x3D;very important words&#x3D;&#x3D;.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">I need to highlight these &lt;mark&gt;very important words&lt;&#x2F;mark&gt;.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>I need to highlight these very important words.</p><h2 id="Subscript"><a href="#Subscript" class="headerlink" title="Subscript"></a>Subscript</h2><p>This isn’t common, but some Markdown processors allow you to use <em>subscript</em> to position one or more characters slightly below the normal line of type. To create a subscript, use one tilde symbol (<code>~</code>) before and after the characters.</p><pre class="line-numbers language-none"><code class="language-none">H~2~O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">H&lt;sub&gt;2&lt;&#x2F;sub&gt;O<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>H2O</p><p><strong>Tip:</strong> Be sure to test this feature in your Markdown application before using it. Some Markdown applications use one tilde symbol before and after words not for subscript, but for <a href="https://www.markdown.xyz/extended-syntax/#strikethrough">strikethrough</a>.</p><h2 id="Superscript"><a href="#Superscript" class="headerlink" title="Superscript"></a>Superscript</h2><p>This isn’t common, but some Markdown processors allow you to use <em>superscript</em> to position one or more characters slightly above the normal line of type. To create a superscript, use one caret symbol (<code>^</code>) before and after the characters.</p><pre class="line-numbers language-none"><code class="language-none">X^2^<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The HTML looks like this:</p><pre class="line-numbers language-none"><code class="language-none">X&lt;sup&gt;2&lt;&#x2F;sup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The rendered output looks like this:</p><p>X2</p><h2 id="自动将-URL-转换为链接"><a href="#自动将-URL-转换为链接" class="headerlink" title="自动将 URL 转换为链接"></a>自动将 URL 转换为链接</h2><p>许多 Markdown 解析器会自动将 URL 转换为链接。这意味着，即使你没有 <a href="https://www.markdown.xyz/basic-syntax/#links">使用中括号</a>，如果你输入 <a href="http://www.example.com，你的">http://www.example.com，你的</a> Markdown 解析器也会自动将其转换为链接。</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><p><a href="http://www.example.com/">http://www.example.com</a></p><h2 id="禁止自动将-URL-转换为链接"><a href="#禁止自动将-URL-转换为链接" class="headerlink" title="禁止自动将 URL 转换为链接"></a>禁止自动将 URL 转换为链接</h2><p>如果你不希望自动将 URL 转换为链接，则可以通过反引号 <a href="https://www.markdown.xyz/basic-syntax/#code">将 URL 表示为代码</a> 。</p><pre class="line-numbers language-none"><code class="language-none">&#96;http:&#x2F;&#x2F;www.example.com&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2022/05/25/markdown-ji-ben-yu-fa/"/>
      <url>/2022/05/25/markdown-ji-ben-yu-fa/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.markdown.xyz/basic-syntax/">原文链接</a></p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>几乎所有 Markdown 应用程序都支持 John Gruber 原始设计文档中列出的 Markdown 基本语法。但是，Markdown 处理程序之间存在着细微的变化和差异，我们都会尽可能标记出来。</p><h2 id="标题（Headings）"><a href="#标题（Headings）" class="headerlink" title="标题（Headings）"></a>标题（Headings）</h2><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。井号的数量代表了标题的级别。例如，添加三个井号即创建一个三级标题 (<code>&lt;h3&gt;</code>) (例如：<code>### My Header</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code># Heading level 1</code></td><td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td>Heading level 1</td></tr><tr><td><code>## Heading level 2</code></td><td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td>Heading level 2</td></tr><tr><td><code>### Heading level 3</code></td><td><code>&lt;h3&gt;Heading level 3&lt;/h3&gt;</code></td><td>Heading level 3</td></tr><tr><td><code>#### Heading level 4</code></td><td><code>&lt;h4&gt;Heading level 4&lt;/h4&gt;</code></td><td>Heading level 4</td></tr><tr><td><code>##### Heading level 5</code></td><td><code>&lt;h5&gt;Heading level 5&lt;/h5&gt;</code></td><td>Heading level 5</td></tr><tr><td><code>###### Heading level 6</code></td><td><code>&lt;h6&gt;Heading level 6&lt;/h6&gt;</code></td><td>Heading level 6</td></tr></tbody></table></div><h3 id="可选语法"><a href="#可选语法" class="headerlink" title="可选语法"></a>可选语法</h3><p>还可以在文本下方添加任意数量的 <code>==</code> 号来标识一级标题，或者 <code>--</code> 号来标识二级标题。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Heading level 1===============</code></td><td><code>&lt;h1&gt;Heading level 1&lt;/h1&gt;</code></td><td>Heading level 1</td></tr><tr><td><code>Heading level 2---------------</code></td><td><code>&lt;h2&gt;Heading level 2&lt;/h2&gt;</code></td><td>Heading level 2</td></tr></tbody></table></div><h3 id="标题（Heading）用法的最佳实践"><a href="#标题（Heading）用法的最佳实践" class="headerlink" title="标题（Heading）用法的最佳实践"></a>标题（Heading）用法的最佳实践</h3><p>当井号（<code>#</code>）和标题文本之间没有空格时，各 Markdown 应用程序的处理方式是不一样的。为了兼容考虑，请在井号和标题文本之间添加一个空格。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code># Here&#39;s a Heading</code></td><td><code>#Here&#39;s a Heading</code></td></tr></tbody></table></div><p>You should also put blank lines before and after a heading for compatibility.</p><div class="table-container"><table><thead><tr><th>✅ Do this</th><th>❌ Don’t do this</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...# Heading...and after a heading.</code></td><td><code>Without blank lines, this might not look right.# HeadingDon&#39;t do this!</code></td></tr></tbody></table></div><h2 id="段落（Paragraphs）"><a href="#段落（Paragraphs）" class="headerlink" title="段落（Paragraphs）"></a>段落（Paragraphs）</h2><p>要创建段落，请使用空白行将一行或多行文本进行分隔。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>I really like using Markdown.I think I&#39;ll use it to format all of my documents from now on.</code></td><td><code>&lt;p&gt;I really like using Markdown.&lt;/p&gt;&lt;p&gt;I think I&#39;ll use it to format all of my documents from now on.&lt;/p&gt;</code></td><td>I really like using Markdown.I think I’ll use it to format all of my documents from now on.</td></tr></tbody></table></div><h3 id="段落（Paragraph）用法的最佳实践"><a href="#段落（Paragraph）用法的最佳实践" class="headerlink" title="段落（Paragraph）用法的最佳实践"></a>段落（Paragraph）用法的最佳实践</h3><p>除非 <a href="https://www.markdown.xyz/basic-syntax/#paragraphs">段落在列表中</a>，否则不要用空格（spaces）或制表符（ tabs）缩进段落。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Don&#39;t put tabs or spaces in front of your paragraphs.Keep lines left-aligned like this.</code></td><td><code>This can result in unexpected formatting problems. Don&#39;t add tabs or spaces in front of paragraphs.</code></td></tr></tbody></table></div><h2 id="换行（Line-Breaks）"><a href="#换行（Line-Breaks）" class="headerlink" title="换行（Line Breaks）"></a>换行（Line Breaks）</h2><p>在一行的末尾添加两个或多个空格，然后按回车键（return），即可创建一个换行（line break）或新行 (<code>&lt;br&gt;</code>)。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>This is the first line.  And this is the second line.</code></td><td><code>&lt;p&gt;This is the first line.&lt;br&gt;And this is the second line.&lt;/p&gt;</code></td><td>This is the first line. And this is the second line.</td></tr></tbody></table></div><h3 id="换行（Line-Break）用法的最佳实践"><a href="#换行（Line-Break）用法的最佳实践" class="headerlink" title="换行（Line Break）用法的最佳实践"></a>换行（Line Break）用法的最佳实践</h3><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行 (称为 “结尾空格（trailing whitespace）”) 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能需要使用除结尾空格以外的其它方式来进行换行。如果你所使用的 Markdown 应用程序 <a href="https://www.markdown.xyz/basic-syntax/#html">支持 HTML</a> 的话，你可以使用 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>为了兼容性，请在行尾添加“结尾空格”或 HTML 的 <code>&lt;br&gt;</code> 标签来实现换行。</p><p>还有两种其他方式我并不推荐使用。CommonMark 和其它几种轻量级标记语言支持在行尾添加反斜杠 (<code>\</code>) 的方式实现换行，但是并非所有 Markdown 应用程序都支持此种方式，因此从兼容性的角度来看，不推荐使用。并且至少有两种轻量级标记语言支持无须在行尾添加任何内容，只须键入回车键（ return）即可实现换行。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>First line with two spaces after.  And the next line.First line with the HTML tag after.&lt;br&gt;And the next line.</code></td><td><code>First line with a backslash after.\And the next line.First line with nothing after.And the next line.</code></td></tr></tbody></table></div><h2 id="强调（Emphasis）"><a href="#强调（Emphasis）" class="headerlink" title="强调（Emphasis）"></a>强调（Emphasis）</h2><p>通过将文本设置为粗体或斜体来强调其重要性。</p><h3 id="粗体（Bold）"><a href="#粗体（Bold）" class="headerlink" title="粗体（Bold）"></a>粗体（Bold）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号（asterisks）或下划线（underscores）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>I just love **bold text**.</code></td><td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td><td>I just love <strong>bold text</strong>.</td></tr><tr><td><code>I just love __bold text__.</code></td><td><code>I just love &lt;strong&gt;bold text&lt;/strong&gt;.</code></td><td>I just love <strong>bold text</strong>.</td></tr><tr><td><code>Love**is**bold</code></td><td><code>Love&lt;strong&gt;is&lt;/strong&gt;bold</code></td><td>Love<strong>is</strong>bold</td></tr></tbody></table></div><h4 id="粗体（Bold）用法最佳实践"><a href="#粗体（Bold）用法最佳实践" class="headerlink" title="粗体（Bold）用法最佳实践"></a>粗体（Bold）用法最佳实践</h4><p>Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Love**is**bold</code></td><td><code>Love__is__bold</code></td></tr></tbody></table></div><h3 id="斜体（Italic）"><a href="#斜体（Italic）" class="headerlink" title="斜体（Italic）"></a>斜体（Italic）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）或下划线（underscore）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Italicized text is the *cat&#39;s meow*.</code></td><td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td><td>Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td><code>Italicized text is the _cat&#39;s meow_.</code></td><td><code>Italicized text is the &lt;em&gt;cat&#39;s meow&lt;/em&gt;.</code></td><td>Italicized text is the <em>cat’s meow</em>.</td></tr><tr><td><code>A*cat*meow</code></td><td><code>A&lt;em&gt;cat&lt;/em&gt;meow</code></td><td>A<em>cat</em>meow</td></tr></tbody></table></div><h4 id="斜体（Italic）用法的最佳实践"><a href="#斜体（Italic）用法的最佳实践" class="headerlink" title="斜体（Italic）用法的最佳实践"></a>斜体（Italic）用法的最佳实践</h4><p>Markdown 的众多应用程序在如何处理单词中间的下划线上意见不一致。为了兼容起见，请用星号标注单词中间的斜体来表示着重。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>A*cat*meow</code></td><td><code>A_cat_meow</code></td></tr></tbody></table></div><h3 id="粗体（Bold）和斜体（Italic）"><a href="#粗体（Bold）和斜体（Italic）" class="headerlink" title="粗体（Bold）和斜体（Italic）"></a>粗体（Bold）和斜体（Italic）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>This text is ***really important***.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is ___really important___.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is __*really important*__.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This text is **_really important_**.</code></td><td><code>This text is &lt;strong&gt;&lt;em&gt;really important&lt;/em&gt;&lt;/strong&gt;.</code></td><td>This text is <strong><em>really important\</em></strong>.</td></tr><tr><td><code>This is really***very***important text.</code></td><td><code>This is really&lt;strong&gt;&lt;em&gt;very&lt;/em&gt;&lt;/strong&gt;important text.</code></td><td>This is really<strong><em>very\</em></strong>important text.</td></tr></tbody></table></div><h4 id="粗体（Bold）和斜体（Italic）用法的最佳实践"><a href="#粗体（Bold）和斜体（Italic）用法的最佳实践" class="headerlink" title="粗体（Bold）和斜体（Italic）用法的最佳实践"></a>粗体（Bold）和斜体（Italic）用法的最佳实践</h4><p>Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用星号将单词或短语的中间部分加粗并以斜体显示，以示重要。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>This is really***very***important text.</code></td><td><code>This is really___very___important text.</code></td></tr></tbody></table></div><h2 id="块引用（Blockquotes）"><a href="#块引用（Blockquotes）" class="headerlink" title="块引用（Blockquotes）"></a>块引用（Blockquotes）</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下所示：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p></blockquote><h3 id="多个段落的块引用（Blockquotes）"><a href="#多个段落的块引用（Blockquotes）" class="headerlink" title="多个段落的块引用（Blockquotes）"></a>多个段落的块引用（Blockquotes）</h3><p>块引用可以包含多个段落。为段落之间的空白行各添加一个 <code>&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote><h3 id="嵌套块引用（Nested-Blockquotes）"><a href="#嵌套块引用（Nested-Blockquotes）" class="headerlink" title="嵌套块引用（Nested Blockquotes）"></a>嵌套块引用（Nested Blockquotes）</h3><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><pre class="line-numbers language-none"><code class="language-none">&gt; Dorothy followed her through many of the beautiful rooms in her castle.&gt;&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><p>Dorothy followed her through many of the beautiful rooms in her castle.</p><blockquote><p>The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</p></blockquote></blockquote><h3 id="带有其它元素的块引用（Blockquotes-with-Other-Elements）"><a href="#带有其它元素的块引用（Blockquotes-with-Other-Elements）" class="headerlink" title="带有其它元素的块引用（Blockquotes with Other Elements）"></a>带有其它元素的块引用（Blockquotes with Other Elements）</h3><p>块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。</p><pre class="line-numbers language-none"><code class="language-none">&gt; #### The quarterly results look great!&gt;&gt; - Revenue was off the chart.&gt; - Profits were higher than ever.&gt;&gt;  *Everything* is going according to **plan**.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><blockquote><h4 id="The-quarterly-results-look-great"><a href="#The-quarterly-results-look-great" class="headerlink" title="The quarterly results look great!"></a>The quarterly results look great!</h4><ul><li>Revenue was off the chart.</li><li>Profits were higher than ever.</li></ul><p><em>Everything</em> is going according to <strong>plan</strong>.</p></blockquote><h3 id="Blockquotes-Best-Practices"><a href="#Blockquotes-Best-Practices" class="headerlink" title="Blockquotes Best Practices"></a>Blockquotes Best Practices</h3><p>For compatibility, put blank lines before and after blockquotes.</p><div class="table-container"><table><thead><tr><th>✅ Do this</th><th>❌ Don’t do this</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...&gt; This is a blockquote...and after a blockquote.</code></td><td><code>Without blank lines, this might not look right.&gt; This is a blockquoteDon&#39;t do this!</code></td></tr></tbody></table></div><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>你可以将多个条目组织成有序或无序列表。</p><h3 id="有序列表（Ordered-Lists）"><a href="#有序列表（Ordered-Lists）" class="headerlink" title="有序列表（Ordered Lists）"></a>有序列表（Ordered Lists）</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>1. First item2. Second item3. Third item4. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item1. Second item1. Third item1. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item8. Second item3. Third item5. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>1. First item2. Second item3. Third item  1. Indented item  2. Indented item4. Fourth item</code></td><td><code>&lt;ol&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item  &lt;ol&gt;   &lt;li&gt;Indented item&lt;/li&gt;   &lt;li&gt;Indented item&lt;/li&gt;  &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ol&gt;</code></td><td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td></tr></tbody></table></div><h4 id="有序列表（Ordered-List）用法的最佳实践"><a href="#有序列表（Ordered-List）用法的最佳实践" class="headerlink" title="有序列表（Ordered List）用法的最佳实践"></a>有序列表（Ordered List）用法的最佳实践</h4><p>CommonMark 和其它几种轻量级标记语言可以让你使用括号（<code>)</code>）作为分隔符（例如 <code>1) First item</code>），但并非所有的 Markdown 应用程序都支持此种用法，因此，从兼容的角度来看，此用法不推荐。为了兼容起见，请只使用英文句点作为分隔符。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>1. First item2. Second item</code></td><td><code>1) First item2) Second item</code></td></tr></tbody></table></div><h3 id="无序列表（Unordered-Lists）"><a href="#无序列表（Unordered-Lists）" class="headerlink" title="无序列表（Unordered Lists）"></a>无序列表（Unordered Lists）</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (<code>-</code>)、星号 (<code>*</code>) 或加号 (<code>+</code>) 。缩进一个或多个列表项可创建嵌套列表。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>- First item- Second item- Third item- Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>* First item* Second item* Third item* Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>+ First item+ Second item+ Third item+ Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item&lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemFourth item</td></tr><tr><td><code>- First item- Second item- Third item  - Indented item  - Indented item- Fourth item</code></td><td><code>&lt;ul&gt; &lt;li&gt;First item&lt;/li&gt; &lt;li&gt;Second item&lt;/li&gt; &lt;li&gt;Third item  &lt;ul&gt;   &lt;li&gt;Indented item&lt;/li&gt;   &lt;li&gt;Indented item&lt;/li&gt;  &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Fourth item&lt;/li&gt;&lt;/ul&gt;</code></td><td>First itemSecond itemThird itemIndented itemIndented itemFourth item</td></tr></tbody></table></div><h4 id="以数字开头的无序列表项"><a href="#以数字开头的无序列表项" class="headerlink" title="以数字开头的无序列表项"></a>以数字开头的无序列表项</h4><p>如果你需要以数字开头并且紧跟一个英文句号（也就是 <code>.</code>）的无序列表项，则可以使使用反斜线（<code>\</code>）来 <a href="https://www.markdown.xyz/basic-syntax/#escaping-characters">转义</a> 这个英文句号。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>Rendered Output</th></tr></thead><tbody><tr><td><code>- 1968\. A great year!- I think 1969 was second best.</code></td><td><code>&lt;ul&gt; &lt;li&gt;1968. A great year!&lt;/li&gt; &lt;li&gt;I think 1969 was second best.&lt;/li&gt;&lt;/ul&gt;</code></td><td>1968. A great year!I think 1969 was second best.</td></tr></tbody></table></div><h4 id="无序列表（Unordered-List）用法的最佳实践"><a href="#无序列表（Unordered-List）用法的最佳实践" class="headerlink" title="无序列表（Unordered List）用法的最佳实践"></a>无序列表（Unordered List）用法的最佳实践</h4><p>Markdown 应用程序在如何处理同一列表中混用不同分隔符上并不一致。为了兼容起见，请不要在同一个列表中混用不同的分隔符，最好选定一种分隔符并一直用下去。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>- First item- Second item- Third item- Fourth item</code></td><td><code>+ First item* Second item- Third item+ Fourth item</code></td></tr></tbody></table></div><h3 id="在列表中添加列表项"><a href="#在列表中添加列表项" class="headerlink" title="在列表中添加列表项"></a>在列表中添加列表项</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示：</p><p><strong>Tip:</strong> If things don’t appear the way you expect, double check that you’ve indented the elements in the list four spaces or one tab.</p><h4 id="段落（Paragraphs）-1"><a href="#段落（Paragraphs）-1" class="headerlink" title="段落（Paragraphs）"></a>段落（Paragraphs）</h4><pre class="line-numbers language-none"><code class="language-none">* This is the first list item.* Here&#39;s the second list item.    I need to add another paragraph below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><p>I need to add another paragraph below the second list item.</p></li><li><p>And here’s the third list item.</p></li></ul><h4 id="引用块（Blockquotes）"><a href="#引用块（Blockquotes）" class="headerlink" title="引用块（Blockquotes）"></a>引用块（Blockquotes）</h4><pre class="line-numbers language-none"><code class="language-none">* This is the first list item.* Here&#39;s the second list item.    &gt; A blockquote would look great below the second list item.* And here&#39;s the third list item.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ul><li><p>This is the first list item.</p></li><li><p>Here’s the second list item.</p><blockquote><p>A blockquote would look great below the second list item.</p></blockquote></li><li><p>And here’s the third list item.</p></li></ul><h4 id="代码块（Code-Blocks）"><a href="#代码块（Code-Blocks）" class="headerlink" title="代码块（Code Blocks）"></a>代码块（Code Blocks）</h4><p><a href="https://www.markdown.xyz/basic-syntax/#code-blocks">代码块（Code blocks）</a> 通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</p><pre class="line-numbers language-none"><code class="language-none">1. Open the file.2. Find the following code block on line 21:        &lt;html&gt;          &lt;head&gt;            &lt;title&gt;Test&lt;&#x2F;title&gt;          &lt;&#x2F;head&gt;3. Update the title to match the name of your website.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li><p>Open the file.</p></li><li><p>Find the following code block on line 21:</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Test&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Update the title to match the name of your website.</p></li></ol><h4 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h4><pre class="line-numbers language-none"><code class="language-none">1. Open the file containing the Linux mascot.2. Marvel at its beauty.    ![Tux, the Linux mascot](&#x2F;assets&#x2F;images&#x2F;tux.png)3. Close the file.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li><p>Open the file containing the Linux mascot.</p></li><li><p>Marvel at its beauty.</p><p><img src="https://www.markdown.xyz/assets/images/tux.png" alt="Tux, the Linux mascot"></p></li><li><p>Close the file.</p></li></ol><h4 id="列表（Lists）-1"><a href="#列表（Lists）-1" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h4><p>你可以将无序列表嵌套在有序列表中，反之亦然。</p><pre class="line-numbers language-none"><code class="language-none">1. First item2. Second item3. Third item    - Indented item    - Indented item4. Fourth item<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><ol><li>First item</li><li>Second item</li><li>Third item<ul><li>Indented item</li><li>Indented item</li></ul></li><li>Fourth item</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (```) 中。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>At the command prompt, type</code>nano<code>.</code></td><td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td><td>At the command prompt, type <code>nano</code>.</td></tr></tbody></table></div><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。</p><div class="table-container"><table><thead><tr><th>Markdown</th><th>HTML</th><th>渲染效果</th></tr></thead><tbody><tr><td><code>Use `code` in your Markdown file.</code></td><td><code>&lt;code&gt;Use</code>code<code>in your Markdown file.&lt;/code&gt;</code></td><td><code>Use</code>code<code>in your Markdown file.</code></td></tr></tbody></table></div><h3 id="代码块（Code-Blocks）-1"><a href="#代码块（Code-Blocks）-1" class="headerlink" title="代码块（Code Blocks）"></a>代码块（Code Blocks）</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;  &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;  &lt;head&gt;  &lt;&#x2F;head&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong> 要创建不用缩进的代码块，请使用 <a href="https://www.markdown.xyz/extended-syntax/#fenced-code-blocks">围栏式代码块（fenced code blocks）</a>.</p><h2 id="分隔线（Horizontal-Rules）"><a href="#分隔线（Horizontal-Rules）" class="headerlink" title="分隔线（Horizontal Rules）"></a>分隔线（Horizontal Rules）</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><pre class="line-numbers language-none"><code class="language-none">***---_________________<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上三个分隔线的渲染效果看起来都一样：</p><hr><h3 id="分隔线（Horizontal-Rule）用法最佳实践"><a href="#分隔线（Horizontal-Rule）用法最佳实践" class="headerlink" title="分隔线（Horizontal Rule）用法最佳实践"></a>分隔线（Horizontal Rule）用法最佳实践</h3><p>为了兼容性，请在分隔线的前后均添加空白行。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>Try to put a blank line before...---...and after a horizontal rule.</code></td><td><code>Without blank lines, this would be a heading.---Don&#39;t do this!</code></td></tr></tbody></table></div><h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>要创建链接，请将链接文本括在方括号（例如 <code>[Duck Duck Go]</code>）中，后面紧跟着括在圆括号中的 URL（例如 <code>(https://duckduckgo.com)</code> ）。</p><pre class="line-numbers language-none"><code class="language-none">My favorite search engine is [Duck Duck Go](https:&#x2F;&#x2F;duckduckgo.com).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>My favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a>.</p><p><strong>Note:</strong> To link to an element on the same page, see <a href="https://www.markdown.xyz/extended-syntax/#linking-to-heading-ids">linking to heading IDs</a>.</p><h3 id="添加标题"><a href="#添加标题" class="headerlink" title="添加标题"></a>添加标题</h3><p>你可以选择为链接添加标题（即 title 属性）。当用户将鼠标悬停在链接上时，将显示一个提示。要添加标题，请将其放在 URL 后面。</p><pre class="line-numbers language-none"><code class="language-none">My favorite search engine is [Duck Duck Go](https:&#x2F;&#x2F;duckduckgo.com &quot;The best search engine for privacy&quot;).<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>My favorite search engine is <a href="https://duckduckgo.com/">Duck Duck Go</a>.</p><h3 id="网址和电子邮件地址"><a href="#网址和电子邮件地址" class="headerlink" title="网址和电子邮件地址"></a>网址和电子邮件地址</h3><p>要将 URL 或电子邮件地址快速转换为链接，请将其括在尖括号中。</p><pre class="line-numbers language-none"><code class="language-none">&lt;https:&#x2F;&#x2F;www.markdownguide.org&gt;&lt;fake@example.com&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>渲染效果如下：</p><p><a href="https://www.markdownguide.org/">https://www.markdownguide.org</a><br><a href="mailto:fake@example.com">fake@example.com</a></p><h3 id="格式化链接"><a href="#格式化链接" class="headerlink" title="格式化链接"></a>格式化链接</h3><p>如需 <a href="https://www.markdown.xyz/basic-syntax/#emphasis">强调（emphasize）</a> 某个链接, 请在方括号前及圆括号后添加星号。要将链接表示为 <a href="https://www.markdown.xyz/basic-syntax/#code">代码（code）</a> ，请在方括号内添加反引号。</p><pre class="line-numbers language-none"><code class="language-none">I love supporting the **[EFF](https:&#x2F;&#x2F;eff.org)**.This is the *[Markdown Guide](https:&#x2F;&#x2F;www.markdownguide.org)*.See the section on [&#96;code&#96;](#code).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>渲染效果如下：</p><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em>.<br>See the section on <a href="https://www.markdown.xyz/basic-syntax/#code"><code>code</code></a>.</p><h3 id="引用式链接"><a href="#引用式链接" class="headerlink" title="引用式链接"></a>引用式链接</h3><p>引用式（Reference-style）链接是一种特殊类型的链接，它使得 URL 在 Markdown 中更易于显示和阅读。引用式链接由两部分组成：一部分被放置在正文文本中；另一部分被放置在文档中的其它地方，以便于阅读。</p><h4 id="引用式链接第一部分的格式"><a href="#引用式链接第一部分的格式" class="headerlink" title="引用式链接第一部分的格式"></a>引用式链接第一部分的格式</h4><p>引用式链接的第一部分的格式由两组方括号组成。第一组方括号内放的是显示为链接的文本，第二组方括号内放的是一个标签，该标签用于指向您存放在文档中其它位置的链接。</p><p>尽管不是必须的，但你可以在第一组和第二组方括号之间添加一个空格。第二组方括号中的标签不区分大小写，并且可以包含字母、数字、空格或标点符号。</p><p>以下示例中，链接的第一部分是等效的：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="引用式链接第二部分的格式"><a href="#引用式链接第二部分的格式" class="headerlink" title="引用式链接第二部分的格式"></a>引用式链接第二部分的格式</h4><p>引用式链接的第二部分可以包含以下属性：</p><ol><li>放在方括号内的标签，以及紧跟在方括号后面的一个冒号和至少一个空格（例如 <code>[label]:</code>）。</li><li>链接的 URL，可以选择将其括在尖括号内。</li><li>链接的标题（可有可无），可以将其括在双引号、单引号或括号内。</li></ol><p>以下示例中，链接的第二部分是等效的：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在 Markdown 文档中的任何位置。有些人将它们放在被引用的段落的后面，有些人将它们放在文档的末尾（类似尾注或脚注）。</p><h4 id="将两部分组合在一起使用的示例"><a href="#将两部分组合在一起使用的示例" class="headerlink" title="将两部分组合在一起使用的示例"></a>将两部分组合在一起使用的示例</h4><p>假设你将一个 URL 作为一个 <a href="https://www.markdown.xyz/basic-syntax/#links">标准 URL 链接</a> 添加到段落中，在 Markdown 中如下所示：</p><pre class="line-numbers language-none"><code class="language-none">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;), and that means comfort.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Though it may point to interesting additional information, the URL as displayed really doesn’t add much to the existing raw text other than making it harder to read. To fix that, you could format the URL like this instead:</p><pre class="line-numbers language-none"><code class="language-none">In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the endsof worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or toeat: it was a [hobbit-hole][1], and that means comfort.[1]: &lt;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上述两个实例中，渲染后的输出是相同的：</p><blockquote><p>In a hole in the ground there lived a hobbit. Not a nasty, dirty, wet hole, filled with the ends of worms and an oozy smell, nor yet a dry, bare, sandy hole with nothing in it to sit down on or to eat: it was a <a href="https://en.wikipedia.org/wiki/Hobbit#Lifestyle">hobbit-hole</a>, and that means comfort.</p></blockquote><p>该链接的 HTML 为：</p><pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hobbit#Lifestyle&quot; title&#x3D;&quot;Hobbit lifestyles&quot;&gt;hobbit-hole&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="链接（Link）的最佳使用实践"><a href="#链接（Link）的最佳使用实践" class="headerlink" title="链接（Link）的最佳使用实践"></a>链接（Link）的最佳使用实践</h3><p>不同的 Markdown 应用程序在处理 URL 中间的空格方面是不一样的。为了兼容起见，请尽量使用 <code>%20</code> （空格的编码形式）来代替空格。</p><div class="table-container"><table><thead><tr><th>✅ 这样做</th><th>❌ 不要这样做</th></tr></thead><tbody><tr><td><code>[link](https://www.example.com/my%20great%20page)</code></td><td><code>[link](https://www.example.com/my great page)</code></td></tr></tbody></table></div><h2 id="图片（Images）-1"><a href="#图片（Images）-1" class="headerlink" title="图片（Images）"></a>图片（Images）</h2><p>要添加图片，首先请添加感叹号（<code>!</code>），然后紧跟着是方括号，方括号中可添加替代文本（alt text，即图片显示失败后显示此文本），最后跟着圆括号，圆括号中添加图片资源的路径或 URL。你可以选择在圆括号中的 URL 之后添加标题（即 title 属性）。</p><pre class="line-numbers language-none"><code class="language-none">![The San Juan Mountains are beautiful!](&#x2F;assets&#x2F;images&#x2F;san-juan-mountains.jpg &quot;San Juan Mountains&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p><img src="https://www.markdown.xyz/assets/images/san-juan-mountains.jpg" alt="The San Juan Mountains are beautiful!"></p><h3 id="带链接的图片"><a href="#带链接的图片" class="headerlink" title="带链接的图片"></a>带链接的图片</h3><p>要为图片添加链接，请先为图片的 Markdown 标记添加一个方括号，然后紧跟着一个圆括号，并在圆括号中添加链接地址。</p><pre class="line-numbers language-none"><code class="language-none">[![An old rock in the desert](&#x2F;assets&#x2F;images&#x2F;shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https:&#x2F;&#x2F;www.flickr.com&#x2F;photos&#x2F;beaurogers&#x2F;31833779864&#x2F;in&#x2F;photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p><a href="https://www.flickr.com/photos/beaurogers/31833779864/in/photolist-Qv3rFw-34mt9F-a9Cmfy-5Ha3Zi-9msKdv-o3hgjr-hWpUte-4WMsJ1-KUQ8N-deshUb-vssBD-6CQci6-8AFCiD-zsJWT-nNfsgB-dPDwZJ-bn9JGn-5HtSXY-6CUhAL-a4UTXB-ugPum-KUPSo-fBLNm-6CUmpy-4WMsc9-8a7D3T-83KJev-6CQ2bK-nNusHJ-a78rQH-nw3NvT-7aq2qf-8wwBso-3nNceh-ugSKP-4mh4kh-bbeeqH-a7biME-q3PtTf-brFpgb-cg38zw-bXMZc-nJPELD-f58Lmo-bXMYG-bz8AAi-bxNtNT-bXMYi-bXMY6-bXMYv"><img src="https://www.markdown.xyz/assets/images/shiprock.jpg" alt="An old rock in the desert"></a></p><h2 id="转义字符（Escaping-Characters）"><a href="#转义字符（Escaping-Characters）" class="headerlink" title="转义字符（Escaping Characters）"></a>转义字符（Escaping Characters）</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 (<code>\</code>) 。</p><pre class="line-numbers language-none"><code class="language-none">\* 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>* 如果没有开头的反斜杠字符的话，这一行将显示为无序列表。</p><h3 id="可做转义的（英文）字符"><a href="#可做转义的（英文）字符" class="headerlink" title="可做转义的（英文）字符"></a>可做转义的（英文）字符</h3><p>以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。</p><div class="table-container"><table><thead><tr><th>字符</th><th>名称</th></tr></thead><tbody><tr><td>\</td><td>反斜杠（backslash）</td></tr><tr><td>`</td><td>backtick (另请参见 <a href="https://www.markdown.xyz/basic-syntax/#escaping-backticks">在代码中转义反引号</a>)</td></tr><tr><td>*</td><td>星号（asterisk）</td></tr><tr><td>_</td><td>下划线（underscore）</td></tr><tr><td>{ }</td><td>花括号（curly braces）</td></tr><tr><td>[ ]</td><td>方括号（brackets）</td></tr><tr><td>&lt; &gt;</td><td>angle brackets</td></tr><tr><td>( )</td><td>圆括号或括号（parentheses）</td></tr><tr><td>#</td><td>井号（pound sign）</td></tr><tr><td>+</td><td>加号（plus sign）</td></tr><tr><td>-</td><td>减号（minus sign） (也叫连字符 hyphen)</td></tr><tr><td>.</td><td>句点（dot）</td></tr><tr><td>!</td><td>感叹号（exclamation mark）</td></tr><tr><td>\</td><td></td><td>管道符（pipe） (另请参见 <a href="https://www.markdown.xyz/extended-syntax/#escaping-pipe-characters-in-tables">在表格中转义管道符</a>)</td></tr></tbody></table></div><h2 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h2><p>大多 Markdown 应用程序允许你在 Markdown 格式文本中添加 HTML 标签。如果你喜欢某些 HTML 标签胜于 Markdown 语法的话，这将何有帮助。例如，某些人发现通过 HTML 标签添加图像更加容易。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>如需使用 HTML，请将 HTML 标签添加到 Markdown 格式文本中即可。</p><pre class="line-numbers language-none"><code class="language-none">This **word** is bold. This &lt;em&gt;word&lt;&#x2F;em&gt; is italic.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染效果如下：</p><p>This <strong>word</strong> is bold. This <em>word</em> is italic.</p><h3 id="HTML-用法最佳实践"><a href="#HTML-用法最佳实践" class="headerlink" title="HTML 用法最佳实践"></a>HTML 用法最佳实践</h3><p>出于安全原因，并非所有 Markdown 应用程序都支持在 Markdown 文档中添加 HTML。如有疑问，请查看 Markdown 应用程序的文档。某些应用程序只支持 HTML 标签的子集。</p><p>对于 HTML 的块级元素 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code> 和 <code>&lt;p&gt;</code>，请在其前后使用空行（blank lines）与其它内容进行分隔。尽量不要使用制表符（tabs）或空格（spaces）对 HTML 标签做缩进，否则将影响格式。</p><p>在 HTML 块级标签内不能使用 Markdown 语法。例如 <code>&lt;p&gt;italic and **bold**&lt;/p&gt;</code> 将不起作用。</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node—RED 启用使用身份认证登录</title>
      <link href="/2022/05/24/node-red-qi-yong-shi-yong-shen-fen-ren-zheng-deng-lu/"/>
      <url>/2022/05/24/node-red-qi-yong-shi-yong-shen-fen-ren-zheng-deng-lu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Node-RED 预设是无帐号与密码的，因此若建立在公开的伺服器上就是不安全的，任何人都可以透过 IP 或网域连上平台，且直接修改及部属编辑器上的节点，因此我们要运用其内建的使用者身分验证机制来保护平台的资讯安全。</p></blockquote><h3 id="编辑器和管理员-API-安全性"><a href="#编辑器和管理员-API-安全性" class="headerlink" title="编辑器和管理员 API 安全性"></a>编辑器和管理员 API 安全性</h3><p><strong>Editor</strong> 和 <strong>Admin API</strong> 支持两种类型的身份验证：</p><ul><li>基于用户名/密码凭据的身份验证</li><li>针对任何 OAuth/OpenID 提供者（例如 Twitter 或 GitHub）进行身份验证<h3 id="基于用户名-密码的身份验证"><a href="#基于用户名-密码的身份验证" class="headerlink" title="基于用户名/密码的身份验证"></a>基于用户名/密码的身份验证</h3></li></ul><p>要在 Editor 和 Admin API 上启用用户身份验证，请取消注释<em>设置文件</em><strong>adminAuth</strong> 中的属性：<br><pre class="line-numbers language-json" data-language="json"><code class="language-json">adminAuth: &#123;    type: &quot;credentials&quot;,    users: [        &#123;            username: &quot;admin&quot;,            password: &quot;$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.&quot;,            permissions: &quot;*&quot;        &#125;,        &#123;            username: &quot;george&quot;,            password: &quot;$2b$08$wuAqPiKJlVN27eF5qJp.RuQYuy6ZYONW7a&#x2F;UWYxDTtwKFCdB8F19y&quot;,            permissions: &quot;read&quot;        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>该<em>users</em>属性是一个用户对象数组。这允许您定义多个用户，每个用户都可以拥有不同的权限。</p><p>上面的这个示例配置定义了两个用户。一个被称为<em>admin</em>有权在编辑器内执行所有操作且密码为<em>password</em>. 另一个调用<em>george</em> who 被授予只读访问权限。</p><p>请注意，密码是使用 bcrypt 算法安全地散列的。</p><blockquote><p>注意：在以前的 Node-RED 版本中，该设置httpAdminAuth 可用于在编辑器上启用 HTTP 基本身份验证。此选项已弃用，不应使用。</p></blockquote><h3 id="生成密码哈希"><a href="#生成密码哈希" class="headerlink" title="生成密码哈希"></a>生成密码哈希</h3><p>如果您使用的是 Node-RED 1.1.0 或更高版本，则可以使用以下命令：</p><p><code>node-red admin hash-pw</code></p><p>对于旧版本的 Node-RED，您可以：</p><ul><li>安装单独的node-red-admin命令行工具并使用以下命令：<br>  <code>node-red-admin hash-pw</code></li><li><p>或者，找到 Node-RED 的安装目录并使用以下命令：</p><p>  <code>node -e &quot;console.log(require(&#39;bcryptjs&#39;).hashSync(process.argv[1], 8));&quot; your-password-here</code></p></li></ul><p>在所有情况下，您都会取回密码的散列版本，然后您可以将其粘贴到您的设置文件中。</p><h3 id="Where-is-my-settings-file"><a href="#Where-is-my-settings-file" class="headerlink" title="Where is my settings file?"></a>Where is my settings file?</h3>]]></content>
      
      
      <categories>
          
          <category> Node-RED </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何取得舊版 macOS</title>
      <link href="/2022/05/23/ru-he-qu-de-jiu-ban-macos/"/>
      <url>/2022/05/23/ru-he-qu-de-jiu-ban-macos/</url>
      
        <content type="html"><![CDATA[<p>如果您的 Mac 與最新版 macOS 不相容，您可以升級到舊版 macOS，例如 macOS Big Sur、Catalina、Mojave 或 High Sierra。</p><p>若要取得最新功能，並維護 Mac 的安全性、穩定性、相容性與效能，請務必讓軟體保持最新狀態。Apple 建議您一律使用與 Mac 相容的最新版 macOS。</p><p><a href="https://support.apple.com/zh-tw/HT212735">了解如何升級為 macOS Monterey</a>（最新版 macOS）。</p><h2 id="檢查相容性"><a href="#檢查相容性" class="headerlink" title="檢查相容性"></a>檢查相容性</h2><p>Mac 隨附的 macOS 版本是其可以使用的最早版本。例如，如果 Mac 隨附 macOS Big Sur，則不能使用 macOS Catalina 或之前版本。如果 macOS 與裝置不相容，App Store 或安裝程式會告知您。如果您嘗試安裝比目前安裝版本更舊的 macOS，安裝程式會指出此版本的 macOS 太舊，無法在這一版的 macOS 中打開。</p><ul><li>macOS Big Sur 11 <a href="https://support.apple.com/zh-tw/HT211238">硬體需求</a></li><li>macOS Catalina 10.15 <a href="https://support.apple.com/zh-tw/HT210222">硬體需求</a></li><li>macOS Mojave 10.14 <a href="https://support.apple.com/kb/SP777?locale=zh_TW">硬體需求</a></li><li>macOS High Sierra 10.13 <a href="https://support.apple.com/kb/SP765?locale=zh_TW">硬體需求</a></li><li>macOS Sierra 10.12 <a href="https://support.apple.com/kb/SP742?locale=zh_TW">硬體需求</a></li><li>OS X El Capitan 10.11 <a href="https://support.apple.com/kb/SP728?locale=zh_TW">硬體需求</a></li><li>OS X Yosemite 10.10 <a href="https://support.apple.com/kb/SP711?locale=zh_TW">硬體需求</a></li></ul><hr><h2 id="製作備份"><a href="#製作備份" class="headerlink" title="製作備份"></a>製作備份</h2><p>安裝任何升級程式之前，最好先<a href="https://support.apple.com/zh-tw/HT201250">備份 Mac</a>。「時光機」可協助您輕鬆備份，而您也可以採取其他備份方法。</p><hr><h2 id="在-Mac-上使用-Safari-下載-macOS"><a href="#在-Mac-上使用-Safari-下載-macOS" class="headerlink" title="在 Mac 上使用 Safari 下載 macOS"></a>在 Mac 上使用 Safari 下載 macOS</h2><p>Safari 會利用這些連結在 App Store 中尋找舊版安裝程式。從 App Store 下載安裝程式後，安裝程式會自動打開。</p><ul><li><a href="macappstores://apps.apple.com/tw/app/macos-big-sur/id1526878132?mt=12">macOS Big Sur</a> 可以升級 Catalina、Mojave、High Sierra、Sierra、El Capitan、Yosemite、Mavericks</li><li><a href="macappstores://apps.apple.com/tw/app/macos-catalina/id1466841314?mt=12">macOS Catalina</a> 可以升級 Mojave、High Sierra、Sierra、El Capitan、Yosemite、Mavericks</li><li><a href="macappstores://apps.apple.com/tw/app/macos-mojave/id1398502828?mt=12">macOS Mojave</a> 可以升級 High Sierra、Sierra、El Capitan、Yosemite、Mavericks、Mountain Lion</li><li><a href="macappstores://apps.apple.com/tw/app/macos-high-sierra/id1246284741?mt=12">macOS High Sierra</a> 可以升級 Sierra、El Capitan、Yosemite、Mavericks、Mountain Lion</li></ul><p>Safari 會以名為 InstallOS.dmg 或 InstallMacOSX.dmg 的磁碟映像檔的形式，來下載以下舊版安裝程式。請開啟磁碟映像檔，然後開啟其中的 .pkg 安裝程式。它會安裝一個名為「安裝 [版本名稱]」的 App。從「應用程式」檔案夾中打開該 App，即可開始安裝作業系統。</p><ul><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-39476-20191023-48f365f4-0015-4c41-9f44-39d3d2aca067/InstallOS.dmg">macOS Sierra</a> 可以升級 El Capitan、Yosemite、Mavericks、Mountain Lion 或 Lion</li><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-41424-20191024-218af9ec-cf50-4516-9011-228c78eda3d2/InstallMacOSX.dmg">OS X El Capitan</a> 可以升級 Yosemite、Mavericks、Mountain Lion、Lion 或 Snow Leopard</li><li><a href="http://updates-http.cdn-apple.com/2019/cert/061-41343-20191023-02465f92-3ab5-4c92-bfe2-b725447a070d/InstallMacOSX.dmg">OS X Yosemite</a> 可以升級 Mavericks、Mountain Lion、Lion 或 Snow Leopard</li></ul><p>發佈日期： 2022 年 03 月 03 日</p>]]></content>
      
      
      <categories>
          
          <category> macOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>靶面尺寸和镜头焦距配套对应的视场角</title>
      <link href="/2022/05/23/ba-mian-chi-cun-he-jing-tou-jiao-ju-pei-tao-dui-ying-de-shi-chang-jiao/"/>
      <url>/2022/05/23/ba-mian-chi-cun-he-jing-tou-jiao-ju-pei-tao-dui-ying-de-shi-chang-jiao/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>镜头焦距：</th><th>1.9mm</th><th>1.9mm</th><th>1.9mm</th><th>2.4mm</th><th>2.8mm</th><th>2.8mm</th><th>2.8mm</th><th>3.6mm</th><th>3.6mm</th><th>3.6mm</th><th>3.9mm</th><th>4mm</th><th>4mm</th><th>4mm</th><th>5mm</th><th>6mm</th></tr></thead><tbody><tr><td>靶面尺寸</td><td>长(mm)</td><td>宽(mm)</td><td>对角(mm)</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td><td>垂直视场角</td><td>视场角</td><td>水平视场角</td><td>水平视场角</td></tr><tr><td>1/6”</td><td>2.4</td><td>1.8</td><td>3</td><td>64.55128973</td><td>50.69235275</td><td>76.58032769</td><td>53.13010326</td><td>46.39718182</td><td>35.63777844</td><td>56.35718118</td><td>36.86989827</td><td>28.07248741</td><td>45.23973067</td><td>34.20545852</td><td>33.39849</td><td>25.36077</td><td>41.11209</td><td>28.04247</td><td>22.61987</td></tr><tr><td>1/4”</td><td>3.2</td><td>2.4</td><td>4</td><td>80.20181646</td><td>64.55128973</td><td>92.93760301</td><td>67.3801362</td><td>59.48976361</td><td>46.39718182</td><td>71.0753568</td><td>47.92497877</td><td>36.86989827</td><td>58.10920919</td><td>44.61241087</td><td>43.60282</td><td>33.39849</td><td>53.1301</td><td>37.97443</td><td>29.86283</td></tr><tr><td>1/4”</td><td>3.6</td><td>2.7</td><td>4.5</td><td>86.90368608</td><td>70.7895929</td><td>99.64153386</td><td>73.73979655</td><td>65.47045366</td><td>51.48141759</td><td>77.56872952</td><td>53.13010326</td><td>41.11209114</td><td>64.01076751</td><td>49.55028198</td><td>48.45549</td><td>37.29908</td><td>58.71551</td><td>43.13259</td><td>33.39849</td></tr><tr><td>1/3.6”</td><td>4</td><td>3</td><td>5</td><td>92.93760301</td><td>76.58032769</td><td>105.5303338</td><td>79.61114354</td><td>71.0753568</td><td>56.35718118</td><td>83.52060083</td><td>58.10920919</td><td>45.23973067</td><td>69.55566392</td><td>54.29936432</td><td>53.1301</td><td>41.11209</td><td>64.01077</td><td>48.44853</td><td>36.8699</td></tr><tr><td>1/3.2”</td><td>4.536</td><td>3.416</td><td>5.678</td><td>100.0913228</td><td>83.90774916</td><td>112.4151895</td><td>86.76048649</td><td>78.01494644</td><td>62.76638318</td><td>90.79251787</td><td>64.42185655</td><td>50.76348344</td><td>76.51941044</td><td>60.35929687</td><td>59.10647</td><td>46.24497</td><td>70.73046</td><td>55.86371</td><td>41.41318</td></tr><tr><td>1/3”</td><td>4.8</td><td>3.6</td><td>6</td><td>103.265031</td><td>86.90368608</td><td>115.305115</td><td>90.00000154</td><td>81.20259068</td><td>65.47045366</td><td>93.94986962</td><td>67.3801362</td><td>53.13010326</td><td>79.61114354</td><td>63.21500557</td><td>61.92751</td><td>48.45549</td><td>73.7398</td><td>59.65761</td><td>43.60282</td></tr><tr><td>1/2.8”</td><td>4.59</td><td>3.42</td><td>5.71</td><td>100.7581907</td><td>83.97442642</td><td>112.712541</td><td>87.4376781</td><td>78.67903116</td><td>62.82601814</td><td>91.11447318</td><td>65.03502234</td><td>50.81543708</td><td>76.83274295</td><td>60.95034996</td><td>59.6901</td><td>46.29342</td><td>71.0347</td><td>56.6316</td><td>41.86371</td></tr><tr><td>1/2.7”</td><td>5.27</td><td>3.96</td><td>6.592</td><td>108.4120734</td><td>92.3623794</td><td>120.0768619</td><td>95.3444878</td><td>86.52220908</td><td>70.53153652</td><td>99.30323061</td><td>72.40411143</td><td>57.62158847</td><td>84.95166994</td><td>68.08914978</td><td>66.74979</td><td>52.67082</td><td>78.97705</td><td>66.68016</td><td>47.41896</td></tr><tr><td>1/2.7”</td><td>5.371</td><td>4.035</td><td>6.718</td><td>109.4409395</td><td>93.43598697</td><td>121.0111347</td><td>96.42642672</td><td>87.60845497</td><td>71.54819508</td><td>100.3720838</td><td>73.44383343</td><td>58.53399502</td><td>86.03311928</td><td>69.10180006</td><td>67.75285</td><td>53.53047</td><td>80.04372</td><td>68.23864</td><td>48.22499</td></tr><tr><td>1/2.5”</td><td>5.76</td><td>4.29</td><td>7.182</td><td>113.172555</td><td>96.93218357</td><td>124.2333209</td><td>100.3888595</td><td>91.61386047</td><td>74.90938911</td><td>104.1109859</td><td>77.31961783</td><td>61.57579159</td><td>89.85658289</td><td>72.88888476</td><td>71.50778</td><td>56.40487</td><td>83.83182</td><td>74.42337</td><td>51.28201</td></tr><tr><td>1/2.3”</td><td>6.16</td><td>4.62</td><td>7.7</td><td>116.6605317</td><td>101.1246685</td><td>127.4667255</td><td>104.1470771</td><td>95.45262362</td><td>79.04526389</td><td>107.9452551</td><td>81.09765338</td><td>65.3738742</td><td>93.84391352</td><td>76.59937866</td><td>75.19254</td><td>60.01287</td><td>87.81062</td><td>81.11793</td><td>54.34588</td></tr><tr><td>1/2”</td><td>6.4</td><td>4.8</td><td>8</td><td>118.6005569</td><td>103.265031</td><td>129.184566</td><td>106.2602065</td><td>97.62815133</td><td>81.20259068</td><td>110.0159615</td><td>83.26708009</td><td>67.3801362</td><td>96.02557665</td><td>78.73863583</td><td>77.31962</td><td>61.92751</td><td>90</td><td>85.31844</td><td>56.14497</td></tr><tr><td>1/1.8”</td><td>7.2</td><td>5.4</td><td>9</td><td>124.3518094</td><td>109.7316158</td><td>134.218899</td><td>112.6198669</td><td>104.2500345</td><td>87.91674815</td><td>116.2184184</td><td>90.00000154</td><td>73.73979655</td><td>102.6803852</td><td>85.41878137</td><td>83.97443</td><td>68.0387</td><td>96.73292</td><td>100.5046</td><td>61.92751</td></tr><tr><td>1/1.7”</td><td>7.6</td><td>5.7</td><td>9.5</td><td>126.8698998</td><td>112.6198669</td><td>136.3971834</td><td>115.4487133</td><td>107.2312982</td><td>91.01405967</td><td>118.9635407</td><td>93.09631699</td><td>76.73497208</td><td>105.6834082</td><td>88.5118831</td><td>87.0624</td><td>70.93975</td><td>99.79819</td><td>108.9137</td><td>64.69489</td></tr><tr><td>1/1.6”</td><td>8.08</td><td>6.01</td><td>10.07</td><td>129.6250777</td><td>115.3913423</td><td>138.6511528</td><td>118.5743466</td><td>110.5507182</td><td>94.04505096</td><td>121.842496</td><td>96.59223359</td><td>79.70500692</td><td>108.8708424</td><td>92.0202983</td><td>90.5701</td><td>73.83141</td><td>103.07</td><td>119.8922</td><td>67.90739</td></tr><tr><td>2/3”</td><td>8.8</td><td>6.6</td><td>11</td><td>133.2888726</td><td>120.1369784</td><td>141.8845934</td><td>122.7790828</td><td>115.0576174</td><td>99.37180137</td><td>126.0395407</td><td>101.421188</td><td>85.02089561</td><td>113.5868613</td><td>96.89477536</td><td>95.45262</td><td>79.04526</td><td>107.9453</td><td>138.6173</td><td>72.50768</td></tr><tr><td>1”</td><td>12.9</td><td>9.6</td><td>16</td><td>147.1728347</td><td>136.8093814</td><td>153.2795657</td><td>139.1802367</td><td>133.0678505</td><td>119.4871277</td><td>141.41991</td><td>121.6647753</td><td>106.2602065</td><td>131.5445116</td><td>117.681393</td><td>116.3893</td><td>100.3889</td><td>126.8699</td><td>397.3125</td><td>94.14006</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 摄像头相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视场角 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bits 速查表</title>
      <link href="/2022/05/22/bits-su-cha-biao/"/>
      <url>/2022/05/22/bits-su-cha-biao/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="bits-cheat-sheet.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> Bits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java函数式编程之Optional</title>
      <link href="/2022/05/21/java-han-shu-shi-bian-cheng-zhi-optional/"/>
      <url>/2022/05/21/java-han-shu-shi-bian-cheng-zhi-optional/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文地址：<a href="https://juejin.cn/post/6844903908360323080">https://juejin.cn/post/6844903908360323080</a></p></blockquote><p><code>java.util.Optional</code>是JDK8中引入的类，它是JDK从著名的Java工具包<code>Guava</code>中移植过来。本文编写的时候使用的是JDK11。<code>Optional</code>是一个包含了<code>NULL</code>值或者非<code>NULL</code>值的对象容器，它常用作明确表明没有结果（其实明确表明存在结果也可以用<code>Optional</code>表示）的方法返回类型，这样可以避免<code>NULL</code>值带来的可能的异常（一般是<code>NullPointerException</code>）。也就是说，一个方法的返回值类型是<code>Optional</code>，则应该避免返回<code>NULL</code>，而应该让返回值指向一个包含<code>NULL</code>对象的<code>Optional</code>实例。<code>Optional</code>的出现为<code>NULL</code>判断、过滤操作、映射操作等提供了函数式适配入口，它算是Java引入函数式编程的一个重要的里程碑。</p><h2 id="Optional各个方法源码分析和使用场景"><a href="#Optional各个方法源码分析和使用场景" class="headerlink" title="Optional各个方法源码分析和使用场景"></a>Optional各个方法源码分析和使用场景</h2><p><code>Optional</code>的源码比较简单，归根于它是一个简单的对象容器。下面会结合源码分析它的所有构造、属性、方法和对应的使用场景。</p><h3 id="Optional属性和构造"><a href="#Optional属性和构造" class="headerlink" title="Optional属性和构造"></a>Optional属性和构造</h3><p><code>Optional</code>的属性和构造如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Optional&lt;T&gt; &#123;    &#x2F;&#x2F; 这个是通用的代表NULL值的Optional实例    private static final Optional&lt;?&gt; EMPTY &#x3D; new Optional&lt;&gt;();    &#x2F;&#x2F; 泛型类型的对象实例    private final T value;        &#x2F;&#x2F; 实例化Optional，注意是私有修饰符，value置为NULL    private Optional() &#123;        this.value &#x3D; null;    &#125;        &#x2F;&#x2F; 直接返回内部的EMPTY实例    public static&lt;T&gt; Optional&lt;T&gt; empty() &#123;        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;T&gt; t &#x3D; (Optional&lt;T&gt;) EMPTY;        return t;    &#125;        &#x2F;&#x2F; 通过value实例化Optional，如果value为NULL则抛出NPE    private Optional(T value) &#123;        this.value &#x3D; Objects.requireNonNull(value);    &#125;        &#x2F;&#x2F; 通过value实例化Optional，如果value为NULL则抛出NPE，实际上就是使用Optional(T value)    public static &lt;T&gt; Optional&lt;T&gt; of(T value) &#123;        return new Optional&lt;&gt;(value);    &#125;    &#x2F;&#x2F; 如果value为NULL则返回EMPTY实例，否则调用Optional#of(value)    public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) &#123;        return value &#x3D;&#x3D; null ? empty() : of(value);    &#125;        &#x2F;&#x2F; 暂时省略其他代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果明确一个对象实例不为<code>NULL</code>的时候，应该使用<code>Optional#of()</code>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);assert null !&#x3D; oOptional op &#x3D; Optional.of(o);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果无法明确一个对象实例是否为<code>NULL</code>的时候，应该使用<code>Optional#ofNullable()</code>，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional op &#x3D; Optional.ofNullable(selectByOrderId(orderId));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>明确表示一个持有<code>NULL</code>值的<code>Optional</code>实例可以使用<code>Optional.empty()</code>。</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果value为空，则抛出NPE，否则直接返回valuepublic T get() &#123;    if (value &#x3D;&#x3D; null) &#123;        throw new NoSuchElementException(&quot;No value present&quot;);    &#125;    return value;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>get()</code>方法一般是需要明确<code>value</code>不为<code>NULL</code>的时候使用，它做了先验<code>value</code>的存在性。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);assert null !&#x3D; oOptional op &#x3D; Optional.of(o);Order value &#x3D; op.get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="isPresent-方法"><a href="#isPresent-方法" class="headerlink" title="isPresent()方法"></a>isPresent()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断value是否存在，不为NULL则返回true，如果为NULL则返回falsepublic boolean isPresent() &#123;    return value !&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order o &#x3D; selectByOrderId(orderId);boolean existed &#x3D; Optional.ofNullable(o).isPresent();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty()方法"></a>isEmpty()方法</h3><p><code>isEmpty()</code>是JDK11引入的方法，是<code>isPresent()</code>的反向判断：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 判断value是否存在，为NULL则返回true，为非NULL则返回falsepublic boolean isEmpty() &#123;    return value &#x3D;&#x3D; null;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ifPresent-方法"><a href="#ifPresent-方法" class="headerlink" title="ifPresent()方法"></a>ifPresent()方法</h3><p><code>ifPresent()</code>方法的作用是：如果<code>value</code>不为<code>NULL</code>，则使用<code>value</code>调用消费者函数式接口的消费方法<code>Consumer#accept()</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void ifPresent(Consumer&lt;? super T&gt; action) &#123;    if (value !&#x3D; null) &#123;        action.accept(value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(selectByOrderId(orderId)).ifPresent(o-&gt; LOGGER.info(&quot;订单ID:&#123;&#125;&quot;,o.getOrderId());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ifPresentOrElse-方法"><a href="#ifPresentOrElse-方法" class="headerlink" title="ifPresentOrElse()方法"></a>ifPresentOrElse()方法</h3><p><code>ifPresentOrElse()</code>方法是JDK9新增的方法，它是<code>ifPresent()</code>方法的加强版，如果<code>value</code>不为<code>NULL</code>，则使用<code>value</code>调用消费者函数式接口的消费方法<code>Consumer#accept()</code>，如果<code>value</code>为<code>NULL</code>则执行<code>Runnable#run()</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction) &#123;    if (value !&#x3D; null) &#123;        action.accept(value);    &#125; else &#123;        emptyAction.run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String orderId &#x3D; &quot;xxxx&quot;; Optional.ofNullable(selectByOrderId(orderId)).ifPresentOrElse(o-&gt; LOGGER.info(&quot;订单ID:&#123;&#125;&quot;,o.getOrderId()), ()-&gt; LOGGER.info(&quot;订单&#123;&#125;不存在&quot;,o.getOrderId()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate) &#123;    &#x2F;&#x2F; 判断predicate不能为NULL    Objects.requireNonNull(predicate);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回自身    if (!isPresent()) &#123;        return this;    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，则通过predicate判断，命中返回自身，不命中则返回空实例empty        return predicate.test(value) ? this : empty();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个方法的功能是简单的过滤功能，容器持有对象<code>value</code>非<code>NULL</code>会做一次判断，决定返回自身实例还是<code>empty()</code>。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(selectByOrderId(orderId)).filter(o -&gt; o.getStatus() &#x3D;&#x3D; 1).ifPresent(o-&gt; LOGGER.info(&quot;订单&#123;&#125;的状态为1&quot;,o.getOrderId));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map()方法"></a>map()方法</h3><p><code>map()</code>是简单的值映射操作：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public &lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123;    &#x2F;&#x2F; 判断mapper不能为NULL    Objects.requireNonNull(mapper);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回empty()    if (!isPresent()) &#123;        return empty();    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，通过mapper转换类型，重新封装为可空的Optional实例        return Optional.ofNullable(mapper.apply(value));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>API注释里面的一个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;URI&gt; uris &#x3D; ...;&#x2F;&#x2F; 找到URI列表中未处理的URI对应的路径Optional&lt;Path&gt; p &#x3D; uris.stream().filter(uri -&gt; !isProcessedYet(uri)).findFirst().map(Paths::get);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="flatMap-方法"><a href="#flatMap-方法" class="headerlink" title="flatMap()方法"></a>flatMap()方法</h3><p><code>flatMap()</code>方法也是一个映射操作，不过映射的<code>Optional</code>类型返回值直接由外部决定，不需要通过值重新封装为<code>Optional</code>实例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public &lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, ? extends Optional&lt;? extends U&gt;&gt; mapper) &#123;    &#x2F;&#x2F; mapper存在性判断    Objects.requireNonNull(mapper);    &#x2F;&#x2F; value为NULL，说明是空实例，则直接返回empty()    if (!isPresent()) &#123;        return empty();    &#125; else &#123;        &#x2F;&#x2F; value不为NULL，通过mapper转换，直接返回mapper的返回值，做一次空判断        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;U&gt; r &#x3D; (Optional&lt;U&gt;) mapper.apply(value);        return Objects.requireNonNull(r);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class OptionalOrderFactory&#123;    static Optional&lt;Order&gt; create(String id)&#123;        &#x2F;&#x2F;省略...    &#125;&#125;String orderId &#x3D; &quot;xxx&quot;;Optional&lt;Order&gt; op &#x3D;  Optional.of(orderId).flatMap(id -&gt; OptionalOrderFactory.create(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="or-方法"><a href="#or-方法" class="headerlink" title="or()方法"></a>or()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier) &#123;    &#x2F;&#x2F; supplier存在性判断    Objects.requireNonNull(supplier);    &#x2F;&#x2F; value不为NULL，则直接返回自身    if (isPresent()) &#123;        return this;    &#125; else &#123;        &#x2F;&#x2F; value为NULL，则返回supplier提供的Optional实例，做一次空判断        @SuppressWarnings(&quot;unchecked&quot;)        Optional&lt;T&gt; r &#x3D; (Optional&lt;T&gt;) supplier.get();        return Objects.requireNonNull(r);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Order a &#x3D; null;Order b &#x3D; select();&#x2F;&#x2F; 拿到的就是b订单实例包装的OptionalOptional&lt;Order&gt; op &#x3D; Optional.ofNullable(a).or(b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="stream-方法"><a href="#stream-方法" class="headerlink" title="stream()方法"></a>stream()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 对value做NULL判断，转换为Stream类型public Stream&lt;T&gt; stream() &#123;    if (!isPresent()) &#123;        return Stream.empty();    &#125; else &#123;        return Stream.of(value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElse-方法"><a href="#orElse-方法" class="headerlink" title="orElse()方法"></a>orElse()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 值不为NULL则直接返回value，否则返回otherpublic T orElse(T other) &#123;    return value !&#x3D; null ? value : other;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>orElse()</code>就是常见的提供默认值兜底的方法，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String v1 &#x3D; null;String v2 &#x3D; &quot;default&quot;;&#x2F;&#x2F; 拿到的就是v2对应的&quot;default&quot;值String value &#x3D; Optional.ofNullable(v1).orElse(v2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElseGet-方法"><a href="#orElseGet-方法" class="headerlink" title="orElseGet()方法"></a>orElseGet()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 值不为NULL则直接返回value，否则返回Supplier#get()public T orElseGet(Supplier&lt;? extends T&gt; supplier) &#123;    return value !&#x3D; null ? value : supplier.get();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>orElseGet()</code>只是<code>orElse()</code>方法的升级版，例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String v1 &#x3D; null;Supplier&lt;String&gt; v2 &#x3D; () -&gt; &quot;default&quot;;&#x2F;&#x2F; 拿到的就是v2对应的&quot;default&quot;值String value &#x3D; Optional.ofNullable(v1).orElseGet(v2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="orElseThrow-方法"><a href="#orElseThrow-方法" class="headerlink" title="orElseThrow()方法"></a>orElseThrow()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果值为NULL，则抛出NoSuchElementException，否则直接返回valuepublic T orElseThrow() &#123;    if (value &#x3D;&#x3D; null) &#123;        throw new NoSuchElementException(&quot;No value present&quot;);    &#125;    return value;&#125;&#x2F;&#x2F; 如果值不为NULL，则直接返回value，否则返回Supplier#get()提供的异常实例public &lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X &#123;    if (value !&#x3D; null) &#123;        return value;    &#125; else &#123;        throw exceptionSupplier.get();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(orderInfoVo.getAmount()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId())));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="equals-和hashCode-方法"><a href="#equals-和hashCode-方法" class="headerlink" title="equals()和hashCode()方法"></a>equals()和hashCode()方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean equals(Object obj) &#123;    if (this &#x3D;&#x3D; obj) &#123;        return true;    &#125;    if (!(obj instanceof Optional)) &#123;        return false;    &#125;    Optional&lt;?&gt; other &#x3D; (Optional&lt;?&gt;) obj;    return Objects.equals(value, other.value);&#125;public int hashCode() &#123;    return Objects.hashCode(value);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个方法都是比较<code>value</code>，说明了<code>Optional</code>实例如果使用于<code>HashMap</code>的KEY，只要<code>value</code>相同，对于<code>HashMap</code>就是同一个KEY。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Optional,Boolean&gt; map &#x3D; new HashMap&lt;&gt;();Optional&lt;String&gt; op1 &#x3D; Optional.of(&quot;throwable&quot;);map.put(op1, true);Optional&lt;String&gt; op2 &#x3D; Optional.of(&quot;throwable&quot;);map.put(op2, false);&#x2F;&#x2F; 输出falseSystem.out.println(map.get(op1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Optional实战"><a href="#Optional实战" class="headerlink" title="Optional实战"></a>Optional实战</h2><p>下面展示一下<code>Optional</code>的一些常见的使用场景。</p><h3 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h3><p>空判断主要是用于不知道当前对象是否为<code>NULL</code>的时候，需要设置对象的属性。不使用<code>Optional</code>时候的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(null !&#x3D; order)&#123;    order.setAmount(orderInfoVo.getAmount());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>时候的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(order).ifPresent(o -&gt; o.setAmount(orderInfoVo.getAmount()));&#x2F;&#x2F; 如果判断空的对象是OrderInfoVo如下Order o &#x3D; select();OrderInfoVo vo &#x3D; ...Optional.ofNullable(vo).ifPresent(v -&gt; o.setAmount(v.getAmount()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>实现空判断的好处是<strong>只有一个属性设值的时候可以压缩代码为一行</strong>，这样做的话，代码会相对简洁。</p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在维护一些老旧的系统的时候，很多情况下外部的传参没有做空判断，因此需要写一些断言代码如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (null &#x3D;&#x3D; orderInfoVo.getAmount())&#123;    throw new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId()));&#125;if (StringUtils.isBlank(orderInfoVo.getAddress())&#123;    throw new IllegalArgumentException(String.format(&quot;%s订单的address不能为空&quot;,orderInfoVo.getOrderId()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>后的断言代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Optional.ofNullable(orderInfoVo.getAmount()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的amount不能为NULL&quot;,orderInfoVo.getOrderId())));Optional.ofNullable(orderInfoVo.getAddress()).orElseThrow(()-&gt; new IllegalArgumentException(String.format(&quot;%s订单的address不能为空&quot;,orderInfoVo.getOrderId())));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="综合仿真案例"><a href="#综合仿真案例" class="headerlink" title="综合仿真案例"></a>综合仿真案例</h3><p>下面是一个仿真案例，模拟的步骤如下：</p><ul><li>给出客户ID列表查询客户列表。</li><li>基于存在的客户列表中的客户ID查询订单列表。</li><li>基于订单列表转换为订单DTO视图列表。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datastatic class Customer &#123;    private Long id;&#125;@Datastatic class Order &#123;    private Long id;    private String orderId;    private Long customerId;&#125;@Datastatic class OrderDto &#123;    private String orderId;&#125;&#x2F;&#x2F; 模拟客户查询private static List&lt;Customer&gt; selectCustomers(List&lt;Long&gt; ids) &#123;    return null;&#125;&#x2F;&#x2F; 模拟订单查询private static List&lt;Order&gt; selectOrders(List&lt;Long&gt; customerIds) &#123;    return null;&#125;&#x2F;&#x2F; main方法public static void main(String[] args) throws Exception &#123;    List&lt;Long&gt; ids &#x3D; new ArrayList&lt;&gt;();    List&lt;OrderDto&gt; view &#x3D; Optional.ofNullable(selectCustomers(ids))            .filter(cs -&gt; !cs.isEmpty())            .map(cs -&gt; selectOrders(cs.stream().map(Customer::getId).collect(Collectors.toList())))            .map(orders -&gt; &#123;                List&lt;OrderDto&gt; dtoList &#x3D; new ArrayList&lt;&gt;();                orders.forEach(o -&gt; &#123;                    OrderDto dto &#x3D; new OrderDto();                    dto.setOrderId(o.getOrderId());                    dtoList.add(dto);                &#125;);                return dtoList;            &#125;).orElse(Collections.emptyList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Optional</code>本质是一个对象容器，它的特征如下：</p><ol><li><code>Optional</code>作为一个容器承载对象，提供方法适配部分函数式接口，结合部分函数式接口提供方法实现<code>NULL</code>判断、过滤操作、安全取值、映射操作等等。</li><li><code>Optional</code>一般使用场景是用于方法返回值的包装，当然也可以作为临时变量从而享受函数式接口的便捷功能。</li><li><code>Optional</code>只是一个简化操作的工具，可以解决多层嵌套代码的节点空判断问题（例如简化箭头型代码）。</li><li><code>Optional</code>并非银弹。</li></ol><p>这里提到箭头型代码，下面尝试用常规方法和<code>Optional</code>分别解决：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 假设VO有多个层级，每个层级都不知道父节点是否为NULL，如下&#x2F;&#x2F; - OrderInfoVo&#x2F;&#x2F;   - UserInfoVo&#x2F;&#x2F;     - AddressInfoVo&#x2F;&#x2F;        - address(属性)&#x2F;&#x2F; 假设我要为address属性赋值，那么就会产生箭头型代码。&#x2F;&#x2F; 常规方法String address &#x3D; &quot;xxx&quot;;OrderInfoVo o &#x3D; ...;if(null !&#x3D; o)&#123;    UserInfoVo uiv &#x3D; o.getUserInfoVo();    if (null !&#x3D; uiv)&#123;        AddressInfoVo aiv &#x3D; uiv.getAddressInfoVo();        if (null !&#x3D; aiv)&#123;            aiv.setAddress(address);        &#125;    &#125;&#125;&#x2F;&#x2F; 使用OptionalString address &#x3D; &quot;xxx&quot;;OrderInfoVo o &#x3D; null;Optional.ofNullable(o)        .map(OrderInfoVo::getUserInfoVo)        .map(UserInfoVo::getAddressInfoVo)        .ifPresent(a -&gt; a.setAddress(address));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>Optional</code>解决箭头型代码，通过映射操作<code>map()</code>能减少大量的<code>if</code>和<code>NULL</code>判断分支，使得代码更加简洁。</p><p>有些开发者提议把<code>DAO</code>方法的返回值类型定义为<code>Optional</code>，笔者对此持中立态度，原因是：</p><ol><li><code>Optional</code>是JDK1.8引入，低版本的JDK并不能使用，不是所有的系统都能平滑迁移到JDK1.8+。</li><li>并不是所有人都热衷于函数式编程，因为它带来了便捷的同时转变了代码的阅读逻辑（有些人甚至会认为降低了代码的可读性）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>球机PTZ和视场角与ONVIF和PTZ对应关系</title>
      <link href="/2022/05/21/qiu-ji-ptz-he-shi-chang-jiao-yu-onvif-he-ptz-dui-ying-guan-xi/"/>
      <url>/2022/05/21/qiu-ji-ptz-he-shi-chang-jiao-yu-onvif-he-ptz-dui-ying-guan-xi/</url>
      
        <content type="html"><![CDATA[<p>文章目录</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul><li><p>不同品牌对应关系不一致，同一品牌，根据摄像头产品参数也会不一致</p></li><li><p>球机的PTZ和ONVIF的PTZ是线性关系</p></li><li><p>摄像头的视场角与ONVIF的Zoom是非线性关系</p></li><li><p>ONVIF的PTZ范围</p><p>P、T ∈[-1, 1]</p><p>Z∈ [0,1]</p></li><li><p>球机PTZ范围：根据不同型号不一致</p><h2 id="PTZ-ONVIF-amp-PTZ-SDK"><a href="#PTZ-ONVIF-amp-PTZ-SDK" class="headerlink" title="PTZ_ONVIF &amp; PTZ_SDK"></a>PTZ_ONVIF &amp; PTZ_SDK</h2></li><li><p>以海康相机iDS-2VS435-F837为例，分别ONVIF控制球机转动指定PTZ坐标，再使用SDK获取PTZ坐标</p></li><li>海康球机SDK获取PTZ坐标(具体参考《设备网络SDK使用手册》)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">int p_pos &#x3D; HexToDecMa(ptz_pos.wPanPos) &#x2F; 10 % 360;&#x2F;&#x2F; 十六进制转化为十进制角度int t_pos &#x3D; HexToDecMa(ptz_pos.wTiltPos) &#x2F; 10 % 360;int z_pos &#x3D; HexToDecMa(ptz_pos.wZoomPos) &#x2F; 10 % 360;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>ONVIF——&gt;PTZ</p><p>模型函数是线性关系$\ y=kx+b $<br>LS最小二乘拟合<br>关系如下：<br>\begin{cases}<br>p′=179.87∗p+179.95 \<br>t′=55.00∗t+35.24 \<br>z′=36.00∗z+1.0<br>\end{cases}</p><p>球机水平方向转动360°<br>球机垂直方向转动[-20°, 90°]<br>球机光学放大倍数37倍<br>可以根据参数来验证拟合关系，设计正交试验，只需要测量几次即可</p><p>球机视场角与ONVIF对应关系</p><p>有时候需要实时获取视场角</p><p>视场角∝放大倍数∝Zoom</p><p>以海康相机iDS-2VS435-F837为例，固定PT，分别ONVIF控制球机转动指定Z，再获取视场角，视场角获取可以参考《视场角计算》</p><p>对应关系如下：</p><p>ONVIF-Zoom ——&gt;水平/垂直视场角</p><p>可以很明显看出是非线性关系<br>采用《非线性优化算法——LM》拟合曲线<br>关系如下</p><script type="math/tex; mode=display">{ F O V H = 1.626 ∗ e 0.634 0.177 + z o o m F O V V = 0.953 ∗ e 0.598 0.166 + z o o m{FOVH=1.626∗e0.6340.177+zoomFOVV=0.953∗e0.5980.166+zoom{FOVH=1.626∗e0.6340.177+zoomFOVV=0.953∗e0.5980.166+zoom{ FOV H =1.626∗e 0.177+zoom0.634FOV V =0.953∗e 0.166+zoom0.598</script><p>​    </p><p>拟合效果如下</p>]]></content>
      
      
      
        <tags>
            
            <tag> camera onvif </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
