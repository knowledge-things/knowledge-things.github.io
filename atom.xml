<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Blog</title>
  
  <subtitle>always-be-coding</subtitle>
  <link href="https://knowledge-things.github.io/atom.xml" rel="self"/>
  
  <link href="https://knowledge-things.github.io/"/>
  <updated>2023-05-16T01:27:36.914Z</updated>
  <id>https://knowledge-things.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SLAMTEC MAPPER 激光测距传感器应用笔记-01</title>
    <link href="https://knowledge-things.github.io/2023/05/16/slamtec-mapper-ji-guang-ce-ju-chuan-gan-qi-ying-yong-bi-ji-01/"/>
    <id>https://knowledge-things.github.io/2023/05/16/slamtec-mapper-ji-guang-ce-ju-chuan-gan-qi-ying-yong-bi-ji-01/</id>
    <published>2023-05-16T01:27:11.000Z</published>
    <updated>2023-05-16T01:27:36.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SLAMTEC-MAPPER-激光测距传感器应用笔记"><a href="#SLAMTEC-MAPPER-激光测距传感器应用笔记" class="headerlink" title="SLAMTEC MAPPER 激光测距传感器应用笔记"></a>SLAMTEC MAPPER 激光测距传感器应用笔记</h1><h3 id="下载SLAMTEC-SDK"><a href="#下载SLAMTEC-SDK" class="headerlink" title="下载SLAMTEC SDK"></a>下载SLAMTEC SDK</h3><p>请在思岚科技官方网站上的<a href="https://www.slamtec.com/cn/support">支持与下载页面</a>下载适合您的平台的ROS SDK并解压至本地。    </p><p>Slamware ROS SDK包含了您开发过程中可能会用到的资源、代码，其目录结构组织如下：</p><div class="table-container"><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>docs</td><td>参考文档</td></tr><tr><td>src</td><td>源码</td></tr><tr><td>—slamware_ros_sdk</td><td>ROS SDK源码包</td></tr><tr><td>—slamware_sdk</td><td>SDK相关头文件与库文件</td></tr></tbody></table></div><h3 id="1-配置ROS环境"><a href="#1-配置ROS环境" class="headerlink" title="1. 配置ROS环境"></a>1. 配置ROS环境</h3><ol><li><p>获取ROS Noetic Docker镜像:<br><code>docker pull ros:noetic</code></p></li><li><p>运行ROS Noetic Docker容器:<br>` docker run -it —name ros-noetic-container ros:noetic /bin/bash</p></li><li><p>安装SLAMTEC Mapper SDK: 首先，您需要从SLAMTEC官方网站下载适用于ROS的SDK（A1/A2/A3）：<a href="https://www.slamtec.com/en/Support#mapper-a-series">https://www.slamtec.com/en/Support#mapper-a-series</a></p></li><li><p>将SDK文件上传到Docker容器中。您可以使用docker cp命令实现这一点，例如：<br><code>docker cp slamtec_ros_sdk.tar.gz ros-noetic-container:/root</code></p></li><li><p>然后在Docker容器中解压缩文件：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it ros-noetic-container bashtar -xvzf slamtec_ros_sdk.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>构建SLAMTEC ROS软件包: 在Docker容器内，导航到解压缩的SDK目录，然后构建ROS软件包：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd slamtec_ros_sdk source &#x2F;opt&#x2F;ros&#x2F;noetic&#x2F;setup.bash catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><p>连接SLAMTEC Mapper设备： </p><p>SLAMTEC Mapper雷达与计算机之间是通过Wi-Fi连接,当设备正常启动后，打开您的无线网络适配器，您将看到热点 SLAMWARE-XXXXXX “ 默认 IP 为 192.168.11.1</p><p>使用<code>--net=host</code>参数运行Docker容器，以便容器可以访问主机网络：<br><code>docker run -it --name ros-noetic-container --net=host ros:noetic /bin/bash</code></p></li><li><p>修改SLAMTEC ROS SDK中的launch文件以使用设备的IP地址。导航到<code>slamtec_ros_sdk/launch</code>文件夹，打开<code>slamware.launch</code>文件并找到以下行：</p></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;arg name&#x3D;&quot;ip_address&quot; default&#x3D;&quot;192.168.11.1&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>启动SLAMTEC Mapper ROS节点</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source devel&#x2F;setup.bashroslaunch slamware_ros_sdk slamware.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-启动节点"><a href="#2-启动节点" class="headerlink" title="2. 启动节点"></a>2. 启动节点</h3><p>若移动机器人处于AP模式，连接机器人WIFI，启动节点</p><pre class="line-numbers language-none"><code class="language-none">roslaunch slamware_ros_sdk slamware_ros_sdk_server_node.launch ip_address:&#x3D;192.168.11.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过rviz查看<code>需要使用noetic-desktop-full镜像</code></p><p><em>启动容器之前执行<code>export DISPLAY=:0</code></em></p><pre class="line-numbers language-none"><code class="language-none">roslaunch slamware_ros_sdk view_slamware_ros_sdk_server_node.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-融合思路"><a href="#3-融合思路" class="headerlink" title="3. 融合思路"></a>3. 融合思路</h3><ol><li>安装并配置ROS环境：根据您的操作系统和需要的ROS版本，安装和配置ROS环境。可以参考ROS Wiki上的教程：<a href="http://wiki.ros.org/ROS/Installation">http://wiki.ros.org/ROS/Installation</a></li><li>安装并配置SLAMTEC Mapper SDK：按照前面回答中的说明，安装并配置SLAMTEC Mapper SDK以从雷达设备获取数据。</li><li>安装并配置摄像头驱动：为了从摄像头获取可见光图像，您需要安装和配置适当的摄像头驱动。对于许多常见的摄像头，可以使用<code>usb_cam</code>或<code>uvc_camera</code>软件包。这些软件包的详细信息和安装说明可以在ROS Wiki上找到：</li></ol><ul><li>usb_cam：<a href="http://wiki.ros.org/usb_cam">http://wiki.ros.org/usb_cam</a></li><li>uvc_camera：<a href="http://wiki.ros.org/uvc_camera">http://wiki.ros.org/uvc_camera</a></li></ul><ol><li>时间同步：为了将雷达数据与可见光图像对齐，您需要确保它们的时间戳是同步的。您可以使用<code>message_filters</code>库来实现这一点。有关如何使用<code>message_filters</code>的更多信息，请参阅ROS Wiki教程：<a href="http://wiki.ros.org/message_filters/Tutorials">http://wiki.ros.org/message_filters/Tutorials</a></li><li>转换坐标系：为了将雷达数据与摄像头图像对齐，您需要将它们转换到相同的坐标系。这可以通过使用ROS的<code>tf</code>库实现。首先，需要定义雷达和摄像头之间的固定变换关系。然后，可以使用<code>tf</code>库将雷达数据转换到摄像头坐标系。关于<code>tf</code>库的更多信息和教程，请参阅ROS Wiki：<a href="http://wiki.ros.org/tf/Tutorials">http://wiki.ros.org/tf/Tutorials</a></li><li>可视化数据：使用ROS的<code>rviz</code>工具可视化雷达数据和摄像头图像。这将帮助您验证数据对齐是否正确。有关如何使用<code>rviz</code>的教程，请参阅ROS Wiki：<a href="http://wiki.ros.org/rviz/Tutorials">http://wiki.ros.org/rviz/Tutorials</a></li></ol><p>通过以上步骤，您可以使用ROS将雷达数据与可见光数据对齐。需要注意的是，这里提供的信息仅是一个概述，实际操作时可能需要根据您的硬件和需求进行调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SLAMTEC-MAPPER-激光测距传感器应用笔记&quot;&gt;&lt;a href=&quot;#SLAMTEC-MAPPER-激光测距传感器应用笔记&quot; class=&quot;headerlink&quot; title=&quot;SLAMTEC MAPPER 激光测距传感器应用笔记&quot;&gt;&lt;/a&gt;SLAMTEC </summary>
      
    
    
    
    <category term="SLAMTEC liDar" scheme="https://knowledge-things.github.io/categories/SLAMTEC-liDar/"/>
    
    
    <category term="ros" scheme="https://knowledge-things.github.io/tags/ros/"/>
    
  </entry>
  
  <entry>
    <title>jupyter-lab 切换kernel</title>
    <link href="https://knowledge-things.github.io/2023/05/05/jupyter-qie-huan-kernel/"/>
    <id>https://knowledge-things.github.io/2023/05/05/jupyter-qie-huan-kernel/</id>
    <published>2023-05-05T01:31:15.000Z</published>
    <updated>2023-05-05T01:40:38.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/Anaconda-Platform/nb_conda_kernels">https://github.com/Anaconda-Platform/nb_conda_kernels</a></p><p>此扩展使一个<a href="https://conda.io/docs/">conda</a>环境中的<a href="http://jupyter.org/">Jupyter Notebook</a>或<a href="https://jupyterlab.readthedocs.io/en/stable/">JupyterLab</a>应用程序能够访问Python、R和其他环境中其他语言的内核。当选择来自外部环境的内核时，内核conda环境在启动之前会自动激活内核。</p></blockquote><h1 id="安装nb-conda"><a href="#安装nb-conda" class="headerlink" title="安装nb_conda"></a>安装nb_conda</h1><p><strong>在 base 环境中，输入：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) conda install nb_conda_kernels <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就安装了一个自动化的工具，实现 <code>ipython kernel install</code> 的功能。以后，新建的虚拟环境中只要安装了 ipykernel，该环境的 Jupyter kernel 就会自动新建。</p><p>例如创建新环境时安装ipykernel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">(base) conda create -n test ipykernel <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就不用管了，test 环境的 kernel 会自动生成.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Anaconda-Platform/nb_conda_kernels&quot;&gt;https://github.com/Anaconda-Platform/nb_conda_kernels&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CLIP论文精读</title>
    <link href="https://knowledge-things.github.io/2023/04/20/clip-lun-wen-jing-du/"/>
    <id>https://knowledge-things.github.io/2023/04/20/clip-lun-wen-jing-du/</id>
    <published>2023-04-20T02:04:40.000Z</published>
    <updated>2023-04-20T02:45:26.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLIP论文精读（Learning-Transferable-Visual-Models-From-Natural-Language-Supervision）"><a href="#CLIP论文精读（Learning-Transferable-Visual-Models-From-Natural-Language-Supervision）" class="headerlink" title="CLIP论文精读（Learning Transferable Visual Models From Natural Language Supervision）"></a>CLIP论文精读（<strong>Learning Transferable Visual Models From Natural Language Supervision</strong>）</h1><blockquote><p>论文地址: <a href="https://arxiv.org/abs/2103.00020">https://arxiv.org/abs/2103.00020</a> （26 Feb 2021）</p></blockquote><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要:"></a>摘要:</h2><p>​        本论文提出了一种新颖的方法，利用自然语言监督来学习可转移的视觉模型。该方法基于现有的预训练语言模型（如GPT-4），通过结合视觉和文本信息，实现对图像数据的更丰富的理解。这种新颖的方法强调了通过自然语言监督来捕捉视觉知识的潜力，从而在各种计算机视觉任务中取得更好的泛化性能。</p><p>该方法的核心思想是使用大量未标注的图像-文本对来训练一个视觉-语言联合模型。在这个过程中，模型需要学会理解图像内容与相关文本描述之间的关系。这种理解被认为是可转移的，因为模型可以将从一种任务中学到的知识应用到其他任务上，以提高其性能。</p><p>实验结果表明，通过自然语言监督学习的视觉模型在多个计算机视觉任务上表现出色，如图像分类、物体检测和语义分割。与传统的监督学习方法相比，本方法在许多任务上实现了显著的性能提升，证明了自然语言监督对于学习可转移视觉知识的有效性。</p><p>总之，本论文提出了一种基于自然语言监督的方法，用于学习具有广泛泛化能力的视觉模型。实验结果验证了该方法在多种计算机视觉任务上的有效性，为未来研究提供了一个有趣的方向。</p><p>该方法可应用于多种任务，包括：OCR、动作检测、目标跟踪。    </p><h2 id="模型总览："><a href="#模型总览：" class="headerlink" title="模型总览："></a>模型总览：</h2><h3 id="训练步骤"><a href="#训练步骤" class="headerlink" title="训练步骤"></a>训练步骤</h3><blockquote><p>openai 准备了4亿个图片和文本对</p></blockquote><ul><li>通过自然语言处理生成的监督信号可以训练一个迁移效果很好的视觉模型 </li></ul><p><img src="/images/image-20230418162752926.png" alt="contrastive pre-training" style="zoom:50%;" /> </p><ul><li>在模型的训练过程输入是一个图片和一个文字的配对</li><li>通过图像的编码器和文字编码器生成Image Encoder和Text Encoder，图像编码器可以使用ResNet和Vision Transformer</li><li>每个training batch都有N个图像文本对</li><li>CLIP在特征上做对比学习（通过正样本和负样本做对比训练），在特征矩阵里，沿着对角线方向上的为正样本，其余不是对角线的样本都是负样本，负样本的个数n^2-n</li></ul><h2 id="zero-shot推理"><a href="#zero-shot推理" class="headerlink" title="zero-shot推理"></a>zero-shot推理</h2><blockquote><p>由于CLIP没有在分类的任务上进行继续学习和微调，所以CLIP没有分类头，作者采用了一种自然语言处理的方式promt template</p></blockquote><h3 id="promt-template"><a href="#promt-template" class="headerlink" title="promt template"></a>promt template</h3><p><img src="/images/image-20230418164016354.png" alt="create dataset classofoer from label text" style="zoom:50%;" /> </p><ul><li>将ImageNet所有类别进行造句，由于训练过程使用的不是单个单词所有需要造句。</li><li>将图片送入编码器得到图片的特征，将所有图片特征和文本特征通过cosine similarity计算相识性。</li><li>将相似性最高的句子挑出来，得到所需的分类</li></ul><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><img src="/images/image-20230418164948666.png" alt="ResNet101 vs CLIP"></p><h2 id="基于CLIP的应用"><a href="#基于CLIP的应用" class="headerlink" title="基于CLIP的应用"></a>基于CLIP的应用</h2><ul><li>clifs <a href="https://github.com/johanmodin/clifs">https://github.com/johanmodin/clifs</a>  根据给定的信息在视频中做目标检索</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="/images/image-20230418173634810.png" alt="image-20230418173634810"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CLIP论文精读（Learning-Transferable-Visual-Models-From-Natural-Language-Supervision）&quot;&gt;&lt;a href=&quot;#CLIP论文精读（Learning-Transferable-Visual-Mod</summary>
      
    
    
    
    <category term="cv" scheme="https://knowledge-things.github.io/categories/cv/"/>
    
    
    <category term="zero-shot" scheme="https://knowledge-things.github.io/tags/zero-shot/"/>
    
  </entry>
  
  <entry>
    <title>通过深度信息计算世界坐标</title>
    <link href="https://knowledge-things.github.io/2023/04/08/tong-guo-shen-du-xin-xi-ji-suan-shi-jie-zuo-biao/"/>
    <id>https://knowledge-things.github.io/2023/04/08/tong-guo-shen-du-xin-xi-ji-suan-shi-jie-zuo-biao/</id>
    <published>2023-04-08T14:20:47.000Z</published>
    <updated>2023-04-08T14:30:26.388Z</updated>
    
    <content type="html"><![CDATA[<p>要将通过monodepth2得到的深度信息转换为世界坐标，您需要执行以下步骤。在这个过程中，我们需要内参矩阵（K）和位姿矩阵（T）。假设我们已经有了这些矩阵，那么可以采取以下步骤：</p><ol><li>将深度图像转换为像素坐标。</li><li>使用内参矩阵将像素坐标转换为相机坐标。</li><li>使用位姿矩阵将相机坐标转换为世界坐标。</li></ol><p>以下是实现这些步骤的公式：</p><h3 id="1-将深度图像转换为像素坐标"><a href="#1-将深度图像转换为像素坐标" class="headerlink" title="1. 将深度图像转换为像素坐标"></a>1. 将深度图像转换为像素坐标</h3><p>对于每个像素(u,v)及其对应的深度值d，我们可以得到像素坐标系中的3D点(x, y, z)。这里，z = d。</p><pre class="line-numbers language-none"><code class="language-none">(x, y, z) &#x3D; (u, v, d)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-使用内参矩阵将像素坐标转换为相机坐标"><a href="#2-使用内参矩阵将像素坐标转换为相机坐标" class="headerlink" title="2. 使用内参矩阵将像素坐标转换为相机坐标"></a>2. 使用内参矩阵将像素坐标转换为相机坐标</h3><p>我们使用内参矩阵K来将像素坐标转换为相机坐标。这里，K是一个3x3矩阵，包含相机的焦距和主点坐标。</p><pre class="line-numbers language-none"><code class="language-none">K &#x3D; |f_x,  0,  c_x|    | 0,  f_y, c_y|    | 0,   0,   1 |其中：f_x: x轴方向的焦距f_y: y轴方向的焦距c_x: x轴方向的主点坐标c_y: y轴方向的主点坐标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了从像素坐标系到相机坐标系的转换，我们需要首先计算逆内参矩阵（K_inv）。然后将像素坐标与逆内参矩阵相乘。</p><pre class="line-numbers language-none"><code class="language-none">K_inv &#x3D; K^(-1)(X_c, Y_c, Z_c) &#x3D; K_inv * (x, y, z)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-使用位姿矩阵将相机坐标转换为世界坐标"><a href="#3-使用位姿矩阵将相机坐标转换为世界坐标" class="headerlink" title="3. 使用位姿矩阵将相机坐标转换为世界坐标"></a>3. 使用位姿矩阵将相机坐标转换为世界坐标</h3><p>位姿矩阵T是一个4x4矩阵，包含旋转矩阵R（3x3）和平移矩阵t（3x1）。</p><pre class="line-numbers language-none"><code class="language-none">T &#x3D; |R, t|    |0, 1|其中：R: 旋转矩阵（3x3）t: 平移矩阵（3x1）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了将相机坐标转换为世界坐标，我们需要将相机坐标表示为齐次坐标（添加一个1作为第四个元素），然后与位姿矩阵相乘。最后，将结果转换回非齐次坐标（去掉第四个元素）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要将通过monodepth2得到的深度信息转换为世界坐标，您需要执行以下步骤。在这个过程中，我们需要内参矩阵（K）和位姿矩阵（T）。假设我们已经有了这些矩阵，那么可以采取以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将深度图像转换为像素坐标。&lt;/li&gt;
&lt;li&gt;使用内参矩阵将像素坐</summary>
      
    
    
    
    <category term="camera" scheme="https://knowledge-things.github.io/categories/camera/"/>
    
    
    <category term="monodepth" scheme="https://knowledge-things.github.io/tags/monodepth/"/>
    
  </entry>
  
  <entry>
    <title>Docker普通用户的权限设置</title>
    <link href="https://knowledge-things.github.io/2023/03/31/docker-pu-tong-yong-hu-de-quan-xian-she-zhi/"/>
    <id>https://knowledge-things.github.io/2023/03/31/docker-pu-tong-yong-hu-de-quan-xian-she-zhi/</id>
    <published>2023-03-31T07:49:25.000Z</published>
    <updated>2023-03-31T07:49:54.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker普通用户的权限设置"><a href="#Docker普通用户的权限设置" class="headerlink" title="Docker普通用户的权限设置"></a>Docker普通用户的权限设置</h1><p>docker安装之后默认会创建docker组，docker组拥有读取套接字权限，因此将该普通用户加入docker组，该组下所有用户有访问unix套接字权限，最后刷新用户的初始组即可。</p><p>2.1 查看是否有docker用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test@ubuntu:~$ sudo cat &#x2F;etc&#x2F;group |grep dockerdocker:x:999:  # 表示存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果没有需要手动增加</p><pre class="line-numbers language-none"><code class="language-none">sudo groupadd docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.2 查看 /var/run/docker.sock 的属性</p><p>如果/var/run/docker.sock的用户组不是docker，而是root需要使用chgrp修改。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># ll &#x2F;var&#x2F;run&#x2F;docker.socksrw-rw---- 1 root root 0 Oct 29 22:20 &#x2F;var&#x2F;run&#x2F;docker.sock&#x3D;chgrp docker &#x2F;var&#x2F;run&#x2F;docker.sock&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.3 将普通用户添加至docker组</p><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test@:~$ sudo gpasswd -a test dockerAdding user test to group docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="查看，此时不在，需要刷新"><a href="#查看，此时不在，需要刷新" class="headerlink" title="查看，此时不在，需要刷新"></a>查看，此时不在，需要刷新</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test@ubuntu:~$ iduid&#x3D;1002(test) gid&#x3D;1002(test) groups&#x3D;1002(test)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h1><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">test@ubuntu:~$ newgrp docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker普通用户的权限设置&quot;&gt;&lt;a href=&quot;#Docker普通用户的权限设置&quot; class=&quot;headerlink&quot; title=&quot;Docker普通用户的权限设置&quot;&gt;&lt;/a&gt;Docker普通用户的权限设置&lt;/h1&gt;&lt;p&gt;docker安装之后默认会创建doc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>github配置SSH秘钥</title>
    <link href="https://knowledge-things.github.io/2023/02/15/github-pei-zhi-ssh-mi-yao/"/>
    <id>https://knowledge-things.github.io/2023/02/15/github-pei-zhi-ssh-mi-yao/</id>
    <published>2023-02-15T03:32:50.000Z</published>
    <updated>2023-02-15T03:41:39.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="github配置SSH秘钥"><a href="#github配置SSH秘钥" class="headerlink" title="github配置SSH秘钥"></a>github配置SSH秘钥</h1><h2 id="检查现有-SSH-密钥"><a href="#检查现有-SSH-密钥" class="headerlink" title="检查现有 SSH 密钥"></a>检查现有 SSH 密钥</h2><h2 id="关于-SSH-密钥"><a href="#关于-SSH-密钥" class="headerlink" title="关于 SSH 密钥"></a>关于 SSH 密钥</h2><p>可以使用 SSH 在 GitHub.com 上的存储库中执行 Git 操作。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/about-ssh">关于 SSH</a>”。</p><p>如果有现有的 SSH 密钥，则可以使用该密钥通过 SSH 对 Git 操作进行身份验证。</p><h2 id="检查现有-SSH-密钥-1"><a href="#检查现有-SSH-密钥-1" class="headerlink" title="检查现有 SSH 密钥"></a>检查现有 SSH 密钥</h2><p>在生成新的 SSH 密钥之前，应该检查本地计算机是否存在现有密钥。</p><ol><li><p>打开终端。</p></li><li><p>输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有的 SSH 密钥。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ls -al ~&#x2F;.ssh# Lists the files in your .ssh directory, if they exist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，GitHub 的一个支持的公钥的文件名是以下之一。</p><ul><li>id_rsa.pub</li><li>id_ecdsa.pub</li><li>id_ed25519.pub</li></ul><p>提示：如果收到错误，指示 ~/.ssh 不存在，则表明默认位置中没有现有的 SSH 密钥对。 您可以在下一步中创建新的 SSH 密钥对。</p></li></ol><h2 id="生成新-SSH-密钥"><a href="#生成新-SSH-密钥" class="headerlink" title="生成新 SSH 密钥"></a>生成新 SSH 密钥</h2><p>可在本地计算机上生成新的 SSH 密钥。 生成密钥后，可以将密钥添加到您在 GitHub.com 上的帐户，以启用通过 SSH 进行 Git 操作的身份验证。</p><ol><li><p>打开终端。</p></li><li><p>粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：如果你使用的是不支持 Ed25519 算法的旧系统，请使用以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将以提供的电子邮件地址为标签创建新 SSH 密钥。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; Generating public&#x2F;private ALGORITHM key pair.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="将-SSH-密钥添加到-ssh-agent"><a href="#将-SSH-密钥添加到-ssh-agent" class="headerlink" title="将 SSH 密钥添加到 ssh-agent"></a>将 SSH 密钥添加到 ssh-agent</h2><p>在向 ssh 代理添加新的 SSH 密钥以管理您的密钥之前，您应该检查现有 SSH 密钥并生成新的 SSH 密钥。</p><ol><li><p>在后台启动 ssh 代理。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ eval &quot;$(ssh-agent -s)&quot;&gt; Agent pid 59566<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>根据您的环境，您可能需要使用不同的命令。 例如，在启动 ssh-agent 之前，你可能需要通过运行 <code>sudo -s -H</code> 根访问，或者可能需要使用 <code>exec ssh-agent bash</code> 或 <code>exec ssh-agent zsh</code> 运行 ssh-agent。</p></li><li><p>将 SSH 私钥添加到 ssh-agent。 如果使用其他名称创建了密钥或要添加具有其他名称的现有密钥，请将命令中的 id_ed25519 替换为私钥文件的名称。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-add ~&#x2F;.ssh&#x2F;id_ed25519<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><ol><li>将 SSH 密钥添加到 GitHub 上的帐户。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">将新的 SSH 密钥添加到 GitHub 帐户</a>”。</li></ol><h1 id="新增-SSH-密钥到-GitHub-帐户"><a href="#新增-SSH-密钥到-GitHub-帐户" class="headerlink" title="新增 SSH 密钥到 GitHub 帐户"></a>新增 SSH 密钥到 GitHub 帐户</h1><h2 id="关于向帐户添加-SSH-密钥"><a href="#关于向帐户添加-SSH-密钥" class="headerlink" title="关于向帐户添加 SSH 密钥"></a>关于向帐户添加 SSH 密钥</h2><p>可以使用 SSH（安全外壳协议）访问和写入 GitHub.com 上的存储库中的数据。 通过 SSH 进行连接时，使用本地计算机上的私钥文件进行身份验证。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/about-ssh">关于 SSH</a>”。</p><p>还可以使用 SSH 对提交和标记进行签名。 有关提交签名的详细信息，请参阅“<a href="https://docs.github.com/zh/articles/about-commit-signature-verification">关于提交签名验证</a>”。</p><p>生成 SSH 密钥对后，必须将公钥添加到 GitHub.com 以启用帐户的 SSH 访问。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>在将新的 SSH 密钥添加到 GitHub.com 上的帐户之前，请完成以下步骤。</p><ol><li>检查现有 SSH 密钥。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys">检查现有 SSH 密钥</a>”。</li><li>生成新的 SSH 密钥，并将其添加到计算机的 SSH 代理。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">生成新的 SSH 密钥并将其添加到 ssh-agent</a>”。</li></ol><h2 id="向你的帐户添加新的-SSH-密钥"><a href="#向你的帐户添加新的-SSH-密钥" class="headerlink" title="向你的帐户添加新的 SSH 密钥"></a>向你的帐户添加新的 SSH 密钥</h2><p>为 GitHub.com 上的帐户添加新 SSH 身份验证密钥后，可以重新配置任何本地存储库以使用 SSH。 有关详细信息，请参阅“<a href="https://docs.github.com/zh/github/getting-started-with-github/managing-remote-repositories/#switching-remote-urls-from-https-to-ssh">将远程 URL 从 HTTPS 切换到 SSH</a>”。</p><p>注意：GitHub 通过在 2022 年 3 月 15 日删除旧的、不安全的密钥类型来提高安全性。</p><p>自该日期起，不再支持 DSA 密钥 (<code>ssh-dss</code>)。 无法在 GitHub.com上向个人帐户添加新的 DSA 密钥。</p><p>2021 年 11 月 2 日之前带有 <code>valid_after</code> 的 RSA 密钥 (<code>ssh-rsa</code>) 可以继续使用任何签名算法。 在该日期之后生成的 RSA 密钥必须使用 SHA-2 签名算法。 一些较旧的客户端可能需要升级才能使用 SHA-2 签名。</p><ol><li><p>将 SSH 公钥复制到剪贴板。</p><p>如果您的 SSH 公钥文件与示例代码不同，请修改文件名以匹配您当前的设置。 在复制密钥时，请勿添加任何新行或空格。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ cat ~&#x2F;.ssh&#x2F;id_ed25519.pub  # Then select and copy the contents of the id_ed25519.pub file  # displayed in the terminal to your clipboard<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提示：或者，你也可以找到隐藏的 <code>.ssh</code> 文件夹，在你最喜欢的文本编辑器中打开该文件，并将其复制到剪贴板。</p><ol><li>在任何页面的右上角，单击个人资料照片，然后单击“设置”。</li></ol><p><img src="https://docs.github.com/assets/cb-34573/images/help/settings/userbar-account-settings.png?100x" alt="用户栏中的 Settings 图标" style="zoom:50%;" /></p></li></ol><ol><li><p>在边栏的“访问”部分中，单击 “SSH 和 GPG 密钥”。</p></li><li><p>单击“新建 SSH 密钥”或“添加 SSH 密钥” 。<img src="https://docs.github.com/assets/cb-28257/images/help/settings/ssh-add-ssh-key-with-auth.png?" alt="SSH 密钥按钮" style="zoom:50%;" /></p></li><li><p>在 “Title”（标题）字段中，为新密钥添加描述性标签。 例如，如果使用的是个人笔记本电脑，则可以将此密钥称为“个人笔记本电脑”。</p></li><li><p>选择密钥类型（身份验证或签名）。 有关提交签名的详细信息，请参阅“<a href="https://docs.github.com/zh/articles/about-commit-signature-verification">关于提交签名验证</a>”。</p></li><li><p>将公钥粘贴到“密钥”字段。<img src="https://docs.github.com/assets/cb-47495/images/help/settings/ssh-key-paste-with-type.png?100px" alt="密钥字段" style="zoom:50%;" /></p></li><li><p>单击“添加 SSH 密钥”。<img src="https://docs.github.com/assets/cb-6592/images/help/settings/ssh-add-key.png?" alt="“添加密钥”按钮" style="zoom:50%;" /></p></li></ol><h1 id="测试-SSH-连接"><a href="#测试-SSH-连接" class="headerlink" title="测试 SSH 连接"></a>测试 SSH 连接</h1><p>设置 SSH 密钥并将其添加到你在 GitHub.com 上的帐户后，可以测试连接。</p><ol><li><p>打开终端。</p></li><li><p>输入以下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh -T git@github.com# Attempts to ssh to GitHub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您可能会看到类似如下的警告：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; The authenticity of host &#39;github.com (IP ADDRESS)&#39; can&#39;t be established.&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.&gt; Are you sure you want to continue connecting (yes&#x2F;no)?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>验证所看到消息中的指纹是否与 <a href="https://docs.github.com/zh/github/authenticating-to-github/githubs-ssh-key-fingerprints">GitHub 的公钥指纹</a>匹配。 如果是，则键入 <code>yes</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; Hi USERNAME! You&#39;ve successfully authenticated, but GitHub does not&gt; provide shell access.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你可能会看到此错误消息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">...Agent admitted failure to sign using the key.debug1: No more authentication methods to try.Permission denied (publickey).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="设置github-ssh代理"><a href="#设置github-ssh代理" class="headerlink" title="设置github ssh代理"></a>设置github ssh代理</h1><p>如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host github.com    User git    ProxyCommand nc -v -x 127.0.0.1:2341 %h %p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;github配置SSH秘钥&quot;&gt;&lt;a href=&quot;#github配置SSH秘钥&quot; class=&quot;headerlink&quot; title=&quot;github配置SSH秘钥&quot;&gt;&lt;/a&gt;github配置SSH秘钥&lt;/h1&gt;&lt;h2 id=&quot;检查现有-SSH-密钥&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="github" scheme="https://knowledge-things.github.io/categories/github/"/>
    
    
    <category term="git" scheme="https://knowledge-things.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CVAT挂载MINIO</title>
    <link href="https://knowledge-things.github.io/2023/01/12/cvat-gua-zai-minio/"/>
    <id>https://knowledge-things.github.io/2023/01/12/cvat-gua-zai-minio/</id>
    <published>2023-01-12T03:15:36.000Z</published>
    <updated>2023-01-12T03:18:32.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CVAT挂载MINIO"><a href="#CVAT挂载MINIO" class="headerlink" title="CVAT挂载MINIO"></a>CVAT挂载MINIO</h2><p><a href="https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/">https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export CVAT_HOST&#x3D;10.9.98.213export no_proxy&#x3D;localhost,127.0.0.1,.example.com,172.19.0.0&#x2F;16,172.20.0.0&#x2F;16,172.17.0.0&#x2F;16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>```shell<br>docker-compose up -d<pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;shelldocker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>docker-compose -f docker-compose.yml -f components/serverless/docker-compose.serverless.yml up -d</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;openvino&#x2F;docker-compose.openvino.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  up -d --build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="s3fs挂载minio存储"><a href="#s3fs挂载minio存储" class="headerlink" title="s3fs挂载minio存储"></a>s3fs挂载minio存储</h3><ol><li><p>安装 s3fs：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在文件中输入您的凭据<code>$&#123;HOME&#125;/.passwd-s3fs</code>并设置仅所有者权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo ACCESS_KEY_ID:SECRET_ACCESS_KEY &gt; $&#123;HOME&#125;&#x2F;.passwd-s3fschmod 600 $&#123;HOME&#125;&#x2F;.passwd-s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>user_allow_other</code>在<code>/etc/fuse.conf</code>文件中取消注释：<code>sudo nano /etc/fuse.conf</code></p></li><li><p>运行 s3fs，替换<code>bucket_name</code>，<code>mount_point</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;$&#123;HOME&#125;&#x2F;.passwd-s3fs -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h4><p>按照上面的前 3 个安装步骤进行操作。</p><h5 id="使用-fstab"><a href="#使用-fstab" class="headerlink" title="使用 fstab"></a>使用 fstab</h5><ol><li><p>使用以下内容创建一个名为 aws_s3_fuse 的 bash 脚本（例如在 /usr/bin 中，以 root 身份）（替换<code>user_name</code>将安装磁盘的代表，<code>backet_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashsudo -u root s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_styleexit 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ol><li><p>给它执行权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod +x &#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑<code>/etc/fstab</code>添加这样一行，替换<code>mount_point</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse  &#x2F;mnt&#x2F;share     fuse    allow_other,user,_netdev     0       0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="使用系统"><a href="#使用系统" class="headerlink" title="使用系统"></a>使用系统</h5><ol><li><p>创建单元文件<code>sudo nano /etc/systemd/system/s3fs.service</code> （替换<code>user_name</code>, <code>bucket_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Unit]Description&#x3D;FUSE filesystem over AWS S3 bucketAfter&#x3D;network.target[Service]Environment&#x3D;&quot;MOUNT_POINT&#x3D;&#x2F;mnt&#x2F;share&quot;User&#x3D;rootGroup&#x3D;rootExecStart&#x3D;s3fs cvat &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style -o umask&#x3D;0000 -o endpoint&#x3D;fr-parExecStop&#x3D;fusermount -u &#x2F;mnt&#x2F;shareRestart&#x3D;alwaysType&#x3D;forking[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新系统配置，系统启动时启用unit autorun，挂载bucket：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reloadsudo systemctl enable s3fs.servicesudo systemctl start s3fs.service# 卸载$ fusermount -u &#x2F;mnt&#x2F;share&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看</p><p>一个文件<code>/etc/mtab</code>包含当前挂载的文件系统的记录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;mtab | grep &#39;s3fs&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CVAT挂载MINIO&quot;&gt;&lt;a href=&quot;#CVAT挂载MINIO&quot; class=&quot;headerlink&quot; title=&quot;CVAT挂载MINIO&quot;&gt;&lt;/a&gt;CVAT挂载MINIO&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://opencv.github.io/</summary>
      
    
    
    
    <category term="cvat minio" scheme="https://knowledge-things.github.io/categories/cvat-minio/"/>
    
    
    <category term="cvat" scheme="https://knowledge-things.github.io/tags/cvat/"/>
    
  </entry>
  
  <entry>
    <title>IMX219 Camera</title>
    <link href="https://knowledge-things.github.io/2023/01/10/imx219-camera/"/>
    <id>https://knowledge-things.github.io/2023/01/10/imx219-camera/</id>
    <published>2023-01-10T09:34:39.000Z</published>
    <updated>2023-01-10T09:48:56.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 参数</p><p><a href="https://www.waveshare.net/wiki/IMX219-77IR_Camera#.E9.80.9A.E7.94.A8.E7.9A.84.E6.8C.87.E4.BB.A4.E8.AE.BE.E7.BD.AE.E9.80.89.E9.A1.B9">https://www.waveshare.net/wiki/IMX219-77IR_Camera#.E9.80.9A.E7.94.A8.E7.9A.84.E6.8C.87.E4.BB.A4.E8.AE.BE.E7.BD.AE.E9.80.89.E9.A1.B9</a></p></blockquote><ul><li>800万像素</li><li>感光芯片： IMX219</li><li>分辨率: 3280 x 2464</li><li>Support 1080p30, 720p60 and 640x480p90 video record</li><li>摄像头参数:<ul><li>CMOS尺寸：1/4英寸</li><li>光圈（F）：2.35</li><li>焦距（Focal Length）：3.15mm</li><li>对角视场角（FOV）：160度</li><li>畸变（Distortion）：&lt; 14.3%</li><li>镜头尺寸：6.5mm × 6.5mm</li></ul></li></ul><h2 id="如果摄像头拍摄效果偏红的话，可以按照以下步骤操作"><a href="#如果摄像头拍摄效果偏红的话，可以按照以下步骤操作" class="headerlink" title="如果摄像头拍摄效果偏红的话，可以按照以下步骤操作"></a>如果摄像头拍摄效果偏红的话，可以按照以下步骤操作</h2><p>1.下载camera-override.isp文件，解压到特定文件夹</p><pre class="line-numbers language-none"><code class="language-none">wget http:&#x2F;&#x2F;www.waveshare.net&#x2F;w&#x2F;upload&#x2F;e&#x2F;eb&#x2F;Camera_overrides.tar.gztar zxvf Camera_overrides.tar.gz sudo cp camera_overrides.isp &#x2F;var&#x2F;nvidia&#x2F;nvcam&#x2F;settings&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.安装文件：</p><pre class="line-numbers language-none"><code class="language-none">sudo chmod 664 &#x2F;var&#x2F;nvidia&#x2F;nvcam&#x2F;settings&#x2F;camera_overrides.ispsudo chown root:root &#x2F;var&#x2F;nvidia&#x2F;nvcam&#x2F;settings&#x2F;camera_overrides.isp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><pre class="line-numbers language-none"><code class="language-none">gst-launch-1.0 nvarguscamerasrc sensor_mode&#x3D;0 sensor_id&#x3D;0 wbmode&#x3D;3 !  &#39;video&#x2F;x-raw(memory:NVMM),width&#x3D;3280, height&#x3D;2464, framerate&#x3D;21&#x2F;1, format&#x3D;NV12&#39; ! nvvidconv flip-method&#x3D;0 ! &#39;video&#x2F;x-raw, width&#x3D;1920, height&#x3D;1080&#39; ! nvvidconv ! nvegltransform ! nveglglessink -e<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 参数&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.waveshare.net/wiki/IMX219-77IR_Camera#.E9.80.9A.E7.94.A8.E7.9A.84.E6.8C.87.E4.BB.A4.E8.AE.BE</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Jupyter Lab 设置</title>
    <link href="https://knowledge-things.github.io/2023/01/10/jupyter-lab-she-zhi/"/>
    <id>https://knowledge-things.github.io/2023/01/10/jupyter-lab-she-zhi/</id>
    <published>2023-01-10T07:11:30.000Z</published>
    <updated>2023-03-31T06:04:14.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Jupyter-Lab-安装"><a href="#1-Jupyter-Lab-安装" class="headerlink" title="1. Jupyter Lab 安装"></a>1. Jupyter Lab 安装</h2><p>安装 JupyterLab 非常简单，只需一行命令即可：</p><h3 id="conda-安装-Miniconda"><a href="#conda-安装-Miniconda" class="headerlink" title="conda 安装 [Miniconda]"></a>conda 安装 [Miniconda]</h3><pre class="line-numbers language-none"><code class="language-none">conda install -c conda-forge jupyterlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip install jupyterlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-JupyterLab-安全验证"><a href="#2-JupyterLab-安全验证" class="headerlink" title="2. JupyterLab 安全验证"></a>2. JupyterLab 安全验证</h3><p>JupyterLab 使用密码保证服务的安全，从而确保其他用户无法登录使用。默认情况下，会自动生成随机密码，如 ： <a href="http://127.0.0.1:8888/lab?token=2cefb80900a38689d9d0d2c4927832fa4ae322b1e441c601，其中">http://127.0.0.1:8888/lab?token=2cefb80900a38689d9d0d2c4927832fa4ae322b1e441c601，其中</a> token=密码。</p><p>为方便远程登录，可手动设置密码，方法如下：</p><ul><li><p>生成配置文件</p><pre class="line-numbers language-none"><code class="language-none">jupyter server --generate-config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>该命令会在 ~/.jupyter 目录下生成配置文件 jupyter_server_config.py, 如果该配置文件已经存在，则会提示是否替换该文件。</p><ul><li><p>手动设置密码</p><pre class="line-numbers language-none"><code class="language-none">jupyter server password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>启动Jupyter</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 后台启动  nohup jupyter-lab --ip&#x3D;0.0.0.0 --port&#x3D;8088 --allow-root --notebook-dir&#x3D;&#x2F;data&#x2F;workspace&#x2F;PaddleDetection&#x2F; &gt; &#x2F;dev&#x2F;null &amp;l &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="安装NVDashboard插件"><a href="#安装NVDashboard插件" class="headerlink" title="安装NVDashboard插件"></a>安装NVDashboard插件</h2><p><em>该插件依赖nodejs</em>,安装插件之后重启Jupyter</p>  <pre class="line-numbers language-none"><code class="language-none">conda install -c conda-forge&#x2F;label&#x2F;cf202003 nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>JupyterLab &gt;= 3.0</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-none"><code class="language-none">pip install jupyterlab_nvdashboard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h2><p>如果您看到前端扩展，但它不工作，请检查服务器扩展是否已启用：</p><pre class="line-numbers language-none"><code class="language-none">jupyter server extension list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果服务器扩展已安装并启用，但您没有看到前端扩展，请检查前端扩展是否已安装：</p><pre class="line-numbers language-none"><code class="language-none">jupyter labextension list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Jupyter-Lab-安装&quot;&gt;&lt;a href=&quot;#1-Jupyter-Lab-安装&quot; class=&quot;headerlink&quot; title=&quot;1. Jupyter Lab 安装&quot;&gt;&lt;/a&gt;1. Jupyter Lab 安装&lt;/h2&gt;&lt;p&gt;安装 JupyterLa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>公开数据集</title>
    <link href="https://knowledge-things.github.io/2023/01/09/gong-kai-shu-ju-ji/"/>
    <id>https://knowledge-things.github.io/2023/01/09/gong-kai-shu-ju-ji/</id>
    <published>2023-01-09T03:40:36.000Z</published>
    <updated>2023-01-09T03:54:12.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://captain-whu.github.io/DOTA/">DOTA遥感数据集</a><br>类别：飞机、轮船、储罐、棒球场、网球场、篮球场、田径场、港口、桥梁、大型车辆、小型车辆、直升机、环岛、足球场、游泳池、集装箱起重机、机场和直升机停机坪</p></blockquote><p><a href="https://bj.bcebos.com/v1/paddledet/data/smalldet/visdrone.zip">VisDrone-DET无人机航拍小目标数据集</a><br><a href="https://bj.bcebos.com/v1/paddledet/data/smalldet/xview_sliced.zip">Xview大型遥感监测数据集</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://captain-whu.github.io/DOTA/&quot;&gt;DOTA遥感数据集&lt;/a&gt;&lt;br&gt;类别：飞机、轮船、储罐、棒球场、网球场、篮球场、田径场、港口、桥梁、大型车辆、小型车辆、直升机、环岛、足球场、游泳池、集装</summary>
      
    
    
    
    
    <category term="数据集" scheme="https://knowledge-things.github.io/tags/%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Paddle系列Jetson推理</title>
    <link href="https://knowledge-things.github.io/2023/01/04/paddle-xi-lie-jetson-tui-li/"/>
    <id>https://knowledge-things.github.io/2023/01/04/paddle-xi-lie-jetson-tui-li/</id>
    <published>2023-01-04T08:21:13.000Z</published>
    <updated>2023-01-04T08:25:43.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jetson-Paddle模型推理"><a href="#Jetson-Paddle模型推理" class="headerlink" title="Jetson Paddle模型推理"></a>Jetson Paddle模型推理</h1><p><em>查看当前cmake版本，版本最大于3.13.0，否则download时openssl会验证失败，原因低版本cmake编译时libcurl并为加入对https支持</em></p><p>报错如下：</p><p><code>log: Protocol &quot;https&quot; not supported or disabled in libcurl</code></p><p><code>cmake --version</code></p><h2 id="更新cmake"><a href="#更新cmake" class="headerlink" title="更新cmake"></a>更新cmake</h2><pre class="line-numbers language-none"><code class="language-none">version&#x3D;3.25build&#x3D;1mkdir ~&#x2F;tempcd ~&#x2F;tempwget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v$version&#x2F;cmake-$version.$build.tar.gztar -xzvf cmake-$version.$build.tar.gzcd cmake-$version.$build&#x2F;.&#x2F;bootstrap  # 这一步会等很久  也可以执行 .&#x2F;configemake -j4   # 使用命令 nproc 查看自己有多少个核心， 我这里用了4个核心编译make，速度快一点 sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用FastDeploy推理"><a href="#使用FastDeploy推理" class="headerlink" title="使用FastDeploy推理"></a>使用FastDeploy推理</h2><blockquote><p><a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/install/download_lib.html#c">https://www.paddlepaddle.org.cn/inference/v2.4/guides/install/download_lib.html#c</a></p><p><a href="https://github.com/PaddlePaddle/FastDeploy/blob/release/1.0.2/docs/cn/build_and_install/jetson.md">https://github.com/PaddlePaddle/FastDeploy/blob/release/1.0.2/docs/cn/build_and_install/jetson.md</a></p><p>(Paddle推理支持列表)[<a href="https://ai.baidu.com/easyedge/app/adapt">https://ai.baidu.com/easyedge/app/adapt</a>]</p></blockquote><h2 id="Jetson部署库编译"><a href="#Jetson部署库编译" class="headerlink" title="Jetson部署库编译"></a>Jetson部署库编译</h2><p>FastDeploy当前在Jetson仅支持ONNX Runtime CPU和TensorRT GPU/Paddle Inference三种后端推理</p><h2 id="C-SDK编译安装"><a href="#C-SDK编译安装" class="headerlink" title="C++ SDK编译安装"></a>C++ SDK编译安装</h2><p>编译需满足</p><ul><li>gcc/g++ &gt;= 5.4(推荐8.2)</li><li>cmake &gt;= 3.10.0</li><li>jetpack &gt;= 4.6.1</li></ul><p>如果需要集成Paddle Inference后端，在<a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/install/download_lib.html#c">Paddle Inference预编译库</a>页面根据开发环境选择对应的Jetpack C++包下载，并解压。</p><p><em>编译FastDeploy时，当打开开关<code>BUILD_ON_JETSON</code>时，会默认开启<code>ENABLE_ORT_BACKEND</code>和<code>ENABLE_TRT_BACKEND</code>，即当前仅支持<code>ONNXRuntime CPU</code>或T<code>ensorRT</code>两种后端分别用于在<code>CPU</code>和<code>GPU</code>上的推理。因此，这里的GPU推理并不会生效，而是会自动转成CPU推理。</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;PaddlePaddle&#x2F;FastDeploy.gitcd FastDeploymkdir build &amp;&amp; cd buildcmake .. -DBUILD_ON_JETSON&#x3D;ON \         -DENABLE_VISION&#x3D;ON \         -DENABLE_TRT_BACKEND&#x3D;ON \         -DWITH_GPU&#x3D;ON \         -DENABLE_PADDLE_BACKEND&#x3D;ON \ # 可选项，如若不需要Paddle Inference后端，可关闭         -DPADDLEINFERENCE_DIRECTORY&#x3D;&#x2F;home&#x2F;nvidia&#x2F;paddle_inference_install_dir \         -DCMAKE_INSTALL_PREFIX&#x3D;$&#123;PWD&#125;&#x2F;installed_fastdeploy \         -DOPENCV_DIRECTORY&#x3D;&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;cmake&#x2F;opencv4 \# 不安装paddle后端推理可使用如下命令cmake .. -DBUILD_ON_JETSON&#x3D;ON -DENABLE_VISION&#x3D;ON -DCMAKE_INSTALL_PREFIX&#x3D;$&#123;PWD&#125;&#x2F;installed_fastdeploy -DWITH_GPU&#x3D;ON -DENABLE_TRT_BACKEND&#x3D;ON -DOPENCV_DIRECTORY&#x3D;&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;cmake&#x2F;opencv4 -DTRT_DIRECTORY&#x3D;&#x2F;usr&#x2F;src&#x2F;tensorrtsudo make -j8sudo make installsource &#x2F;home&#x2F;nvidia&#x2F;FastDeploy&#x2F;build&#x2F;installed_fastdeploy&#x2F;fastdeploy_init.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成后，即在<code>CMAKE_INSTALL_PREFIX</code>指定的目录下生成C++推理库</p><h2 id="C-推理"><a href="#C-推理" class="headerlink" title="C++推理"></a>C++推理</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">以yolox为例进行推理部署cd FastDeploy&#x2F;examples&#x2F;vision&#x2F;detection&#x2F;paddledetection&#x2F;cpp&#x2F;buildmkdir build &amp;&amp; cd buildcmake .. -DFASTDEPLOY_INSTALL_DIR&#x3D;&#x2F;home&#x2F;nvidia&#x2F;FastDeploy&#x2F;build&#x2F;installed_fastdeploymake -j6# GPU推理.&#x2F;infer_yolox_demo .&#x2F;yolox_convnext_s_36e_coco&#x2F; wsz138.jpg 0# GPU上TensorRT推理.&#x2F;infer_yolox_demo .&#x2F;yolox_convnext_s_36e_coco&#x2F; wsz138.jpg 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>FastDeploy 默认采用TRT-FP32的推理。如果需要使用TRT-FP16的推理，设置的方法很简单，只需要在代码中加入一行 option.EnableTrtFP16() 即可。</p><p>【格外注意】当需要在TRT-FP32和TRT-FP16之间切换时，别忘了先删除保存的 trt 缓存文件。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void TrtInfer(const std::string&amp; model_dir, const std::string&amp; image_file) &#123;  auto model_file &#x3D; model_dir + sep + &quot;model.pdmodel&quot;;  auto params_file &#x3D; model_dir + sep + &quot;model.pdiparams&quot;;  auto config_file &#x3D; model_dir + sep + &quot;infer_cfg.yml&quot;;  auto option &#x3D; fastdeploy::RuntimeOption();  option.UseGpu();  option.UseTrtBackend();  option.SetTrtCacheFile(&quot;.&#x2F;tensorrt_cache&#x2F;model.trt&quot;);  option.EnableTrtFP16();  auto model &#x3D; fastdeploy::vision::detection::PaddleYOLOX(      model_file, params_file, config_file, option);  if (!model.Initialized()) &#123;    std::cerr &lt;&lt; &quot;Failed to initialize.&quot; &lt;&lt; std::endl;    return;  &#125;  auto im &#x3D; cv::imread(image_file);  fastdeploy::vision::DetectionResult res;  if (!model.Predict(im, &amp;res)) &#123;    std::cerr &lt;&lt; &quot;Failed to predict.&quot; &lt;&lt; std::endl;    return;  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python编译安装"><a href="#Python编译安装" class="headerlink" title="Python编译安装"></a>Python编译安装</h2><p>编译过程同样需要满足</p><ul><li>gcc/g++ &gt;= 5.4(推荐8.2)</li><li>cmake &gt;= 3.10.0</li><li>jetpack &gt;= 4.6.1</li><li>python &gt;= 3.6</li></ul><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update &amp;&amp; sudo apt-get install python-pip python3-pippip3 install cython<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Python打包依赖<code>wheel</code>，编译前请先执行<code>pip install wheel</code></p><p>如果需要集成Paddle Inference后端，在<a href="https://www.paddlepaddle.org.cn/inference/v2.4/guides/install/download_lib.html#c">Paddle Inference预编译库</a>页面根据开发环境选择对应的Jetpack C++包下载，并解压。</p><p>所有编译选项通过环境变量导入</p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;paddle-inference-lib.bj.bcebos.com&#x2F;2.4.1&#x2F;cxx_c&#x2F;Jetson&#x2F;jetpack4.6_gcc7.5&#x2F;xavier&#x2F;paddle_inference_install_dir.tgzsudo tar zxvf paddle_inference_install_dir.tgz -C &#x2F;usr&#x2F;local&#x2F;src&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git clone https:&#x2F;&#x2F;github.com&#x2F;PaddlePaddle&#x2F;FastDeploy.gitcd FastDeploy&#x2F;pythonexport BUILD_ON_JETSON&#x3D;ONexport ENABLE_VISION&#x3D;ON# ENABLE_PADDLE_BACKEND &amp; PADDLEINFERENCE_DIRECTORY为可选项export ENABLE_PADDLE_BACKEND&#x3D;ONexport PADDLEINFERENCE_DIRECTORY&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;paddle_inference_install_dir&#x2F;python3 setup.py buildpython3 setup.py bdist_wheel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译完成即会在<code>FastDeploy/python/dist</code>目录下生成编译后的<code>wheel</code>包，直接pip install即可</p><p>编译过程中，如若修改编译参数，为避免带来缓存影响，可删除<code>FastDeploy/python</code>目录下的<code>build</code>和<code>.setuptools-cmake-build</code>两个子目录后再重新编译</p><h2 id="Python推理"><a href="#Python推理" class="headerlink" title="Python推理"></a>Python推理</h2><p>在部署前，需要先将PaddleDetection导出成部署模型，导出步骤参考文档<a href="https://github.com/PaddlePaddle/PaddleDetection/blob/release/2.4/deploy/EXPORT_MODEL.md">导出模型</a></p><p><strong>注意</strong></p><ul><li>在导出模型时不要进行NMS的去除操作，正常导出即可</li><li>如果用于跑原生TensorRT后端（非Paddle Inference后端），不要添加—trt参数</li><li>导出模型时，不要添加<code>fuse_normalize=True</code>参数</li></ul><pre class="line-numbers language-none"><code class="language-none">cd &#x2F;FastDeploy&#x2F;examples&#x2F;vision&#x2F;detection&#x2F;paddledetection&#x2F;python#下载模型文件和测试图片,可使用PaddleDetectin导出的模型# GPU上使用TensorRT推理python3 infer_yolox.py --model_dir yolox_convnext_s_36e_coco --image wsz138.jpg --device gpu --use_trt True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数</strong></p><blockquote><ul><li><strong>model_file</strong>(str): 模型文件路径</li><li><strong>params_file</strong>(str): 参数文件路径</li><li><strong>config_file</strong>(str): 推理配置yaml文件路径</li><li><strong>runtime_option</strong>(RuntimeOption): 后端推理配置，默认为None，即采用默认配置</li><li><strong>model_format</strong>(ModelFormat): 模型格式，默认为Paddle</li></ul></blockquote><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Jetson-Paddle模型推理&quot;&gt;&lt;a href=&quot;#Jetson-Paddle模型推理&quot; class=&quot;headerlink&quot; title=&quot;Jetson Paddle模型推理&quot;&gt;&lt;/a&gt;Jetson Paddle模型推理&lt;/h1&gt;&lt;p&gt;&lt;em&gt;查看当前cm</summary>
      
    
    
    
    <category term="FastDeploy TensorRT" scheme="https://knowledge-things.github.io/categories/FastDeploy-TensorRT/"/>
    
    
    <category term="paddle" scheme="https://knowledge-things.github.io/tags/paddle/"/>
    
  </entry>
  
  <entry>
    <title>git代理设置</title>
    <link href="https://knowledge-things.github.io/2023/01/03/git-dai-li-she-zhi/"/>
    <id>https://knowledge-things.github.io/2023/01/03/git-dai-li-she-zhi/</id>
    <published>2023-01-03T02:35:16.000Z</published>
    <updated>2023-03-31T06:04:05.832Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-none"><code class="language-none">git config --global https.proxy http:&#x2F;&#x2F;192.168.55.100:7890git config --global https.proxy https:&#x2F;&#x2F;192.168.55.100:7890git config --global --unset http.proxygit config --global --unset https.proxynpm config delete proxy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;git config --global https.proxy http:&amp;#x2F;&amp;#x2F;192.168.55.100:7890

gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>s3fs挂载minio存储</title>
    <link href="https://knowledge-things.github.io/2023/01/03/s3fs-gua-zai-minio-cun-chu/"/>
    <id>https://knowledge-things.github.io/2023/01/03/s3fs-gua-zai-minio-cun-chu/</id>
    <published>2023-01-03T02:12:27.000Z</published>
    <updated>2023-01-03T02:12:41.212Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/">https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/</a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">export CVAT_HOST&#x3D;10.9.98.213export no_proxy&#x3D;localhost,127.0.0.1,.example.com,172.19.0.0&#x2F;16,172.20.0.0&#x2F;16,172.17.0.0&#x2F;16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>```shell<br>docker-compose up -d<pre class="line-numbers language-none"><code class="language-none">&#96;&#96;&#96;shelldocker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>docker-compose -f docker-compose.yml -f components/serverless/docker-compose.serverless.yml up -d</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">docker-compose -f docker-compose.yml -f docker-compose.override.yml -f components&#x2F;serverless&#x2F;docker-compose.serverless.yml -f components&#x2F;cuda&#x2F;docker-compose.cuda.yml -f components&#x2F;openvino&#x2F;docker-compose.openvino.yml -f components&#x2F;analytics&#x2F;docker-compose.analytics.yml -f components&#x2F;tf_annotation&#x2F;docker-compose.tf_annotation.yml  -f docker-compose.override.yml  up -d --build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker exec -it cvat_server bash -ic &#39;python3 ~&#x2F;manage.py createsuperuser&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="s3fs挂载minio存储"><a href="#s3fs挂载minio存储" class="headerlink" title="s3fs挂载minio存储"></a>s3fs挂载minio存储</h3><ol><li><p>安装 s3fs：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt install s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在文件中输入您的凭据<code>$&#123;HOME&#125;/.passwd-s3fs</code>并设置仅所有者权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo ACCESS_KEY_ID:SECRET_ACCESS_KEY &gt; $&#123;HOME&#125;&#x2F;.passwd-s3fschmod 600 $&#123;HOME&#125;&#x2F;.passwd-s3fs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>user_allow_other</code>在<code>/etc/fuse.conf</code>文件中取消注释：<code>sudo nano /etc/fuse.conf</code></p></li><li><p>运行 s3fs，替换<code>bucket_name</code>，<code>mount_point</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;$&#123;HOME&#125;&#x2F;.passwd-s3fs -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h4><p>按照上面的前 3 个安装步骤进行操作。</p><h5 id="使用-fstab"><a href="#使用-fstab" class="headerlink" title="使用 fstab"></a>使用 fstab</h5><ol><li><p>使用以下内容创建一个名为 aws_s3_fuse 的 bash 脚本（例如在 /usr/bin 中，以 root 身份）（替换<code>user_name</code>将安装磁盘的代表，<code>backet_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashsudo -u root s3fs test &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_styleexit 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><ol><li><p>给它执行权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo chmod +x &#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>编辑<code>/etc/fstab</code>添加这样一行，替换<code>mount_point</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;usr&#x2F;bin&#x2F;aws_s3_fuse  &#x2F;mnt&#x2F;share     fuse    allow_other,user,_netdev     0       0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h5 id="使用系统"><a href="#使用系统" class="headerlink" title="使用系统"></a>使用系统</h5><ol><li><p>创建单元文件<code>sudo nano /etc/systemd/system/s3fs.service</code> （替换<code>user_name</code>, <code>bucket_name</code>, <code>mount_point</code>, <code>/path/to/.passwd-s3fs</code>）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[Unit]Description&#x3D;FUSE filesystem over AWS S3 bucketAfter&#x3D;network.target[Service]Environment&#x3D;&quot;MOUNT_POINT&#x3D;&#x2F;mnt&#x2F;share&quot;User&#x3D;rootGroup&#x3D;rootExecStart&#x3D;s3fs cvat &#x2F;mnt&#x2F;share&#x2F; -o passwd_file&#x3D;&#x2F;root&#x2F;.passwd-s3fs -o allow_other -o  url&#x3D;http:&#x2F;&#x2F;localhost:9000&#x2F; -o use_path_request_style -o umask&#x3D;0000 -o endpoint&#x3D;fr-parExecStop&#x3D;fusermount -u &#x2F;mnt&#x2F;shareRestart&#x3D;alwaysType&#x3D;forking[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新系统配置，系统启动时启用unit autorun，挂载bucket：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo systemctl daemon-reloadsudo systemctl enable s3fs.servicesudo systemctl start s3fs.service# 卸载$ fusermount -u &#x2F;mnt&#x2F;share&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看</p><p>一个文件<code>/etc/mtab</code>包含当前挂载的文件系统的记录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat &#x2F;etc&#x2F;mtab | grep &#39;s3fs&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://opencv.github.io/cvat/docs/administration/advanced/installation_automatic_annotation/&quot;&gt;https://opencv.github.io/cvat/doc</summary>
      
    
    
    
    
    <category term="minio" scheme="https://knowledge-things.github.io/tags/minio/"/>
    
  </entry>
  
  <entry>
    <title>TensorRT环境安装</title>
    <link href="https://knowledge-things.github.io/2022/12/28/tensorrt-huan-jing-an-zhuang/"/>
    <id>https://knowledge-things.github.io/2022/12/28/tensorrt-huan-jing-an-zhuang/</id>
    <published>2022-12-28T05:53:28.000Z</published>
    <updated>2023-01-03T02:11:38.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ONNX"><a href="#ONNX" class="headerlink" title="ONNX"></a>ONNX</h1><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><pre class="line-numbers language-none"><code class="language-none">!pip install -U numpy&#x3D;&#x3D;1.23.1!pip install -U onnx&#x3D;&#x3D;1.12.0!pip install -U onnxruntime&#x3D;&#x3D;1.12.1!pip install -U protobuf&#x3D;&#x3D;3.16.0!pip install -U typing-extensions&#x3D;&#x3D;4.4.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ubuntu users: the quickest way to install protobuf is to run</p><pre class="line-numbers language-none"><code class="language-none">apt-get install python3-pip python3-dev libprotobuf-dev protobuf-compiler<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Then you can build ONNX as:</p><pre class="line-numbers language-none"><code class="language-none">export CMAKE_ARGS&#x3D;&quot;-DONNX_USE_PROTOBUF_SHARED_LIBS&#x3D;ON&quot;git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;onnx&#x2F;onnx.gitcd onnx# prefer lite protoset CMAKE_ARGS&#x3D;-DONNX_USE_LITE_PROTO&#x3D;ONpip install -e .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Verify-Installation"><a href="#Verify-Installation" class="headerlink" title="Verify Installation"></a>Verify Installation</h2><p>After installation, run</p><pre class="line-numbers language-none"><code class="language-none">python -c &quot;import onnx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>ONNX uses <a href="https://docs.pytest.org/">pytest</a> as test driver. In order to run tests, you will first need to install pytest:</p><pre class="line-numbers language-none"><code class="language-none">pip install pytest nbval<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>After installing pytest, use the following command to run tests.</p><pre class="line-numbers language-none"><code class="language-none">pytest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h1><p><a href="https://github.com/google/benchmark/tree/0d98dba29d66e93259db7daa53a9327df767a415">https://github.com/google/benchmark/tree/0d98dba29d66e93259db7daa53a9327df767a415</a></p><h2 id="Installation-1"><a href="#Installation-1" class="headerlink" title="Installation"></a>Installation</h2><pre class="line-numbers language-none"><code class="language-none"># Check out the library.$ git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;benchmark.git# Go to the library root directory$ cd benchmark# Make a build directory to place the build output.$ cmake -E make_directory &quot;build&quot;# Generate build system files with cmake, and download any dependencies.$ cmake -E chdir &quot;build&quot; cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES&#x3D;on -DCMAKE_BUILD_TYPE&#x3D;Release ..&#x2F;# or, starting with CMake 3.13, use a simpler form:# cmake -DCMAKE_BUILD_TYPE&#x3D;Release -S . -B &quot;build&quot;# Build the library.$ cmake --build &quot;build&quot; --config Release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fatal: 无法访问 ‘<a href="https://github.com/openstreetmap/osmosis.git/’：GnuTLS">https://github.com/openstreetmap/osmosis.git/’：GnuTLS</a> recv error (-110): The TLS connection was non-properly terminated.</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><p>关掉ssl<br>输入以下代码：</p><pre class="line-numbers language-none"><code class="language-none">apt-get install gnutls-bingit config --global http.sslVerify falsegit config --global http.postBuffer 1048576000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="pybind11"><a href="#pybind11" class="headerlink" title="pybind11"></a>pybind11</h2><pre class="line-numbers language-none"><code class="language-none">$ cd &#x2F;workspace&#x2F;TensorRT&#x2F;parsers&#x2F;onnx&#x2F;third_party&#x2F;onnx&#x2F;third_party&#x2F;$ git clone https:&#x2F;&#x2F;github.com&#x2F;pybind&#x2F;pybind11.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h3><p>运行<code>yolov5</code>时<code>docker</code>容器报错：<code>ImportError: libGL.so.1: cannot open shared object file: No such file or directory</code>。</p><p>解决办法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get install ffmpeg libsm6 libxext6  -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">$ cd $TRT_OSSPATH $ mkdir -p build &amp;&amp; cd build $ cmake .. -DTRT_LIB_DIR&#x3D;$TRT_LIBPATH -DTRT_OUT_DIR&#x3D;&#96;pwd&#96;&#x2F;out $ make -j$(nproc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ONNX&quot;&gt;&lt;a href=&quot;#ONNX&quot; class=&quot;headerlink&quot; title=&quot;ONNX&quot;&gt;&lt;/a&gt;ONNX&lt;/h1&gt;&lt;h2 id=&quot;Installation&quot;&gt;&lt;a href=&quot;#Installation&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Jetson TX2上升级cmake方法</title>
    <link href="https://knowledge-things.github.io/2022/12/20/jetson-tx2-shang-sheng-ji-cmake-fang-fa/"/>
    <id>https://knowledge-things.github.io/2022/12/20/jetson-tx2-shang-sheng-ji-cmake-fang-fa/</id>
    <published>2022-12-20T01:53:21.000Z</published>
    <updated>2022-12-20T01:56:26.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从源码安装camke"><a href="#从源码安装camke" class="headerlink" title="从源码安装camke"></a>从源码安装camke</h1><h2 id="1-删除默认的cmake"><a href="#1-删除默认的cmake" class="headerlink" title="1. 删除默认的cmake"></a>1. 删除默认的cmake</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt remove cmakesudo apt purge --auto-remove cmake<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-从官网下载所需版本，解压，创建build文件夹"><a href="#2-从官网下载所需版本，解压，创建build文件夹" class="headerlink" title="2. 从官网下载所需版本，解压，创建build文件夹"></a>2. 从官网下载所需版本，解压，创建build文件夹</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">version&#x3D;3.13build&#x3D;3mkdir ~&#x2F;tempcd ~&#x2F;tempwget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v$version&#x2F;cmake-$version.$build.tar.gztar -xzvf cmake-$version.$build.tar.gzcd cmake-$version.$build&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.&#x2F;bootstrapmake -j4sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-移动路径"><a href="#4-移动路径" class="headerlink" title="4. 移动路径"></a>4. 移动路径</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cp .&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-验证安装结果"><a href="#5-验证安装结果" class="headerlink" title="5.验证安装结果"></a>5.验证安装结果</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出：<br><pre class="line-numbers language-none"><code class="language-none">cmake version 3.13.3CMake suite maintained and supported by Kitware (kitware.com&#x2F;cmake).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从源码安装camke&quot;&gt;&lt;a href=&quot;#从源码安装camke&quot; class=&quot;headerlink&quot; title=&quot;从源码安装camke&quot;&gt;&lt;/a&gt;从源码安装camke&lt;/h1&gt;&lt;h2 id=&quot;1-删除默认的cmake&quot;&gt;&lt;a href=&quot;#1-删除默认的cm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阅读记录-2022/12</title>
    <link href="https://knowledge-things.github.io/2022/12/06/yue-du-ji-lu-2022-12/"/>
    <id>https://knowledge-things.github.io/2022/12/06/yue-du-ji-lu-2022-12/</id>
    <published>2022-12-06T02:01:36.000Z</published>
    <updated>2023-01-10T09:15:31.689Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.51cto.com/article/677110.html">digiKam使用</a><br><a href="https://snapcraft.io/install/digikam/ubuntu">snap digiKam</a><br><a href="https://linuxhint.com/setup-configure-autocomplete-zsh/">Ubuntu zsh autoComplete</a><br><a href="https://catalog.ngc.nvidia.com/orgs/nvidia/containers/paddlepaddle/tags">Paddle Nvidia Containers</a><br><a href="https://github.com/NVIDIA/DeepLearningExamples">NVIDIA DeepLearningExamples</a><br><a href="https://github.com/PINTO0309/openvino2tensorflow">openvino2tensorflow</a><br><a href="https://netron.app/">netron可视化网络</a><br><a href="https://github.com/PaddlePaddle/PaddleClas/blob/v2.4.0/docs/zh_CN/PULC/PULC_safety_helmet.md">PULC 佩戴安全帽分类模型</a><br><a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/distributed/launch_cn.html">Paddle多机多卡训练</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.51cto.com/article/677110.html&quot;&gt;digiKam使用&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://snapcraft.io/install/digikam/ubuntu&quot;&gt;snap digiKam&lt;/</summary>
      
    
    
    
    
    <category term="阅读记录" scheme="https://knowledge-things.github.io/tags/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter NoteBook 的快捷鍵</title>
    <link href="https://knowledge-things.github.io/2022/11/10/jupyter-notebook-de-kuai-jie-jian/"/>
    <id>https://knowledge-things.github.io/2022/11/10/jupyter-notebook-de-kuai-jie-jian/</id>
    <published>2022-11-10T07:14:31.000Z</published>
    <updated>2022-11-10T07:15:46.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）"><a href="#快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）" class="headerlink" title="快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:"></a>快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:</h3><div class="table-container"><table><thead><tr><th style="text-align:left">快捷鍵</th><th style="text-align:left">作用</th><th style="text-align:left">說明</th></tr></thead><tbody><tr><td style="text-align:left">Enter</td><td style="text-align:left">轉入編輯模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Enter</td><td style="text-align:left">運行本單元，選中下個單元</td><td style="text-align:left">新單元默認為命令模式</td></tr><tr><td style="text-align:left">Ctrl-Enter</td><td style="text-align:left">運行本單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Alt-Enter</td><td style="text-align:left">運行本單元，在其下插入新單元</td><td style="text-align:left">新單元默認為編輯模式</td></tr><tr><td style="text-align:left">Y</td><td style="text-align:left">單元轉入代碼狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">M</td><td style="text-align:left">單元轉入 markdown 狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">R</td><td style="text-align:left">單元轉入 raw 狀態</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">設定 1 級標題</td><td style="text-align:left">僅在 markdown 狀態下時建議使用標題相關快捷鍵，如果單元處於其他狀態，則會強制切換到 markdown 狀態</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">設定 2 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">設定 3 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">設定 4 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">設定 5 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">設定 6 級標題</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Up</td><td style="text-align:left">選中上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">K</td><td style="text-align:left">選中上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Down</td><td style="text-align:left">選中下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">選中下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-K</td><td style="text-align:left">連續選擇上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-J</td><td style="text-align:left">連續選擇下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">在上方插入新單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">在下方插入新單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">剪切選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">複製選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-V</td><td style="text-align:left">粘貼到上方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">粘貼到下方單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">恢復刪除的最後一個單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">D,D</td><td style="text-align:left">刪除選中的單元</td><td style="text-align:left">連續按兩個 D 鍵</td></tr><tr><td style="text-align:left">Shift-M</td><td style="text-align:left">合併選中的單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">開關行號</td><td style="text-align:left">編輯框的行號是可以開啟和關閉的</td></tr><tr><td style="text-align:left">O</td><td style="text-align:left">轉換輸出</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-O</td><td style="text-align:left">轉換輸出滾動</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Esc</td><td style="text-align:left">關閉頁面</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Q</td><td style="text-align:left">關閉頁面</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">H</td><td style="text-align:left">顯示快捷鍵幫助</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">I,I</td><td style="text-align:left">中斷 NoteBook 內核</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">0,0</td><td style="text-align:left">重啟 NoteBook 內核</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift</td><td style="text-align:left">忽略</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Space</td><td style="text-align:left">向上滾動</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Space</td><td style="text-align:left">向下滾動</td></tr></tbody></table></div><h3 id="編輯模式快捷鍵（-按-Enter-鍵啟動）"><a href="#編輯模式快捷鍵（-按-Enter-鍵啟動）" class="headerlink" title="編輯模式快捷鍵（ 按 Enter 鍵啟動）:"></a>編輯模式快捷鍵（ 按 Enter 鍵啟動）:</h3><div class="table-container"><table><thead><tr><th style="text-align:left">快捷鍵</th><th style="text-align:left">作用</th><th style="text-align:left">說明</th></tr></thead><tbody><tr><td style="text-align:left">Tab</td><td style="text-align:left">代碼補全或縮進</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Tab</td><td style="text-align:left">提示</td><td style="text-align:left">輸出幫助信息，部分函數、類、方法等會顯示其定義原型，如果在其後加 <code>?</code> 再運行會顯示更加詳細的幫助</td></tr><tr><td style="text-align:left">Ctrl-]</td><td style="text-align:left">縮進</td><td style="text-align:left">向右縮進</td></tr><tr><td style="text-align:left">Ctrl-[</td><td style="text-align:left">解除縮進</td><td style="text-align:left">向左縮進</td></tr><tr><td style="text-align:left">Ctrl-A</td><td style="text-align:left">全選</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Z</td><td style="text-align:left">撤銷</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Shift-Z</td><td style="text-align:left">重做</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Y</td><td style="text-align:left">重做</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Home</td><td style="text-align:left">跳到單元開頭</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Up</td><td style="text-align:left">跳到單元開頭</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-End</td><td style="text-align:left">跳到單元末尾</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Down</td><td style="text-align:left">跳到單元末尾</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Left</td><td style="text-align:left">跳到左邊一個字首</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Right</td><td style="text-align:left">跳到右邊一個字首</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Backspace</td><td style="text-align:left">刪除前面一個字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-Delete</td><td style="text-align:left">刪除後面一個字</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Esc</td><td style="text-align:left">切換到命令模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-M</td><td style="text-align:left">切換到命令模式</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift-Enter</td><td style="text-align:left">運行本單元，選中下一單元</td><td style="text-align:left">新單元默認為命令模式</td></tr><tr><td style="text-align:left">Ctrl-Enter</td><td style="text-align:left">運行本單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Alt-Enter</td><td style="text-align:left">運行本單元，在下面插入一單元</td><td style="text-align:left">新單元默認為編輯模式</td></tr><tr><td style="text-align:left">Ctrl-Shift—</td><td style="text-align:left">分割單元</td><td style="text-align:left">按光標所在行進行分割</td></tr><tr><td style="text-align:left">Ctrl-Shift-Subtract</td><td style="text-align:left">分割單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-S</td><td style="text-align:left">保存當前 NoteBook</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Shift</td><td style="text-align:left">忽略</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Up</td><td style="text-align:left">光標上移或轉入上一單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Down</td><td style="text-align:left">光標下移或轉入下一單元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Ctrl-/</td><td style="text-align:left">註釋整行/撤銷註釋</td><td style="text-align:left">僅代碼狀態有效</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）&quot;&gt;&lt;a href=&quot;#快捷鍵狀態的快捷鍵（按-Esc-鍵開啟）&quot; class=&quot;headerlink&quot; title=&quot;快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:&quot;&gt;&lt;/a&gt;快捷鍵狀態的快捷鍵（按 Esc 鍵開啟）:&lt;/h3</summary>
      
    
    
    
    
    <category term="Jupyter 快捷键" scheme="https://knowledge-things.github.io/tags/Jupyter-%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Paddle RCNN系列参数配置</title>
    <link href="https://knowledge-things.github.io/2022/11/03/paddle-rcnn-xi-lie-can-shu-pei-zhi/"/>
    <id>https://knowledge-things.github.io/2022/11/03/paddle-rcnn-xi-lie-can-shu-pei-zhi/</id>
    <published>2022-11-03T08:30:38.000Z</published>
    <updated>2022-11-03T09:33:36.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCNN系列模型参数配置教程"><a href="#RCNN系列模型参数配置教程" class="headerlink" title="RCNN系列模型参数配置教程"></a>RCNN系列模型参数配置教程</h1><ul><li>标签： 模型参数配置</li></ul><pre class="line-numbers language-none"><code class="language-none">#基础配置  # 检测模型的名称architecture: MaskRCNN# 默认使用GPU运行，设为False时使用CPU运行use_gpu: true# 最大迭代次数，而一个iter会运行batch_size * device_num张图片# 一般batch_size为1时，1x迭代18万次，2x迭代36万次max_iters: 180000# 模型保存间隔，如果训练时eval设置为True，会在保存后进行验证snapshot_iter: 10000# 输出指定区间的平均结果，默认20，即输出20次的平均结果。也是默认打印log的间隔。log_iter: 20# 训练权重的保存路径save_dir: output# 模型的预训练权重，默认是从指定url下载pretrain_weights: https:&#x2F;&#x2F;paddle-imagenet-models-name.bj.bcebos.com&#x2F;ResNet50_cos_pretrained.tar# 验证模型的评测标准，可以选择COCO或者VOCmetric: COCO# 用于模型验证或测试的训练好的权重weights: output&#x2F;mask_rcnn_r50_fpn_1x&#x2F;model_final&#x2F;# 用于训练或验证的数据集的类别数目# **其中包含背景类，即81&#x3D;80 + 1（背景类）**num_classes: 81#####################################模型配置###################################### Mask RCNN元结构，包括了以下主要组件, 具体细节可以参考[论文]( https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1703.06870)MaskRCNN:  backbone: ResNet  fpn: FPN  rpn_head: FPNRPNHead  roi_extractor: FPNRoIAlign  bbox_assigner: BBoxAssigner  bbox_head: BBoxHead  mask_assigner: MaskAssigner  mask_head: MaskHead  rpn_only: false# 主干网络ResNet:  # 配置在哪些阶段加入可变性卷积，默认不添加  dcn_v2_stages: []  # ResNet深度，默认50  depth: 50  # 主干网络返回的主要阶段特征用于FPN作进一步的特征融合  # 默认从[2,3,4,5]返回特征  feature_maps: [2,3,4,5]  # 是否在训练中固定某些权重，默认从第2阶段开始固定，即resnet的stage 1  freeze_at: 2  # 是否停止norm layer的梯度回传，默认是  freeze_norm: true  # norm layer的权重衰退值  norm_decay: 0.0  # norm layer的类型, 可以选择bn&#x2F;sync_bn&#x2F;affine_channel, 默认为affine_channel  norm_type: affine_channel  # ResNet模型的类型, 分为&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;四种, 默认使用&#39;b&#39;类型  variant: b# FPN多特征融合FPN:  # FPN使用的最高层特征后是否添加额外conv，默认false  has_extra_convs: false  # FPN使用主干网络最高层特征，默认是resnet第5阶段后添加额外卷积操作变&lt;成了FPN的第6个，总共有5个阶段  max_level: 6  # FPN使用主干网络最低层特征，默认是resnet第2阶段的输出  min_level: 2  # FPN中使用Norm类型, bn&#x2F;sync_bn&#x2F;affine_channel&#x2F;null, 默认不用null  norm_type: null  # FPN输出特征的通道数量, 默认是256  num_chan: 256  # 特征图缩放比例, 默认是[0.03125, 0.0625, 0.125, 0.25]  spatial_scale: [0.03125, 0.0625, 0.125, 0.25]# 检测第一阶段RPNFPNRPNHead:  # FPN第一层特征生成anchor时，默认anchor尺寸32  anchor_start_size: 32  # RPNHead默认进行前背景二分类  num_classes: 1  # 根据特征图尺寸，在特征图的每个位置生成N个大小、长宽比各不同anchor  # N &#x3D; anchor_sizes * aspect_ratios  # 具体实现参考[API](fluid.layers.anchor_generator)  anchor_generator:    aspect_ratios: [0.5, 1.0, 2.0]    variance: [1.0, 1.0, 1.0, 1.0]  # 首先计算Anchor和GT BBox之间的IoU，为每个Anchor匹配上GT，  # 然后根据阈值过滤掉IoU低的Anchor，得到最终的Anchor及其GT进行loss计算  # 具体实现参考[API](fluid.layers.rpn_target_assign)  rpn_target_assign:    rpn_batch_size_per_im: 256    rpn_fg_fraction: 0.5    rpn_negative_overlap: 0.3    rpn_positive_overlap: 0.7    rpn_straddle_thresh: 0.0  # 首先取topk个分类分数高的anchor  # 然后通过NMS对这topk个anchor进行重叠度检测，对重叠高的两个anchor只保留得分高的  # 训练和测试阶段主要区别在最后NMS保留的Anchor数目  # 训练时输出2000个proposals，推理时输出1000个proposals  # 具体实现参考[API](fluid.layers.generate_proposals)  train_proposal:    min_size: 0.0    nms_thresh: 0.7    post_nms_top_n: 2000    pre_nms_top_n: 2000  test_proposal:    min_size: 0.0    nms_thresh: 0.7    post_nms_top_n: 1000    pre_nms_top_n: 1000# 对FPN每层执行RoIAlign后，然后合并输出结果，用于BBox Head计算FPNRoIAlign:  # 用于抽取特征特征的FPN的层数，默认为4  canconical_level: 4  # 用于抽取特征特征的FPN的特征图尺寸，默认为224  canonical_size: 224  # 用于抽取特征特征的最高层FPN，默认是2  max_level: 5  # 用于抽取特征特征的最底层FPN，默认是2  min_level: 2  #roi extractor的采样率，默认为2  sampling_ratio: 2  # 输出bbox的特征图尺寸，默认为7  box_resolution: 7  # 输出mask的特征图尺寸，默认为14  mask_resolution: 14# 输出实例掩码的HeadMaskHead:  # 卷积的数量，FPN是4，其他为0，默认为0  num_convs: 4  # mask head输出的特征图尺寸，默认14  resolution: 28  # 空洞率，默认为1  dilation: 1  # 第一个卷积后输出的特征图通道数, 默认为256  num_chan_reduced: 256  # 输出的mask的类别，默认为81  num_classes: 81# 求rpn生成的roi跟gt bbox之间的iou，然后根据阈值进行过滤，保留一定数量的roi# 再根据gt bbox的标签，对roi进行标签赋值，即得到每个roi的类别# 具体实现参考[API](fluid.layers.generate_proposal_labels)BBoxAssigner:  batch_size_per_im: 512  bbox_reg_weights: [0.1, 0.1, 0.2, 0.2]  bg_thresh_lo: 0.0  bg_thresh_hi: 0.5  fg_fraction: 0.25  fg_thresh: 0.5# 根据roi的label，选择前景，为其赋值mask label# 具体实现参考[API](fluid.layers.generate_mask_labels)MaskAssigner:  resolution: 28  num_classes: 81# 输出检测框的HeadBBoxHead:  # 在roi extractor和bbox head之间，插入两层FC，对特征做进一步学习  head: TwoFCHead  # 通过NMS进行bbox过滤  # 具体实现参考[API](fluid.layers.multiclass_nms)  nms:    keep_top_k: 100    nms_threshold: 0.5    score_threshold: 0.05# 输出检测框之前，对特征进一步学习TwoFCHead:  # FC输出的特征图通道数，默认是1024  num_chan: 1024#####################################训练配置###################################### 学习率配置LearningRate:  # 初始学习率, 一般情况下8卡gpu，batch size为2时设置为0.02  # 可以根据具体情况，按比例调整  # 比如说4卡V100，bs&#x3D;2时，设置为0.01  base_lr: 0.01  # 学习率规划器  # 具体实现参考[API](fluid.layers.piecewise_decay)  schedulers:    # 学习率衰减策略    # 对于coco数据集，1个epoch大概需要7000个iter    # if step &lt; 120000:    #    learning_rate &#x3D; 0.1    # elif 120000 &lt;&#x3D; step &lt; 160000:    #    learning_rate &#x3D; 0.1 * 0.1    # else:    #    learning_rate &#x3D; 0.1 * (0.1)**2    - !PiecewiseDecay      gamma: 0.1      milestones: [120000, 160000]    # 在训练开始时，调低学习率为base_lr * start_factor，然后逐步增长到base_lr，这个过程叫学习率热身，按照以下公式更新学习率    # linear_step &#x3D; end_lr - start_lr    # lr &#x3D; start_lr + linear_step * (global_step &#x2F; warmup_steps)    # 具体实现参考[API](fluid.layers.linear_lr_warmup)    - !LinearWarmup      start_factor: 0.3333333333333333      steps: 500OptimizerBuilder:  # 默认使用SGD+Momentum进行训练  # 具体实现参考[API](fluid.optimizer)  optimizer:    momentum: 0.9    type: Momentum  # 默认使用L2权重衰减正则化  # 具体实现参考[API](fluid.regularizer)  regularizer:    factor: 0.0001    type: L2#####################################数据配置###################################### 模型训练集设置参考# 训练、验证、测试使用的数据配置主要区别在数据路径、模型输入、数据增强参数设置TrainReader:  # 训练过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，标记的目标框、实例标签、实例分割掩码  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;gt_bbox&#39;, &#39;gt_class&#39;, &#39;is_crowd&#39;, &#39;gt_mask&#39;]  # VOC数据集对应的输入，注意选择VOC时，也要对应修改metric: VOC- # fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;gt_bbox&#39;, &#39;gt_class&#39;, &#39;is_difficult&#39;]  # 数据集目录配置  dataset:    # 指定数据集名称，可以选择VOCDataSet, COCODataSet    !COCODataSet    # 训练图片所在目录    image_dir: train2017    # 标记文件所在目录    anno_path: annotations&#x2F;instances_train2017.json    # 数据集根目录    dataset_dir: dataset&#x2F;coco  # 对一个batch中的单张图片做的数据增强  sample_transforms:  # 读取Image图像为numpy数组  # 可以选择将图片从BGR转到RGB，可以选择对一个batch中的图片做mixup增强  - !DecodeImage    to_rgb: true  # 对图片进行随机翻转  # 可以选择同步翻转mask，可以选择归一化bbox的坐标  - !RandomFlipImage    prob: 0.5  # 归一化图片，默认均值[0.485, 0.456, 0.406]，方差[1, 1, 1]  # 可以选择将归一化结果除以255，可以选择图片的数据格式  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  # 调整图片尺寸，默认采用cv2的线性插值  - !ResizeImage    target_size: 800    max_size: 1333    interp: 1    use_cv2: true  # 调整图片数据格式，默认使用CHW  - !Permute    to_bgr: false    channel_first: true  # 对一个batch中的图片统一做的数据增强  batch_transforms:  # 将一个batch中的图片，按照最大的尺寸，做补齐  - !PadBatch    pad_to_stride: 32    # 选择是否使用padding之后的image信息，默认为false    use_padded_im_info: false  # 1个GPU的batch size，默认为1  batch_size: 1  # 选择是否打乱所有样本的顺序  shuffle: true  # 使用多进程&#x2F;线程的数目，默认为2  worker_num: 2  # 选择是否使用多进程，默认为false  use_process: false  # 如果最后一个batch的图片数量为奇数，选择是否丢掉这个batch，不进行训练，默认是不丢掉的  drop_last: false  # 使用数据集中的样本数目，默认是-1，表示使用全部  samples: -1  # 模型验证集设置参考  EvalReader:  # 验证过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，图片shape  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;im_shape&#39;]  dataset:    !COCODataSet    image_dir: val2017    anno_path: annotations&#x2F;instances_val2017.json    dataset_dir: dataset&#x2F;coco  sample_transforms:  - !DecodeImage    to_rgb: true  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  - !ResizeImage    interp: 1    max_size: 1333    target_size: 800    use_cv2: true  - !Permute    channel_first: true    to_bgr: false    batch_size: 1    shuffle: false    drop_last: false    drop_empty: false    worker_num: 2# 测试验证集设置参考TestReader:  # 测试过程中模型的相关输入  # 包括图片，图片长宽高等基本信息，图片id，图片shape  inputs_def:    fields: [&#39;image&#39;, &#39;im_info&#39;, &#39;im_id&#39;, &#39;im_shape&#39;]  dataset:    # 测试图片所在目录    !ImageFolder    anno_path: annotations&#x2F;instances_val2017.json  sample_transforms:  - !DecodeImage    to_rgb: true    with_mixup: false  - !NormalizeImage    is_channel_first: false    is_scale: true    mean: [0.485,0.456,0.406]    std: [0.229, 0.224,0.225]  - !ResizeImage    interp: 1    max_size: 1333    target_size: 800    use_cv2: true  - !Permute    channel_first: true    to_bgr: false  batch_size: 1  shuffle: false  drop_last: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCNN系列模型参数配置教程&quot;&gt;&lt;a href=&quot;#RCNN系列模型参数配置教程&quot; class=&quot;headerlink&quot; title=&quot;RCNN系列模型参数配置教程&quot;&gt;&lt;/a&gt;RCNN系列模型参数配置教程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;标签： 模型参数配置&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Paddle" scheme="https://knowledge-things.github.io/categories/Paddle/"/>
    
    
    <category term="RCNN  参数配置" scheme="https://knowledge-things.github.io/tags/RCNN-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://knowledge-things.github.io/2022/11/03/linux-chang-yong-ming-ling/"/>
    <id>https://knowledge-things.github.io/2022/11/03/linux-chang-yong-ming-ling/</id>
    <published>2022-11-03T08:22:29.000Z</published>
    <updated>2023-05-15T05:32:31.774Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看分辨率等信息$ identify xxx.jpg# 关闭模型评估内存异常未正确推出的进程$ ps aux | grep &#39;tools&#x2F;train.py&#39;  | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9$ ps aux | grep &#39;tools&#x2F;eval.py&#39;  | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9# 按照文件大小排序显示，按字节排序，按兆（M）加参数 ‘h’$ du -sh .&#x2F;* | sort -rn   从大到小$ du -sh .&#x2F;* | sort -n    从小到大# 选择部分列出$ du -s &#x2F;usr&#x2F;* | sort -rn | head     前面的10个$ du -s &#x2F;usr&#x2F;* | sort -rn | tail     后面的10个# 查找文件内容$ find .&#x2F; -type f -name &quot;*.xml&quot; | xargs grep &quot;0000280.png&quot;# 远程Copy文件到本地$ scp rtzh@10.11.109.247:&#x2F;data&#x2F;aiimages&#x2F;dataset&#x2F;anjian&#x2F;gkpw.zip .&#x2F;#统计文件数量$ ls -l | grep &quot;^-&quot; | wc -l# 列出 tar.xz 文件内容tar -tf archive.tar.xz#压缩tar –zcvf jpg.tar.gz a&#x2F;# 将文件或者文件件打包为zip压缩包，book.zip大小为38.8Mzip -r book.zip .&#x2F;input.pdf# 将book.zip分割，每个压缩包不超过20M，生成两个压缩包subbook.zip（17.8M）和subbook.z01（21M）zip -s 20m book.zip --out subbook.zip#解压到指定目录tar -zxvf &#x2F;bbs.tar.zip -C &#x2F;zzz&#x2F;bbs    # 解压多个unzip \*.zip #实时显示GPU资源使用情况watch -n 2 -d nvidia-smi #启动 visualdl$ visualdl --logdir .&#x2F;vdl_dir&#x2F;scalar --host 0.0.0.0 --port 8088# 查看Docker环境变量信息$ systemctl show docker --property Environment# Docker proxy config$ &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d$ nano proxy.conf[Service]Environment&#x3D;&quot;HTTP_PROXY&#x3D;http:&#x2F;&#x2F;127.0.0.1:2340&#x2F;&quot;Environment&#x3D;&quot;HTTPS_PROXY&#x3D;http:&#x2F;&#x2F;127.0.0.1:2340&#x2F;&quot;Environment&#x3D;&quot;NO_PROXY&#x3D;localhost,127.0.0.1,.example.com&quot;$ systemctl daemon-reload$ systemctl restart docker$ systemctl status docker#清除历史编译文件夹$ find . -name pom.xml -exec mvn clean -f &#39;&#123;&#125;&#39; \;$ find . -name &#39;target&#39; -a -type d -exec rm -rfv &#39;&#123;&#125;&#39; \;# docker端口转发docker inspect xxxxsudo iptables --listsudo iptables -t nat -A DOCKER -p tcp --dport 5432 -j DNAT --to 172.18.0.13:5432# linux 挂载共享mount -t cifs -o username&#x3D;ligger &#x2F;&#x2F;192.168.1.121&#x2F;dataset &#x2F;mnt&#x2F;win_sharesudo mount -t cifs -o username&#x3D;rtzh &#x2F;&#x2F;10.11.109.247&#x2F;aiimages &#x2F;mnt&#x2F;local_share&#x2F;nohup jupyter-lab --ip&#x3D;0.0.0.0 --port&#x3D;8088 --allow-root --notebook-dir&#x3D;&#x2F;home&#x2F;kevin&#x2F;workspace &gt; &#x2F;dev&#x2F;null &amp;#设置终端代理export https_proxy&#x3D;http:&#x2F;&#x2F;10.9.98.199:2340 http_proxy&#x3D;http:&#x2F;&#x2F;10.9.98.199:2340 all_proxy&#x3D;socks5:&#x2F;&#x2F;10.9.98.199:2340#取消代理unset http_proxy &amp; unset https_proxy &amp; unset all_proxy#查看kafka分区数量.&#x2F;kafka-topics.sh --describe --zookeeper zookeeper:2181 --topic captureTask#修改分区数量.&#x2F;kafka-topics.sh --alter --zookeeper zookeeper:2181 --topic captureTask --partitions 7#如果你使用的是新版本的Kafka，它可能使用了Kafka自己的协调器而不是Zookeeper。在这种情况下，你需要使用--bootstrap-server参数而不是--zookeeper参数。例如：.&#x2F;kafka-topics.sh --alter --bootstrap-server kafka:9092 --topic captureTask --partitions 7#查看分组数量.&#x2F;kafka-consumer-groups.sh --bootstrap-server &lt;kafka-broker-host&gt;:&lt;kafka-broker-port&gt; --describe --group &lt;consumer-group-id&gt;.&#x2F;kafka-consumer-groups.sh --bootstrap-server kafka:9092 --describe --group  consumer-group2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-bash&quot; data-language=&quot;bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;# 查看分辨率等信息
$ identify xxx.jpg

# 关闭模型评估内存异常未正确推出的进程</summary>
      
    
    
    
    <category term="Linux" scheme="https://knowledge-things.github.io/categories/Linux/"/>
    
    
    <category term="常用命令" scheme="https://knowledge-things.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>mAP计算</title>
    <link href="https://knowledge-things.github.io/2022/11/03/map-ji-suan/"/>
    <id>https://knowledge-things.github.io/2022/11/03/map-ji-suan/</id>
    <published>2022-11-03T08:03:32.000Z</published>
    <updated>2022-11-03T08:15:50.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。<br>原文链接[<a href="https://aistudio.baidu.com/aistudio/projectdetail/2213799">https://aistudio.baidu.com/aistudio/projectdetail/2213799</a>] </p></blockquote><p>在机器学习领域中，用于评价一个模型的性能有多种指标，其中几项就是FP、FN、TP、TN、精确率(Precision)、召回率(Recall)、准确率(Accuracy)。</p><p>mean Average Precision, 即各类别AP的平均值，是AP：PR 曲线下面积。</p><p>此前先了解一下IOU评判标准：</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/156a2736163b482d9405bbf1a7fc76c8d818d372669642c88f26d7f8f9ad6a1f" alt="img"></p><p>TP、FP、FN、TN</p><p>常见的评判方式，第一位的T,F代表正确或者错误。第二位的P和N代表判断的正确或者错误</p><ul><li>True Positive (TP): IoU&gt;IOUthreshold IoU&gt;<em>I<strong>O</strong>U</em>threshold  (IOU的阈值一般取0.5)的所有检测框数量（同一Ground Truth只计算一次），可以理解为真实框，或者标准答案</li><li>False Positive (FP): IoU&lt;IOUthreshold IoU&lt;<em>I<strong>O</strong>U</em>threshold  的所有检测框数量</li><li>False Negative (FN): 没有检测到的 GT 的数量</li><li>True Negative (TN): mAP中无用到</li></ul><p><img src="https://ai-studio-static-online.cdn.bcebos.com/c9ddb96d1bc94786903d6e3186a951fe7042c831c2ad4d329aaf95298c2eda79" alt="img"></p><p>查准率（Precision）: Precision =TPTP+FP=TP all detections =<em>T**P</em>+<em>F<strong>P</strong>T**P</em>= all detections <em>T**P</em></p><p>查全率（Recall）: Recall =TPTP+FN=TP all ground truths =<em>T**P</em>+<em>F<strong>N</strong>T**P</em>= all ground truths <em>T**P</em></p><p>二者绘制的曲线称为 P-R 曲线： 查准率：P 为纵轴y 查全率：R 为横轴x轴，如下图</p><p><img src="https://ai-studio-static-online.cdn.bcebos.com/2505d5e4ce9040879553d2a3252785e9d5cf697d278543999e77ef0b51d2847a" alt="img"></p><p>mAP值即为，PR曲线下的面积。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载内容 如有侵权 或 不希望被转载 可以留言或私发告诉我，我会及时处理，尊重你的权利。&lt;br&gt;原文链接[&lt;a href=&quot;https://aistudio.baidu.com/aistudio/projectdetail/2213799&quot;&gt;htt</summary>
      
    
    
    
    <category term="Deep Learning" scheme="https://knowledge-things.github.io/categories/Deep-Learning/"/>
    
    
    <category term="mAP" scheme="https://knowledge-things.github.io/tags/mAP/"/>
    
  </entry>
  
</feed>
