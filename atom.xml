<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kevin Blog</title>
  
  <subtitle>always-be-coding</subtitle>
  <link href="https://knowledge-things.github.io/atom.xml" rel="self"/>
  
  <link href="https://knowledge-things.github.io/"/>
  <updated>2022-11-01T01:51:53.657Z</updated>
  <id>https://knowledge-things.github.io/</id>
  
  <author>
    <name>Kevin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSH tunnel</title>
    <link href="https://knowledge-things.github.io/2022/11/01/ssh-tunnel/"/>
    <id>https://knowledge-things.github.io/2022/11/01/ssh-tunnel/</id>
    <published>2022-11-01T01:38:33.000Z</published>
    <updated>2022-11-01T01:51:53.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接 <a href="https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/">https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/</a></p><p><a href="https://blog.csdn.net/scwMason/article/details/111152300">https://blog.csdn.net/scwMason/article/details/111152300</a></p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ol><li>公网服务器B</li><li>需要访问的目标内网服务器A</li></ol><h5 id="公网服务器配置"><a href="#公网服务器配置" class="headerlink" title="公网服务器配置"></a>公网服务器配置</h5><p>修改公网主机 B 的 SSH 配置文件/etc/ssh/sshd_config</p><p>GatewayPorts yes<br>1<br>这样可以把监听的端口绑定到任意 IP 0.0.0.0 上，否则只有本机 127.0.0.1 可以访问。</p><h5 id="重启-sshd-服务"><a href="#重启-sshd-服务" class="headerlink" title="重启 sshd 服务"></a>重启 sshd 服务</h5><p><code>sudo service sshd restart</code><br>内网服务器配置</p><p>在内网主机 A 上，执行以下命令安装 AutoSSH</p><p>How to install AutoSSH on various systems via their package manager.</p><div class="table-container"><table><thead><tr><th>OS</th><th>Install method</th></tr></thead><tbody><tr><td>Debian / Ubuntu</td><td><code>$ sudo apt-get install autossh</code></td></tr><tr><td>CentOS / Fedora / RHEL</td><td><code>$ sudo yum install autossh</code></td></tr><tr><td>ArchLinux</td><td><code>$ sudo pacman -S autossh</code></td></tr><tr><td>FreeBSD</td><td><code># pkg install autossh</code> or <code># cd /usr/ports/security/autossh/ &amp;&amp; make install clean</code></td></tr><tr><td>OSX</td><td><code>$ brew install autossh</code></td></tr></tbody></table></div><p>Alternatively you can also compile and install AutoSSH from source:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wget http:&#x2F;&#x2F;www.harding.motd.ca&#x2F;autossh&#x2F;autossh-1.4e.tgzgunzip -c autossh-1.4e.tgz | tar xvf -cd autossh-1.4e.&#x2F;configuremakesudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="断线免密登录自动重连"><a href="#断线免密登录自动重连" class="headerlink" title="断线免密登录自动重连"></a>断线免密登录自动重连</h5><p>ssh 反向链接会因为超时而关闭，如果关闭了那从外网连通内网的通道就无法维持，为此我们需要结合免密码登录及 AutoSSH 来提供稳定的 ssh 反向代理隧道。</p><p>1、在内网主机 A 上产生公钥和私钥</p><p><code>ssh-keygen</code><br>然后按三次回车执行默认选项生成公钥和私钥。会生成密钥文件和私钥文件 id_rsa,id_rsa.pub 或 id_dsa,id_dsa.pub</p><p>2、拷贝秘钥 在内网主机 A 上继续执行如下命令，将内网主机 A 上的秘钥文件 copy 到公网主机 B 中。</p><p><code>ssh-copy-id  username@ip</code><br>其中“username”是公网主机 B 的用户名，ip 为公网主机 B 的 ip，然后按照提示输入公网主机 B 的密码就完成了。</p><p>启动autossh</p><p><strong>注意</strong></p><p><strong>前提是公网服务器的22001端口（也可自定义）已经开放，没有的话先去设置安全组</strong></p><pre class="line-numbers language-none"><code class="language-none">autossh -M 4010 -NR 10022:localhost:22  root@XXX.XXX.XXX.XXX<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数解释：</strong></p><ul><li>“-M 4010”意思是使用内网主机 A 的 4010 端口监视 SSH 连接状态，连接出问题了会自动重连</li><li>“ -N”意思是不执行远程命令</li><li>“-R”意思是将远程主机（公网主机 B）的某个端口转发到本地指定机器的指定端口</li></ul><p>代码解释：</p><p>“22001:localhost:4000”意思是将内网主机 A 的 4000 号端口转发至公网主机 B 的 22001 号端口上<br>“username@xxx.xxx.xxx.xxx”意思是公网主机 B 的用户名和 IP<br>“-p xxxx”意思是公网主机 B 的 SSH 端口，如果是默认的 22 号端口，则可以不输入.<br>查看端口情况</p><p><code>lsof -i:4010</code></p><h2 id="AutoSSH-during-boot-with-systemd"><a href="#AutoSSH-during-boot-with-systemd" class="headerlink" title="AutoSSH during boot with systemd"></a>AutoSSH during boot with systemd</h2><p>If you want a permanent SSH tunnel already created during boot time, you will (nowadays) have to create a systemd service and enable it. There is however an important thing to note about systemd and AutoSSH: <code>-f</code> (background usage) already implies <code>AUTOSSH_GATETIME=0</code>, however <code>-f</code> is not supported by systemd.</p><blockquote><p><a href="http://www.freedesktop.org/software/systemd/man/systemd.service.html">http://www.freedesktop.org/software/systemd/man/systemd.service.html</a><br>[…] running programs in the background using “&amp;”, and other elements of shell syntax are not supported.</p></blockquote><p>So in the case of <code>systemd</code> we need to make use of <code>AUTOSSH_GATETIME</code>. Let’s look at a very basic service:</p><pre class="line-numbers language-none"><code class="language-none">$ vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh-ssh-tunnel.service$ sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;autossh-ssh-tunnel.service[Unit]Description&#x3D;AutoSSH service for remote tunnelAfter&#x3D;network.target[Service]Environment&#x3D;&quot;AUTOSSH_GATETIME&#x3D;0&quot;User&#x3D;rootExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;autossh -M 4010 -NR 10022:localhost:22  root@39.106.68.226[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tell systemd that we have added some stuff:</p><pre class="line-numbers language-none"><code class="language-none">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Start the service</p><pre class="line-numbers language-none"><code class="language-none">systemctl start autossh-ssh-tunnel.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Enable during boot time</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable autossh-ssh-tunnel.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考链接 &lt;a href=&quot;https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/&quot;&gt;https://www.everythingcli.org/ssh-tu</summary>
      
    
    
    
    <category term="SSH tunnel" scheme="https://knowledge-things.github.io/categories/SSH-tunnel/"/>
    
    
    <category term="autossh" scheme="https://knowledge-things.github.io/tags/autossh/"/>
    
  </entry>
  
  <entry>
    <title>VPN 心跳保护</title>
    <link href="https://knowledge-things.github.io/2022/10/25/vpn-xin-tiao-bao-hu/"/>
    <id>https://knowledge-things.github.io/2022/10/25/vpn-xin-tiao-bao-hu/</id>
    <published>2022-10-25T03:43:22.000Z</published>
    <updated>2022-10-25T03:44:02.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VPN-心跳保护"><a href="#VPN-心跳保护" class="headerlink" title="VPN 心跳保护"></a>VPN 心跳保护</h2><ul><li><p>添加ppp0网络检测<br><code>nano health_vpn.sh</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bash# &quot;100%&quot;在ping的输出结果中(证明未ping该网段)if ping -w 1 -c 3 192.168.42.1 | grep &quot;100%&quot; &gt;&#x2F;dev&#x2F;null  #未ping通则重启网卡,并重新添加路由表then        echo &quot;192.168.42.1 is Not reachable&quot;        echo &quot;restart docker vpn-client ...&quot;        docker restart vpn-client        echo &quot;ending start vpn...&quot;#ping通则不作处理else        echo &quot;192.168.42.1 is reachable&quot;fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#添加执行权限chmod +x health_vpn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>crontab -e 选择要使用的vi工具</p></li><li><p>添加定时计划</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">* * * * * sleep 10; &#x2F;home&#x2F;rtzh&#x2F;health_vpn.sh  &gt;&gt;&#x2F;tmp&#x2F;health-vpn.txt#验证成功后可关闭日志，避免日志文件过大* * * * * sleep 10; &#x2F;home&#x2F;rtzh&#x2F;health_vpn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>重启cron服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service cron restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看是否启动成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status croncrontab -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="打开cron日志"><a href="#打开cron日志" class="headerlink" title="打开cron日志"></a>打开cron日志</h2><p>Ubuntu系统默认是不打开cron日志的</p><p>如何打开，很简单，控制台输入</p><p><code>vi /etc/rsyslog.d/50-default.conf</code></p><p>打开文件，在文件中找到cron.*，把前面的#去掉，保存退出，输入</p><p><code>sudo service rsyslog restart</code></p><p>重启系统日志，然后稍微等下应该就能在/var/log目录下看到cron.log，vi cron.log就可以查看cron运行日志了。</p><pre class="line-numbers language-none"><code class="language-none">tail -f &#x2F;var&#x2F;log&#x2F;cron.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VPN-心跳保护&quot;&gt;&lt;a href=&quot;#VPN-心跳保护&quot; class=&quot;headerlink&quot; title=&quot;VPN 心跳保护&quot;&gt;&lt;/a&gt;VPN 心跳保护&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加ppp0网络检测&lt;br&gt;&lt;code&gt;nano health_vpn.s</summary>
      
    
    
    
    <category term="Linux" scheme="https://knowledge-things.github.io/categories/Linux/"/>
    
    <category term="VPN" scheme="https://knowledge-things.github.io/categories/Linux/VPN/"/>
    
    
    <category term="vpn client" scheme="https://knowledge-things.github.io/tags/vpn-client/"/>
    
  </entry>
  
  <entry>
    <title>阅读记录（2022年10月）</title>
    <link href="https://knowledge-things.github.io/2022/10/20/yue-du-ji-lu/"/>
    <id>https://knowledge-things.github.io/2022/10/20/yue-du-ji-lu/</id>
    <published>2022-10-20T08:21:11.000Z</published>
    <updated>2022-10-27T09:41:50.332Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2022-10-20"><a href="#2022-10-20" class="headerlink" title="2022-10-20"></a>2022-10-20</h2><ul><li><strong>mmdection环境搭建</strong><br><a href="https://pytorch.org/get-started/previous-versions/">PyThorch历史版本安装</a><br><a href="https://blog.csdn.net/Singlepledge/article/details/107138749">Ubuntu 20.04 : 几个BT下载软件和命令</a><br><a href="https://blog.csdn.net/weixin_45385568/article/details/115084264">ubuntu20.04显卡驱动 cuda cudnn安装</a><br><a href="https://developer.nvidia.com/cuda-toolkit-archive">CUDA历史版本官方下载地址</a><br><a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">显卡驱动与CUDA版本对应关系</a><br><a href="https://blog.csdn.net/Yana_Zeng/article/details/119539835">pytorch安装</a><br><a href="https://pytorch.org/get-started/previous-versions/">pytorch历史版本</a></li></ul><h2 id="2022-10-21"><a href="#2022-10-21" class="headerlink" title="2022-10-21"></a>2022-10-21</h2><p>  <a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker">Nvidia-docker install guide</a><br>  <a href="https://support.strongvpn.com/hc/en-us/articles/360039667713-IKEv2-Setup-Ubuntu-18-and-above-on-Command-Line">Ubuntu IPSec vpn安装</a><br>  <a href="https://hub.docker.com/r/fengzhou/ipsec-vpn-client">ipsec-vpn-client docker</a></p><h2 id="2022-10-24"><a href="#2022-10-24" class="headerlink" title="2022-10-24"></a>2022-10-24</h2><p>  <a href="https://blog.csdn.net/qq_41627642/article/details/124803970">Swin-Transformer-Object-Detection V2.11.0环境搭建</a><br>  <a href="https://blog.csdn.net/CSDN_X_W/article/">Swin Transformer Object Detection 目标检测-1</a><br>  <a href="https://blog.csdn.net/weixin_44347020/article/details/116153242">基于mmdetection训练Swin Transformer Object Detection</a></p><h2 id="2022-10-27"><a href="#2022-10-27" class="headerlink" title="2022-10-27"></a>2022-10-27</h2><p>  <a href="https://www.paddlepaddle.org.cn/whl/linux/mkl/avx/stable.html">PaddlePaddle安装包</a><br>  <a href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/version/cudnn_cn.html">PaddlePaddle Api</a><br>  <a href="https://github.com/alibaba/EasyCV/blob/master/docs/source/data_hub.md">alibaba EasyCV datahub</a><br>  <a href="https://blog.csdn.net/qq_38410428/article/details/103645212">遥感数据集</a><br>  <a href="https://xie.infoq.cn/article/3c4afe81a2e2693eb23406752">alibaba EasyCV datahub</a><br>  <a href="https://github.com/mcordts/cityscapesScripts">cityscapesScripts</a><br>  <a href="https://blog.csdn.net/hanruiding/article/details/89493466">按文件大小排序</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2022-10-20&quot;&gt;&lt;a href=&quot;#2022-10-20&quot; class=&quot;headerlink&quot; title=&quot;2022-10-20&quot;&gt;&lt;/a&gt;2022-10-20&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mmdection环境搭建&lt;/strong&gt;&lt;b</summary>
      
    
    
    
    
    <category term="阅读记录" scheme="https://knowledge-things.github.io/tags/%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>microk8s曲线救国</title>
    <link href="https://knowledge-things.github.io/2022/10/14/microk8s-qu-xian-jiu-guo/"/>
    <id>https://knowledge-things.github.io/2022/10/14/microk8s-qu-xian-jiu-guo/</id>
    <published>2022-10-14T08:57:40.000Z</published>
    <updated>2022-10-14T09:01:25.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-安装前的准备"><a href="#一-安装前的准备" class="headerlink" title="一. 安装前的准备"></a>一. 安装前的准备</h2><ol><li>安装 pullk8s 工具，此工具可以通过 hub.docker.com 的 opsdockerimage 仓库下载k8s所需的 k8s.gcr.io 或 gcr.io 镜像，无需自己翻墙，每天更新一次，包括所有image 的全平台的所有tags。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo curl -L &quot;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;OpsDocker&#x2F;pullk8s&#x2F;main&#x2F;pullk8s.sh&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pullk8s$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pullk8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s COMMAND [NAME[:TAG|@DIGEST]] [OPTIONS]Pull gcr.io&#39;s image for hub.docker.comCommands:  check    Check gcr.io&#39;s fail pull images.  pull     Pull an image or a repositoryOptions:  --microk8s  If use MicroK8s release.Examples:  pullk8s pull gcr.io&#x2F;google_containers&#x2F;etcd:2.0.12  pullk8s pull k8s.gcr.io&#x2F;etcd:2.0.12  pullk8s pull k8s.gcr.io&#x2F;pause:3.6 --microk8s  pullk8s check --microk8s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>安装 snap ,Ubuntu 目前已经支持。</p><p>其他系统的安装见 Installing snapd | Snapcraft documentation    <a href="https://snapcraft.io/docs/installing-snapd">https://snapcraft.io/docs/installing-snapd</a></p></li></ol><h2 id="检查被屏蔽的-gcr-io-或-k8s-gcr-io-容器名称"><a href="#检查被屏蔽的-gcr-io-或-k8s-gcr-io-容器名称" class="headerlink" title="检查被屏蔽的 gcr.io 或 k8s.gcr.io 容器名称"></a>检查被屏蔽的 gcr.io 或 k8s.gcr.io 容器名称</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s check --microk8sk8s.gcr.io&#x2F;pause:3.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>此时提示的 k8s.gcr.io/pause:3.1 就是pull 失败的容器名称</p><ul><li>因 microk8s 启动需要时间，可能要执行多次才能看到失败的容器名称，</li><li>使用 pullk8s 拉取失败的镜像，并导入到 pod 空间中</li></ul></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pullk8s pull k8s.gcr.io&#x2F;pause:3.1 --microk8s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-安装前的准备&quot;&gt;&lt;a href=&quot;#一-安装前的准备&quot; class=&quot;headerlink&quot; title=&quot;一. 安装前的准备&quot;&gt;&lt;/a&gt;一. 安装前的准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;安装 pullk8s 工具，此工具可以通过 hub.docker.com 的</summary>
      
    
    
    
    <category term="microk8s" scheme="https://knowledge-things.github.io/categories/microk8s/"/>
    
    
    <category term="pullk8s" scheme="https://knowledge-things.github.io/tags/pullk8s/"/>
    
  </entry>
  
  <entry>
    <title>install onepanel</title>
    <link href="https://knowledge-things.github.io/2022/10/14/install-onepanel/"/>
    <id>https://knowledge-things.github.io/2022/10/14/install-onepanel/</id>
    <published>2022-10-14T03:16:59.000Z</published>
    <updated>2022-10-14T08:41:21.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Install-onepanel"><a href="#Install-onepanel" class="headerlink" title="Install onepanel"></a>Install onepanel</h2><h2 id="Install-onepanel-1"><a href="#Install-onepanel-1" class="headerlink" title="Install onepanel"></a>Install onepanel</h2><blockquote><p>官方参考文档    </p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/files/">https://docs.onepanel.ai/docs/deployment/configuration/files/</a></p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/#configure-local-dns">https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/#configure-local-dns</a></p><p><a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/">https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s/</a></p><p>Git Blog</p></blockquote><p><strong>1    Install microk8s using the command line</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo snap install microk8s --channel&#x3D;1.21&#x2F;stable --classicsudo snap alias microk8s.kubectl kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>2 Make sure your current user has permissions to work with <code>microk8s</code>.</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo usermod -a -G microk8s $USERsudo chown -f -R $USER ~.&#x2F;kube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Configuring the proxy environment variables</strong></p><p><em>启用proxy后需要在安装k8s基础容器后关闭代理</em></p><p>修改配置文件<code>/etc/environment</code> </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo nano &#x2F;etc&#x2F;environmentHTTPS_PROXY&#x3D;http:&#x2F;&#x2F;squid.internal:3128HTTP_PROXY&#x3D;http:&#x2F;&#x2F;squid.internal:3128NO_PROXY&#x3D;10.0.0.0&#x2F;8,192.168.0.0&#x2F;16,127.0.0.1,172.16.0.0&#x2F;16https_proxy&#x3D;http:&#x2F;&#x2F;squid.internal:3128http_proxy&#x3D;http:&#x2F;&#x2F;squid.internal:3128no_proxy&#x3D;10.0.0.0&#x2F;8,192.168.0.0&#x2F;16,127.0.0.1,172.16.0.0&#x2F;16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>we need to configure <code>NO_PROXY</code> and <code>no_proxy</code> with the IP ranges the pods and services occupy</p><p>For the changes to take effect we need to restart MicroK8s:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stopmicrok8s start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Wait for it to be ready.</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>3 Enable the following required add-ons:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo microk8s enable storage dns rbac<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>4 Update API server config<code>(optional)</code></strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;args&#x2F;kube-apiserver<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add to the top</p><pre class="line-numbers language-none"><code class="language-none">--service-account-signing-key-file&#x3D;$&#123;SNAP_DATA&#125;&#x2F;certs&#x2F;serviceaccount.key--service-account-key-file&#x3D;$&#123;SNAP_DATA&#125;&#x2F;certs&#x2F;serviceaccount.key--service-account-issuer&#x3D;api--service-account-api-audiences&#x3D;api,nats<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Restart microk8s for the changes to take effect</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>5 Enable microk8s addons</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo microk8s enable storage dns rbacmicrok8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Check <code>node</code> and <code>pod</code> status</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">-------------node status----------root@rtzh-virtual-k8s:~# sudo microk8s.kubectl get nodeNAME               STATUS   ROLES    AGE   VERSIONrtzh-virtual-k8s   Ready    &lt;none&gt;   18m   v1.21.13-3+cbc10c94808907------------pod status-------------root@rtzh-virtual-k8s:~# sudo microk8s.kubectl get pod --all-namespaces NAMESPACE     NAME                                      READY   STATUS    RESTARTS   AGEkube-system   calico-kube-controllers-f7868dd95-hfmz5   1&#x2F;1     Running   0          19mkube-system   calico-node-k8kk6                         1&#x2F;1     Running   0          19mkube-system   hostpath-provisioner-566686b959-lk6hg     1&#x2F;1     Running   0          2m55skube-system   coredns-7f9c69c78c-2fsrt                  1&#x2F;1     Running   0          2m53s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Configure DNS</strong></p><p>i. Edit the resolvconf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;var&#x2F;snap&#x2F;microk8s&#x2F;current&#x2F;args&#x2F;kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add to the top</p><pre class=" language-lang---resolv-conf=/run/systemd/resolve/resolv.conf```"><code class="language-lang---resolv-conf=/run/systemd/resolve/resolv.conf```">ii. Edit coredns configmap so we point to the resolv.conf file<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s kubectl edit cm coredns -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>Set the forward section to:```forward . /etc/resolv.conf 8.8.8.8  8.8.4.4</code></pre><p>iii. Restart microk8s</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Install-Onepanel"><a href="#Install-Onepanel" class="headerlink" title="Install Onepanel#"></a>Install Onepanel<a href="https://docs.onepanel.ai/docs/deployment/configuration/remote-microk8s#install-onepanel">#</a></h2><ol><li><p>Install</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># startvpncurl -sLO https:&#x2F;&#x2F;github.com&#x2F;onepanelio&#x2F;onepanel&#x2F;releases&#x2F;latest&#x2F;download&#x2F;opctl-linux-amd64chmod +x opctl-linux-amd64sudo mv .&#x2F;opctl-linux-amd64 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;opctl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Initialize Onepanel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">opctl init --provider microk8s \--enable-metallb \--artifact-repository-provider s3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><code>params.yaml</code>按照模板中的说明进行填充，并参阅<a href="https://docs.onepanel.ai/docs/deployment/configuration/files#sections">配置文件部分</a>以获取更多详细信息。</p><pre class="line-numbers language-none"><code class="language-none"># - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Generated with Onepanel CLI # CLI version: v1.0.2# Command: opctl init --provider microk8s --enable-metallb --artifact-repository-provider s3# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Onepanel# Description: Onepanel application information# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -application:  defaultNamespace: example  domain: onepanel.test  fqdn: app.onepanel.test  insecure: true  nodePool:    label: node.kubernetes.io&#x2F;instance-type    options:      - name: &#39;Local machine&#39;        value: &#39;local&#39;  provider: microk8s# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Artifact repository# Description: S3 compatible object storage for storing files across Onepanel# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -artifactRepository:  s3:    # S3 access key    accessKey: &#39;minio&#39;    # Name of bucket, example: my-bucket    bucket: &#39;mybucket&#39; # Your bucket here    endpoint: &#39;minio.example.svc.cluster.local&#39; # replace &#96;example&#96; with your namespace    # Change to true if endpoint does NOT support HTTPS    insecure: true    # Key Format for objects stored by Workflows. This can reference Workflow variables    keyFormat: artifacts&#x2F;&#123;&#123;workflow.namespace&#125;&#125;&#x2F;&#123;&#123;workflow.name&#125;&#125;&#x2F;&#123;&#123;pod.name&#125;&#125;    publicEndpoint: 10.1.131.146:9000 # The IP address from minio    # Bucket region, this can be anything since it is running locally    region: us-west-2    # S3 secret key    secretKey: &#39;minio123&#39;# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: cert-manager# Description: automatically creates and renews TLS certificates using Let&#39;s Encrypt# Docs: https:&#x2F;&#x2F;onepanelio.github.io&#x2F;core-docs&#x2F;docs&#x2F;deployment&#x2F;configuration&#x2F;tls# CLI flag: --enable-cert-manager# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -certManager:  email: test@test.com # Not used in local deployments as certs are generated locally# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -# Component: Application and kubernetes load balancing on non-cloud deployments.# Description: MetalLB, LoadBalancer# CLI flag: --enable-metallb# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -metalLb:  addresses:    - 192.168.99.0&#x2F;32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Deploy onepanel</p><blockquote><p><code>issue</code> kfserving controller image pull unauthorized</p></blockquote><p>Modifying the kfserving version before deploying onepanel</p><p>If you have already executed <code>kubeconfig opctl apply</code>, delete  cache file </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf .onepanel&#x2F;kubernetes.yamlrm -rf .onepanel&#x2F;manifests&#x2F;cache&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">nano .onepanel&#x2F;manifests&#x2F;v1.0.2&#x2F;kfserving&#x2F;base&#x2F;kfserving.yaml# change- gcr.io&#x2F;kfserving&#x2F;kfserving-controller:v0.6.0to+ kfserving&#x2F;kfserving-controller:v0.6.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s config &gt; kubeconfigKUBECONFIG&#x3D;.&#x2F;kubeconfig opctl apply<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="Expose-Onepanel-using-Nginx"><a href="#Expose-Onepanel-using-Nginx" class="headerlink" title="Expose Onepanel using Nginx"></a>Expose Onepanel using Nginx</h2><p>First, install nginx.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Then, configure nginx to expose Onepanel</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nano &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Change this</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;        # First attempt to serve request as file, then        # as directory, then fall back to displaying a 404.        try_files $uri $uri&#x2F; &#x3D;404;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>to</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">location &#x2F; &#123;  client_max_body_size 0; # No size limit to upload requests      proxy_pass http:&#x2F;&#x2F;192.168.99.0; # the ip address you gave metallb  proxy_set_header Host $host;  proxy_http_version 1.1;  proxy_set_header Upgrade $http_upgrade;  proxy_set_header Connection &quot;upgrade&quot;;  proxy_request_buffering off;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Then, stop editing and run</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo nginx -s reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Configure-Local-DNS"><a href="#Configure-Local-DNS" class="headerlink" title="Configure Local DNS"></a>Configure Local DNS</h2><p><code>/etc/hosts</code></p><p>添加一行</p><p>For this example, we will assume the IP is: 10.9.98.213</p><pre class="line-numbers language-none"><code class="language-none"># &lt;ip&gt; &lt;fqdn&gt;10.9.98.213 app.onepanel.test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>常用命令</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">microk8s.kubectl describe node# Describe a nodemicrok8s.kubectl describe node ml#跟踪Node节点信息microk8s.kubectl describe pods -A #显示所有pod信息microk8s.kubectl describe pod kfserving-controller-manager-0 -n kfserving-system  #显示指定pod详细信息microk8s.kubectl delete deployment kfserving-models-web-app -n kfserving-system #删除deploymentmicrok8s.kubectl delete pod kfserving-controller-manager-0 -n kfserving-system #删除podmicrok8s.kubectl get pods --all-namespaces #同下microk8s kubectl get pods -A# 获取所有pod执行状态microk8s kubectl get deployment -A# 查看所有部署microk8s stop &amp;&amp; microk8s start &amp;&amp; microk8s status --wait-ready  #重启microk8s.kubectl logs -f onepanel-core-ui-7d9b8d5954-bbtzv -n onepanel#查看日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Install-onepanel&quot;&gt;&lt;a href=&quot;#Install-onepanel&quot; class=&quot;headerlink&quot; title=&quot;Install onepanel&quot;&gt;&lt;/a&gt;Install onepanel&lt;/h2&gt;&lt;h2 id=&quot;Install-o</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://knowledge-things.github.io/categories/kubernetes/"/>
    
    
    <category term="onepanel" scheme="https://knowledge-things.github.io/tags/onepanel/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu install vnc</title>
    <link href="https://knowledge-things.github.io/2022/10/13/ubuntu-install-vnc/"/>
    <id>https://knowledge-things.github.io/2022/10/13/ubuntu-install-vnc/</id>
    <published>2022-10-13T06:15:59.000Z</published>
    <updated>2022-10-13T06:18:56.511Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Install-and-Configure-a-VNC-in-Ubuntu"><a href="#Install-and-Configure-a-VNC-in-Ubuntu" class="headerlink" title="Install and Configure a VNC in Ubuntu"></a>Install and Configure a VNC in Ubuntu</h3><p>To install <strong>TigerVNC</strong> server and other associated packages in Ubuntu, run the following command.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo apt install tigervnc-standalone-server tigervnc-common tigervnc-xorg-extension tigervnc-viewer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Now start the VNC server by running the <strong>vncserver</strong> command as a normal user. This action will create the initial configuration stored in the <code>$HOME/.vnc</code> directory and it will also prompt you to set up a login password.</p><p>Enter a password (which must be at least six characters length) and confirm/verify it. Then set a view-only password if you wish, as follows.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver$ ls -l ~&#x2F;.vnc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Next, we need to configure the DE to work with the VNC <strong>server. So, stop the \</strong>VNC*<em> server using the following command, in order to perform some configurations.*</em></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ vncserver -kill :1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To configure <strong>GNOME</strong> or whatever desktop you have installed, create a file called <strong>xstartup</strong> under the configurations directory using your <a href="https://www.tecmint.com/linux-command-line-editors/">favorite text editor</a>.</p><pre class="line-numbers language-none"><code class="language-none">$ vi ~&#x2F;.vnc&#x2F;xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Add the following lines in the file. These commands will be automatically executed whenever you start or restart the TigerVNC server. Note that the commands may vary depending on the DE you installed.</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;shexec &#x2F;etc&#x2F;vnc&#x2F;xstartupxrdb $HOME&#x2F;.Xresourcesvncconfig -iconic &amp;dbus-launch --exit-with-session gnome-session &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Save the file and set the appropriate permission on the file so it can be executed.</p><pre class="line-numbers language-none"><code class="language-none">$ chmod 700 ~&#x2F;.vnc&#x2F;xstartup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Next, start the <strong>VNC</strong> server by running the following command as a normal user. Set your own values for the display geometry. In addition, use the <code>-localhost</code> flag to allow connections from the <strong>localhost</strong> only and by analogy, only from users authenticated on the server.</p><p>In addition, <strong>VNC</strong> by default uses TCP port <code>5900+N</code>, where <code>N</code> is the display number. In this case, the <code>:1</code> means that the VNC server will run on display port number <strong>5901</strong>.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver :1 -localhost -geometry 1024x768 -depth 32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>To list <strong>VNC</strong> server sessions on your system, run the following command.</p><pre class="line-numbers language-none"><code class="language-none">$ vncserver -list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Once the VNC server has started, check the port it is running on with the <a href="https://www.tecmint.com/20-netstat-commands-for-linux-network-management/">netstat command</a>.</p><pre class="line-numbers language-none"><code class="language-none">$ netstat -tlnp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">vncserver -localhost no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Install-and-Configure-a-VNC-in-Ubuntu&quot;&gt;&lt;a href=&quot;#Install-and-Configure-a-VNC-in-Ubuntu&quot; class=&quot;headerlink&quot; title=&quot;Install and Config</summary>
      
    
    
    
    <category term="linux" scheme="https://knowledge-things.github.io/categories/linux/"/>
    
    
    <category term="remote vnc" scheme="https://knowledge-things.github.io/tags/remote-vnc/"/>
    
  </entry>
  
  <entry>
    <title>microk8s安装onepanel</title>
    <link href="https://knowledge-things.github.io/2022/10/13/microk8s-an-zhuang-onepanel/"/>
    <id>https://knowledge-things.github.io/2022/10/13/microk8s-an-zhuang-onepanel/</id>
    <published>2022-10-13T03:11:42.000Z</published>
    <updated>2022-10-13T03:11:42.217Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Kubernetes-Dashboard</title>
    <link href="https://knowledge-things.github.io/2022/10/10/kubernetes-dashboard/"/>
    <id>https://knowledge-things.github.io/2022/10/10/kubernetes-dashboard/</id>
    <published>2022-10-10T02:24:22.000Z</published>
    <updated>2022-10-10T02:31:56.507Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-部署和访问-Kubernetes-仪表板"><a href="#1-部署和访问-Kubernetes-仪表板" class="headerlink" title="1.部署和访问 Kubernetes 仪表板"></a>1.部署和访问 Kubernetes 仪表板</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo recommended.yaml https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.6.1&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml#修改刚下载的yaml文件，添加type: NodePort -&gt; 外网访问$ vim recommended.yaml# ------------------- Dashboard Service ------------------- #kind: ServiceapiVersion: v1metadata:  labels:    k8s-app: kubernetes-dashboard  name: kubernetes-dashboard  namespace: kubernetes-dashboardspec:  ports:    - port: 443      targetPort: 8443  selector:    k8s-app: kubernetes-dashboard  type: NodePort----------------------------------------------------------------# create -f 创建dashboard$ kubectl create -f recommended.yaml# 查看namespace为kubernetes-dashboard下创建的pods$ kubectl get pods -n kubernetes-dashboard--------------------------------------------------------------------------NAME                                    READY   STATUS    RESTARTS   AGEkubernetes-dashboard-5fd74ddbcd-2m4j6   1&#x2F;1     Running   0          3d23h$ kubectl proxy &amp;# Starting to serve on 127.0.0.1:8001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Access Control:</strong> 创建一个admin账号，否则进去之后无法观测各个小集群的信息(没有admin权限登录后各个界面都没有集群信息)</p><pre class="line-numbers language-applescript" data-language="applescript"><code class="language-applescript">$ vim dashboard_admin.yaml# *** 请替换为你想创建的名字----------------------------------------apiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRoleBindingmetadata:  name: ***  namespace: kubernetes-dashboardroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:  - kind: ServiceAccount    name: ***    namespace: kubernetes-dashboard-----------------------------------------$ kubectl create -f dashboard_admin.yaml# 查找名为*** secret token$ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep ***| awk &#39;&#123;print $1&#125;&#39;)----------------------------------------------------token:   eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJl.....# 复制这长一串的token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>Chrome可能回因为证书问题无法访问</em></p><pre class="line-numbers language-autohotkey" data-language="autohotkey"><code class="language-autohotkey">在chrome该页面上，直接键盘敲入这12个字符：&#96;thisisunsafe&#96;**注意：鼠标点击当前页面任意位置，让页面处于最上层即可输入**<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="2-通过局域网访问"><a href="#2-通过局域网访问" class="headerlink" title="2.通过局域网访问"></a>2.通过局域网访问</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl port-forward -n kubernetes-dashboard --address 0.0.0.0 service&#x2F;kubernetes-dashboard 8080:443<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建一个dashboard管理用户</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create serviceaccount dashboard-admin -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>绑定用户为集群管理用户</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole&#x3D;cluster-admin --serviceaccount&#x3D;kube-system:dashboard-admin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完以上操作后,由于管理用户的名称为<code>dashboard-admin</code>,生成的对应的secret的值则为<code>dashboard-admin-token-随机字符串</code>我的机器上完整名称为<code>dashboard-admin-token-sg6bp</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[centos@k8s-master dashboard]$ kubectl get secret -n&#x3D;kube-system |grep dashboard-admin-tokendashboard-admin-token-sg6bp                      kubernetes.io&#x2F;service-account-token   3      23h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以看到这个secret的完整名称,或者不使用grep管道,列出所有的secrets,然后从中寻找需要的.</p><p>通过上面介绍过的<code>kubectl describe secret</code>命令查看token</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[centos@k8s-master dashboard]$ kubectl describe -n&#x3D;kube-system  secret dashboard-admin-token-sg6bpName:         dashboard-admin-token-sg6bpNamespace:    kube-systemLabels:       &lt;none&gt;Annotations:  kubernetes.io&#x2F;service-account.name: dashboard-admin              kubernetes.io&#x2F;service-account.uid: c60d2a65-619e-11e9-a627-0050568417a2Type:  kubernetes.io&#x2F;service-account-tokenData&#x3D;&#x3D;&#x3D;&#x3D;ca.crt:     1025 bytesnamespace:  11 bytestoken:      eyJhbGciOiJSUzI1NiIsImtp...[centos@k8s-master dashboard]$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把以上token复制到登陆页面的token栏里,就可以登陆了.登陆以后就可以看到如上面最后展示的有完整信息的界面.</p><h5 id="3-获取token"><a href="#3-获取token" class="headerlink" title="3.获取token"></a>3.获取token</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get secret -n&#x3D;kube-system |grep dashboard-admin-tokenkubectl describe -n&#x3D;kube-system  secret dashboard-admin-token-t854k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id><a href="#" class="headerlink" title=" "></a> </h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-部署和访问-Kubernetes-仪表板&quot;&gt;&lt;a href=&quot;#1-部署和访问-Kubernetes-仪表板&quot; class=&quot;headerlink&quot; title=&quot;1.部署和访问 Kubernetes 仪表板&quot;&gt;&lt;/a&gt;1.部署和访问 Kubernetes 仪</summary>
      
    
    
    
    <category term="kubernetes" scheme="https://knowledge-things.github.io/categories/kubernetes/"/>
    
    
    <category term="dashboard" scheme="https://knowledge-things.github.io/tags/dashboard/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes-kubectl安装</title>
    <link href="https://knowledge-things.github.io/2022/10/08/kubernetes-kubectl-an-zhuang/"/>
    <id>https://knowledge-things.github.io/2022/10/08/kubernetes-kubectl-an-zhuang/</id>
    <published>2022-10-08T07:14:12.000Z</published>
    <updated>2022-10-08T07:30:32.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-Linux-系统中安装并设置-kubectl"><a href="#在-Linux-系统中安装并设置-kubectl" class="headerlink" title="在 Linux 系统中安装并设置 kubectl"></a>在 Linux 系统中安装并设置 kubectl</h1><h2 id="准备开始"><a href="#准备开始" class="headerlink" title="准备开始"></a>准备开始</h2><p>kubectl 版本和集群版本之间的差异必须在一个小版本号内。 例如：v1.25 版本的客户端能与 v1.24、 v1.25 和 v1.26 版本的控制面通信。 用最新兼容版的 kubectl 有助于避免不可预见的问题。</p><h2 id="在-Linux-系统中安装-kubectl"><a href="#在-Linux-系统中安装-kubectl" class="headerlink" title="在 Linux 系统中安装 kubectl"></a>在 Linux 系统中安装 kubectl</h2><p>在 Linux 系统中安装 kubectl 有如下几种方法：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-kubectl-binary-with-curl-on-linux">用 curl 在 Linux 系统中安装 kubectl</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-using-native-package-management">用原生包管理工具安装</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/_print/#install-using-other-package-management">用其他包管理工具安装</a></li></ul><h3 id="用-curl-在-Linux-系统中安装-kubectl"><a href="#用-curl-在-Linux-系统中安装-kubectl" class="headerlink" title="用 curl 在 Linux 系统中安装 kubectl"></a>用 curl 在 Linux 系统中安装 kubectl</h3><ol><li><p>用以下命令下载最新发行版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明：</strong></p><p>如需下载某个指定的版本，请用指定版本号替换该命令的这一部分： <code>$(curl -L -s https://dl.k8s.io/release/stable.txt)</code>。</p><p>例如，要在 Linux 中下载 v1.25.0 版本，请输入：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;v1.25.0&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证该可执行文件（可选步骤）</p><p>下载 kubectl 校验和文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl.sha256&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于校验和文件，验证 kubectl 的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;$(cat kubectl.sha256)  kubectl&quot; | sha256sum --check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证通过时，输出为：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">kubectl: OK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证失败时，<code>sha256</code> 将以非零值退出，并打印如下输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl: FAILEDsha256sum: WARNING: 1 computed checksum did NOT match<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>下载的 kubectl 与校验和文件版本必须相同。</p></li><li><p>安装 kubectl</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo install -o root -g root -m 0755 kubectl &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>说明：</strong></p><p>即使你没有目标系统的 root 权限，仍然可以将 kubectl 安装到目录 <code>~/.local/bin</code>中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x kubectlmkdir -p ~&#x2F;.local&#x2F;binmv .&#x2F;kubectl ~&#x2F;.local&#x2F;bin&#x2F;kubectl# 之后将 ~&#x2F;.local&#x2F;bin 附加（或前置）到 $PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行测试，以保障你安装的版本是最新的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl version --client<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者使用如下命令来查看版本的详细信息：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">kubectl version --client --output&#x3D;yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="用原生包管理工具安装"><a href="#用原生包管理工具安装" class="headerlink" title="用原生包管理工具安装"></a>用原生包管理工具安装</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-install-0">基于 Debian 的发行版</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-install-1">基于 Red Hat 的发行版</a></li></ul><ol><li><p>更新 <code>apt</code> 包索引，并安装使用 Kubernetes <code>apt</code> 仓库所需要的包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y ca-certificates curl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果你使用 Debian 9（stretch）或更早版本，则你还需要安装 <code>apt-transport-https</code>：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install -y apt-transport-https<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>下载 Google Cloud 公开签名秘钥：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加 Kubernetes <code>apt</code> 仓库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg] https:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>更新 <code>apt</code> 包索引，使之包含新的仓库并安装 kubectl：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="用其他包管理工具安装"><a href="#用其他包管理工具安装" class="headerlink" title="用其他包管理工具安装"></a>用其他包管理工具安装</h3><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#other-kubectl-install-0">Snap</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#other-kubectl-install-1">Homebrew</a></li></ul><p>如果你使用的 Ubuntu 或其他 Linux 发行版，内建支持 <a href="https://snapcraft.io/docs/core/install">snap</a> 包管理工具， 则可用 <a href="https://snapcraft.io/">snap</a> 命令安装 kubectl。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">snap install kubectl --classickubectl version --client<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="验证-kubectl-配置"><a href="#验证-kubectl-配置" class="headerlink" title="验证 kubectl 配置"></a>验证 kubectl 配置</h2><p>为了让 kubectl 能发现并访问 Kubernetes 集群，你需要一个 <a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/">kubeconfig 文件</a>， 该文件在 <a href="https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh">kube-up.sh</a> 创建集群时，或成功部署一个 Miniube 集群时，均会自动生成。 通常，kubectl 的配置信息存放于文件 <code>~/.kube/config</code> 中。</p><p>通过获取集群状态的方法，检查是否已恰当的配置了 kubectl：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl cluster-info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回一个 URL，则意味着 kubectl 成功的访问到了你的集群。</p><p>如果你看到如下所示的消息，则代表 kubectl 配置出了问题，或无法连接到 Kubernetes 集群。</p><pre class="line-numbers language-none"><code class="language-none">The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?（访问 &lt;server-name:port&gt; 被拒绝 - 你指定的主机和端口是否有误？）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>例如，如果你想在自己的笔记本上（本地）运行 Kubernetes 集群，你需要先安装一个 Minikube 这样的工具，然后再重新运行上面的命令。</p><p>如果命令 <code>kubectl cluster-info</code> 返回了 url，但你还不能访问集群，那可以用以下命令来检查配置是否妥当：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl cluster-info dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="kubectl-的可选配置和插件"><a href="#kubectl-的可选配置和插件" class="headerlink" title="kubectl 的可选配置和插件"></a>kubectl 的可选配置和插件</h2><h3 id="启用-shell-自动补全功能"><a href="#启用-shell-自动补全功能" class="headerlink" title="启用 shell 自动补全功能"></a>启用 shell 自动补全功能</h3><p>kubectl 为 Bash、Zsh、Fish 和 PowerShell 提供自动补全功能，可以为你节省大量的输入。</p><p>下面是为 Bash、Fish 和 Zsh 设置自动补全功能的操作步骤。</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-0">Bash</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-1">Fish</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-autocompletion-2">Zsh</a></li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>kubectl 的 Bash 补全脚本可以用命令 <code>kubectl completion bash</code> 生成。 在 Shell 中导入（Sourcing）补全脚本，将启用 kubectl 自动补全功能。</p><p>然而，补全脚本依赖于工具 <a href="https://github.com/scop/bash-completion"><strong>bash-completion</strong></a>， 所以要先安装它（可以用命令 <code>type _init_completion</code> 检查 bash-completion 是否已安装）。</p><h3 id="安装-bash-completion"><a href="#安装-bash-completion" class="headerlink" title="安装 bash-completion"></a>安装 bash-completion</h3><p>很多包管理工具均支持 bash-completion（参见<a href="https://github.com/scop/bash-completion#installation">这里</a>）。 可以通过 <code>apt-get install bash-completion</code> 或 <code>yum install bash-completion</code> 等命令来安装它。</p><p>上述命令将创建文件 <code>/usr/share/bash-completion/bash_completion</code>，它是 bash-completion 的主脚本。 依据包管理工具的实际情况，你需要在 <code>~/.bashrc</code> 文件中手工导入此文件。</p><p>要查看结果，请重新加载你的 Shell，并运行命令 <code>type _init_completion</code>。 如果命令执行成功，则设置完成，否则将下面内容添加到文件 <code>~/.bashrc</code> 中：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">source &#x2F;usr&#x2F;share&#x2F;bash-completion&#x2F;bash_completion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新加载 Shell，再输入命令 <code>type _init_completion</code> 来验证 bash-completion 的安装状态。</p><h3 id="启动-kubectl-自动补全功能"><a href="#启动-kubectl-自动补全功能" class="headerlink" title="启动 kubectl 自动补全功能"></a>启动 kubectl 自动补全功能</h3><h4 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h4><p>你现在需要确保一点：kubectl 补全脚本已经导入（sourced）到 Shell 会话中。 可以通过以下两种方法进行设置：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-bash-autocompletion-0">当前用户</a></li><li><a href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#kubectl-bash-autocompletion-1">系统全局</a></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;source &lt;(kubectl completion bash)&#39; &gt;&gt;~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果 kubectl 有关联的别名，你可以扩展 Shell 补全来适配此别名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &#39;alias k&#x3D;kubectl&#39; &gt;&gt;~&#x2F;.bashrcecho &#39;complete -o default -F __start_kubectl k&#39; &gt;&gt;~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>bash-completion 负责导入 <code>/etc/bash_completion.d</code> 目录中的所有补全脚本。</p><p>两种方式的效果相同。重新加载 Shell 后，kubectl 自动补全功能即可生效。 若要在当前 Shell 会话中启用 Bash 补全功能，需要运行 <code>exec bash</code> 命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">exec bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装-kubectl-convert-插件"><a href="#安装-kubectl-convert-插件" class="headerlink" title="安装 kubectl convert 插件"></a>安装 <code>kubectl convert</code> 插件</h3><p>一个 Kubernetes 命令行工具 <code>kubectl</code> 的插件，允许你将清单在不同 API 版本间转换。 这对于将清单迁移到新的 Kubernetes 发行版上未被废弃的 API 版本时尤其有帮助。 更多信息请访问 <a href="https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-guide/#migrate-to-non-deprecated-apis">迁移到非弃用 API</a></p><ol><li><p>用以下命令下载最新发行版：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl-convert&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证该可执行文件（可选步骤）</p><p>下载 kubectl-convert 校验和文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -LO &quot;https:&#x2F;&#x2F;dl.k8s.io&#x2F;$(curl -L -s https:&#x2F;&#x2F;dl.k8s.io&#x2F;release&#x2F;stable.txt)&#x2F;bin&#x2F;linux&#x2F;amd64&#x2F;kubectl-convert.sha256&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于校验和，验证 kubectl-convert 的可执行文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;$(cat kubectl-convert.sha256) kubectl-convert&quot; | sha256sum --check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证通过时，输出为：</p><pre class="line-numbers language-console" data-language="console"><code class="language-console">kubectl-convert: OK<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证失败时，<code>sha256</code> 将以非零值退出，并打印输出类似于：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl-convert: FAILEDsha256sum: WARNING: 1 computed checksum did NOT match<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>下载相同版本的可执行文件和校验和。</p></li><li><p>安装 kubectl-convert</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo install -o root -g root -m 0755 kubectl-convert &#x2F;usr&#x2F;local&#x2F;bin&#x2F;kubectl-convert<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>验证插件是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl convert --help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你没有看到任何错误就代表插件安装成功了。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;在-Linux-系统中安装并设置-kubectl&quot;&gt;&lt;a href=&quot;#在-Linux-系统中安装并设置-kubectl&quot; class=&quot;headerlink&quot; title=&quot;在 Linux 系统中安装并设置 kubectl&quot;&gt;&lt;/a&gt;在 Linux 系统中安装并</summary>
      
    
    
    
    <category term="k8s" scheme="https://knowledge-things.github.io/categories/k8s/"/>
    
    
    <category term="kubectl" scheme="https://knowledge-things.github.io/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes安装</title>
    <link href="https://knowledge-things.github.io/2022/10/08/kubernetes-an-zhuang/"/>
    <id>https://knowledge-things.github.io/2022/10/08/kubernetes-an-zhuang/</id>
    <published>2022-10-08T07:10:19.000Z</published>
    <updated>2022-10-10T02:26:55.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考文档<a href="https://zhuanlan.zhihu.com/p/146028810">https://zhuanlan.zhihu.com/p/146028810</a></p></blockquote><h2 id="安装kubeadm-kubelet-和-kubectl"><a href="#安装kubeadm-kubelet-和-kubectl" class="headerlink" title="安装kubeadm, kubelet 和 kubectl"></a>安装kubeadm, kubelet 和 kubectl</h2><p>部署之前，我们需要安装一下三个包：</p><ul><li><strong>kubeadm</strong>: 引导启动k8s集群的命令行工具。</li><li><strong>kubelet</strong>: 在群集中所有节点上运行的核心组件, 用来执行如启动pods和containers等操作。</li><li><strong>kubectl</strong>: 操作集群的命令行工具。</li></ul><p>首先添加apt-key：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt update &amp;&amp; sudo apt install -y apt-transport-https curlcurl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="1-下载-Google-Cloud-公开签名秘钥："><a href="#1-下载-Google-Cloud-公开签名秘钥：" class="headerlink" title="1.下载 Google Cloud 公开签名秘钥："></a>1.下载 Google Cloud 公开签名秘钥：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo curl -fsSLo &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg   (可手动下载)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-添加-Kubernetes-apt-仓库："><a href="#2-添加-Kubernetes-apt-仓库：" class="headerlink" title="2.添加 Kubernetes apt 仓库："></a>2.添加 Kubernetes <code>apt</code> 仓库：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo &quot;deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;kubernetes-archive-keyring.gpg] http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kubernetes&#x2F;apt kubernetes-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-更新-apt-包索引，安装-kubelet、kubeadm-和-kubectl，并锁定其版本："><a href="#3-更新-apt-包索引，安装-kubelet、kubeadm-和-kubectl，并锁定其版本：" class="headerlink" title="3.更新 apt 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本："></a>3.更新 <code>apt</code> 包索引，安装 kubelet、kubeadm 和 kubectl，并锁定其版本：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get updatesudo apt-get install -y kubelet&#x3D;1.23.12-00 kubeadm&#x3D;1.23.12-00 kubectl&#x3D;1.23.12-00sudo apt-mark hold kubelet kubeadm kubectl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>安装老版本的 Kubernetes</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-cache madison kubectl | grep $&#123;version&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关闭Swap</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo swapoff -a# use &quot;free -m&quot; to see if we successfully unable the swap$ free -m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-创建Master节点"><a href="#4-创建Master节点" class="headerlink" title="4.创建Master节点"></a>4.创建Master节点</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm init --config kubeadm-config.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># kubeadm-config.yamlkind: ClusterConfigurationapiVersion: kubeadm.k8s.io&#x2F;v1beta3kubernetesVersion: v1.23.12imageRepository: registry.cn-hangzhou.aliyuncs.com&#x2F;google_containersnetworking:  podSubnet: 10.244.0.0&#x2F;16  serviceSubnet: 172.16.0.0&#x2F;16---kind: KubeletConfigurationapiVersion: kubelet.config.k8s.io&#x2F;v1beta1cgroupDriver: cgroupfs---apiVersion: kubeadm.k8s.io&#x2F;v1beta3kind: InitConfigurationlocalAPIEndpoint:  advertiseAddress: &quot;192.168.0.192&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据上面的步骤：</p><p><strong>1)</strong> 在主机节点(A)当前用户home下创建.kube, 拷贝admin配置文件，赋予权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ mkdir -p $HOME&#x2F;.kube$ sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config$ sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2)</strong> 在主节点(A)安装网络插件，这是必要的，因为pod之间需要通信, 这里使用的是flannel</p><pre class="line-numbers language-applescript" data-language="applescript"><code class="language-applescript">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml# 其他 Networking 和 network policy 可以参考以下链接https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-添加Worker节点"><a href="#5-添加Worker节点" class="headerlink" title="5.添加Worker节点"></a>5.添加Worker节点</h5><p>要为群集添加工作节点，需要为每台计算机执行以下操作：</p><ul><li>SSH到机器</li><li>成为root用户，(如: sudo su -)</li><li>运行上面的<code>kubeadm init</code>命令输出的：<code>kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code></li></ul><p>如果我们忘记了Master节点的加入token，可以使用如下命令来查看：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm token list# 输出：# TOKEN                     TTL       EXPIRES                USAGES                   DESCRIPTION   EXTRA GROUPS# abcdef.0123456789abcdef   22h       2018-11-10T14:24:51Z   authentication,signing   &lt;none&gt;        system:bootstrappers:kubeadm:default-node-token<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>记录 <code>kubeadm init</code> 输出的 <code>kubeadm join</code> 命令。 你需要此命令<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#join-nodes">将节点加入集群</a>。</p><pre class="line-numbers language-none"><code class="language-none">kubeadm join 192.168.0.192:6443 --token yca760.ascp39dkvddytq3h \        --discovery-token-ca-cert-hash sha256:ecfd86831e088af80789823035d4999fc45c050610a4b787ba84e50750493ed9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以使用下面的名为 <code>kubeadm-config.yaml</code> 的 kubeadm <a href="https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/docs/reference/config-api/kubeadm-config.v1beta3">配置文件</a> 示例用于向集群中添加另一个控制面节点。</p><p><a href="https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/setup/production-environment/tools/kubeadm/dual-stack-support.md">https://github.com/rucjohn/books-official-doc-kubenetes/blob/4a9b421a1a8727548b2f3ebdca0de77024837f0e/setup/production-environment/tools/kubeadm/dual-stack-support.md</a></p><pre class="line-numbers language-none"><code class="language-none">apiVersion: kubeadm.k8s.io&#x2F;v1beta3kind: JoinConfigurationcontrolPlane:  localAPIEndpoint:    advertiseAddress: &quot;192.168.0.193&quot;    bindPort: 6443discovery:  bootstrapToken:    apiServerEndpoint: 192.168.0.192:6443    token: &quot;yca760.ascp39dkvddytq3h&quot;    caCertHashes:    - &quot;sha256:ecfd86831e088af80789823035d4999fc45c050610a4b787ba84e50750493ed9&quot;    # 请更改上面的认证信息，使之与你的集群中实际使用的令牌和 CA 证书匹配nodeRegistration:  kubeletExtraArgs:    node-ip: 10.100.0.4,fd00:1:2:3::4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，token的有效期是24小时，如果我们的token已经过期的话，可以使用以下命令重新生成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm token create# 输出：# 9w6mbu.3k2z7pprl3eaozk9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们也没有<code>--discovery-token-ca-cert-hash</code>的值，可以使用以下命令生成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">openssl x509 -pubkey -in &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;ca.crt | openssl rsa -pubin -outform der 2&gt;&#x2F;dev&#x2F;null | openssl dgst -sha256 -hex | sed &#39;s&#x2F;^.* &#x2F;&#x2F;&#39;# 输出：# 9fcb02a0f4ab216866f87986106437b7305474850f0de81b9ac9c36a468f7c67<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-卸载-k8s"><a href="#6-卸载-k8s" class="headerlink" title="6.卸载 k8s"></a>6.卸载 k8s</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#卸载集群kubeadm resetrm -rf $HOME&#x2F;.kube---------------sudo apt-get purge kubeadm kubectl kubelet kubernetes-cni sudo apt-get autoremove  sudo rm -rf ~&#x2F;.kube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考文档&lt;a href=&quot;https://zhuanlan.zhihu.com/p/146028810&quot;&gt;https://zhuanlan.zhihu.com/p/146028810&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装</summary>
      
    
    
    
    <category term="k8s" scheme="https://knowledge-things.github.io/categories/k8s/"/>
    
    
    <category term="kubernetes" scheme="https://knowledge-things.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>系统过载时施加背压</title>
    <link href="https://knowledge-things.github.io/2022/09/29/xi-tong-guo-zai-shi-shi-jia-bei-ya/"/>
    <id>https://knowledge-things.github.io/2022/09/29/xi-tong-guo-zai-shi-shi-jia-bei-ya/</id>
    <published>2022-09-29T02:54:21.000Z</published>
    <updated>2022-09-29T02:57:17.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://mechanical-sympathy.blogspot.com/">Mechanical Sympathy</a></p></blockquote><p>系统在持续负载下应如何响应？它是否应该继续接受请求，直到它的响应时间跟随致命的曲棍球棒，然后是崩溃？除非系统设计为处理到达的请求多于其处理能力的情况，否则通常会发生这种情况。如果我们看到请求的持续到达率超过了我们的系统能够处理的能力，那么就必须付出一些代价。让整个系统降级并不是我们想要为客户提供的理想服务。更好的方法是以我们系统的最大可能吞吐率处理事务，同时保持良好的响应时间，并拒绝超过此到达率的请求。</p><p>让我们将一个小型美术馆作为一个隐喻。在这个画廊中，典型的观众平均花费 20 分钟浏览，画廊最多可容纳 30 位观众。如果超过 30 位观众同时占据画廊，那么客户就会因为无法清楚地看到画作而变得不高兴。如果发生这种情况，他们不太可能购买或退货。为了让我们的观众满意，最好建议一些观众去几扇门下的咖啡馆，然后在画廊不那么忙的时候回来。这样，画廊里的观众就可以在没有其他观众的情况下看到所有的画作，同时那些我们无法容纳的人享用咖啡。如果我们应用<a href="http://en.wikipedia.org/wiki/Little&#39;s_law">利特尔定律</a>我们不能让客户到达每小时超过 90 个，否则会超出最大容量。如果他们在 9:00-10:00 之间以每小时 100 人的速度到达，那么我相信路边的咖啡馆会感谢额外的 10 位顾客。</p><p>在我们的系统中，可用容量通常取决于我们的线程池大小和处理单个事务的时间。这些线程池通常以队列为前端，以处理高于我们最大到达率的流量突发。如果队列是无界的，并且我们的到达率持续高于最大容量，那么队列将不受限制地增长。随着队列的增长，它们越来越多地增加了超出可接受响应时间的延迟，最终它们将消耗所有内存，导致我们的系统出现故障。将溢出的请求发送到咖啡馆，同时仍以最大可能的速度为其他人提供服务不是更好吗？我们可以通过设计我们的系统来应用“背压”来做到这一点。</p><div class="table-container"><table><thead><tr><th><a href="https://4.bp.blogspot.com/-H5j78ebce9w/T7erBJ8X-gI/AAAAAAAAADM/F_ak3B9Wdl0/s1600/back-pressure.png"><img src="https://4.bp.blogspot.com/-H5j78ebce9w/T7erBJ8X-gI/AAAAAAAAADM/F_ak3B9Wdl0/s1600/back-pressure.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1。</td></tr></tbody></table></div><p><a href="http://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离</a>鼓励在所有级别进行良好的系统设计。我喜欢分层设计，以便第三方网关与主要交易服务分开。这可以通过让网关只负责协议转换和边界安全来实现。典型的网关可以是运行<a href="http://jcp.org/en/jsr/detail?id=315">Servlets</a>的 Web 容器。<a href="http://martinfowler.com/eaaCatalog/domainModel.html">网关接受客户请求，应用适当的安全性，并转换通道协议以转发到托管域模型</a>的事务服务. 如果需要保留事务，事务服务可以使用持久存储。例如，聊天服务器域模型的状态可能不需要保存，而出于合规和业务原因，金融交易模型必须保存多年。</p><p>图 1. 上面是许多系统中典型请求流的简化视图。网关中的线程池接受用户请求并将它们转发给事务服务。假设我们有一个异步事务服务，前面有一个输入和输出队列，或类似的<a href="http://en.wikipedia.org/wiki/FIFO">FIFO</a>结构。如果我们希望系统满足响应时间服务质量（QoS）保证，那么我们需要考虑以下三个变量：</p><ol><li>线程上单个事务所花费的时间</li><li>池中可以并行执行事务的线程数</li><li><p>设置最大可接受延迟的输入队列长度</p><p><strong>最大延迟=（事务时间/线程数）*队列长度</strong></p><p><strong>队列长度=最大延迟/（事务时间/线程数）</strong></p></li></ol><p>通过允许队列不受限制，延迟将继续增加。因此，如果我们想设置最大响应时间，那么我们需要限制队列长度。</p><p>通过限制输入队列，我们阻止了接收网络数据包的线程，这将向上游施加背压。如果网络协议是 TCP，则通过填充网络缓冲区对发送方施加类似的背压。这个过程可以通过网关一直重复到客户那里。对于每项服务，我们都需要配置队列，以便它们在实现端到端客户体验所需的服务质量方面发挥作用。</p><p>我经常发现的最大胜利之一是缩短处理单个事务延迟所需的时间。这有助于最好和最坏的情况。</p><h5 id="最坏"><a href="#最坏" class="headerlink" title="最坏"></a><strong>最坏</strong></h5><p>的情况假设队列是无限的，系统处于持续的重负载下。在内存耗尽之前，事情可能会以微妙的方式很快开始出错。当队列大于处理器缓存时，您认为会发生什么？消费者线程将在他们努力跟上的时候遭受缓存未命中，从而使问题更加复杂。这可能会导致系统很快陷入困境并最终崩溃。在 Linux 下，这尤其令人讨厌，因为<a href="http://en.wikipedia.org/wiki/C_dynamic_memory_allocation">malloc</a>或其朋友之一会成功，因为 Linux 默认允许“<a href="http://www.win.tue.nl/~aeb/linux/lk/lk-9.html#ss9.6">过度提交</a>”，然后在使用该内存时，<a href="http://lwn.net/Articles/317814/"> OOM Killer</a>将开始拍摄过程。当操作系统开始拍摄过程时，你就知道事情不会有好的结局！</p><p><strong>那么同步设计呢？</strong></p><p>你可能会说同步设计没有队列。好吧，不是那么明显。如果您有一个线程池，那么它将有一个锁或信号量等待队列来分配线程。如果您足够疯狂地为每个请求分配一个新线程，那么一旦您克服了创建线程的巨大成本，您的线程就会在运行队列中等待处理器执行。此外，这些队列涉及上下文切换和条件变量，这大大增加了<a href="http://mechanical-sympathy.blogspot.co.uk/2011/11/locks-condition-variables-latency.html">成本</a>. 你不能逃避排队，他们无处不在！最好接受它们并设计您的系统需要向其客户提供的服务质量。如果我们必须有队列，那就为它们设计，也许选择一些性能很好的无锁队列。</p><p>当我们需要支持像 REST 这样的同步协议时，使用背压（由我们在网关处的完整传入队列发出信号）发送有意义的“服务器繁忙”消息，例如 HTTP 503 状态代码。然后，客户可以将此解释为在路边的咖啡馆享用咖啡和蛋糕的时间。</p><p><strong>需要注意的细微之处…</strong></p><p>您需要考虑整个端到端服务。如果客户端从您的系统中使用数据的速度非常慢怎么办？它可能会在网关中绑定一个线程，使其停止工作。现在你有更少的线程在队列中工作，所以响应时间会增加。需要监控队列和线程，并且在超过阈值时需要采取适当的措施。例如，当队列已满 70% 时，是否应该发出警报以便进行调查？此外，还需要对交易时间进行抽样，以确保它们在预期范围内。</p><h5 id="概括"><a href="#概括" class="headerlink" title="概括"></a><strong>概括</strong></h5><p>如果我们不考虑我们的系统在重负载下的表现，那么它们很可能会严重退化，最坏的情况是崩溃。当它们以这种方式崩溃时，我们会发现是否有任何真正邪恶的数据损坏漏洞潜伏在那些黑暗的地方。应用背压是应对持续高负载的一种有效技术，这样可以在不降低已接受请求和事务的系统性能的情况下提供最大吞吐量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转自&lt;a href=&quot;https://mechanical-sympathy.blogspot.com/&quot;&gt;Mechanical Sympathy&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统在持续负载下应如何响应？它是否应该继续接受请求</summary>
      
    
    
    
    <category term="并发编程" scheme="https://knowledge-things.github.io/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="backpressure" scheme="https://knowledge-things.github.io/tags/backpressure/"/>
    
  </entry>
  
  <entry>
    <title>git撤销commit</title>
    <link href="https://knowledge-things.github.io/2022/09/29/git-che-xiao-commit/"/>
    <id>https://knowledge-things.github.io/2022/09/29/git-che-xiao-commit/</id>
    <published>2022-09-29T02:02:55.000Z</published>
    <updated>2022-09-29T02:04:01.050Z</updated>
    
    <content type="html"><![CDATA[<p>当我们写完代码后，我们一般都是</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">git add . &#x2F;&#x2F; 添加所有文件git commit - m &quot;xxxxxx&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们<code>git commit</code>完之后，还没有执行<code>git push</code>，想修改/撤销这个<code>commit</code>，怎么办？</p><h2 id="1、如果只是想修改注释，可以这样操作"><a href="#1、如果只是想修改注释，可以这样操作" class="headerlink" title="1、如果只是想修改注释，可以这样操作"></a>1、如果只是想修改注释，可以这样操作</h2><p><code>git commit --amend</code><br>这个时候进入<code>vim</code>编辑，直接修改即可，修改完注释，退出<code>vim</code>编辑<br><code>:wq</code>保存已编辑的注释，重新<code>git push</code>即可</p><h2 id="2、要撤回commit"><a href="#2、要撤回commit" class="headerlink" title="2、要撤回commit"></a>2、要撤回commit</h2><p><code>git reset --soft HEAD^</code><br>这样就能成功的撤回你刚刚的<code>commit</code>操作。</p><p>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>如果你进行了2次commit，想都撤回，可以使用HEAD~2<br><strong>注意，这个命令仅仅是撤回commit操作，写的代码仍然保留</strong></p><hr><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p><code>--mixed</code><br>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数，<code>git reset --mixed HEAD^</code> 和 <code>git reset HEAD^</code> 效果是一样的。</p><p><code>--soft</code><br>不删除工作空间改动代码，<strong>撤销commit</strong>，<strong>不撤销<code>git add .</code></strong> </p><p><code>--hard</code><br><strong>删除工作空间改动代码</strong>，<strong>撤销commit，撤销<code>git add .</code></strong><br><strong>注意完成这个操作后，会删除工作空间代码！！！恢复到上一次的commit状态。慎重！！！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们写完代码后，我们一般都是&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-armasm&quot; data-language=&quot;armasm&quot;&gt;&lt;code class=&quot;language-armasm&quot;&gt;git add . &amp;#x2F;&amp;#x2F;</summary>
      
    
    
    
    <category term="版本管理" scheme="https://knowledge-things.github.io/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="git" scheme="https://knowledge-things.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>基于锁与无锁并发算法</title>
    <link href="https://knowledge-things.github.io/2022/09/28/jcp-jsr166/"/>
    <id>https://knowledge-things.github.io/2022/09/28/jcp-jsr166/</id>
    <published>2022-09-28T10:25:32.000Z</published>
    <updated>2022-09-29T02:30:44.440Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JSR 166 <a href="https://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html">https://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html</a><br>​<a href="https://jcp.org/en/jsr/detail?id=166">https://jcp.org/en/jsr/detail?id=166</a><br>​<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html">https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html</a></p><p>​    原文链接 <a href="https://mechanical-sympathy.blogspot.com/2013/08/lock-based-vs-lock-free-concurrent.html">https://mechanical-sympathy.blogspot.com/2013/08/lock-based-vs-lock-free-concurrent.html</a></p></blockquote><p><strong>测试用例</strong></p><p>为了比较实现，我需要一个不支持特定方法的 API 测试用例。例如，API 应该是无垃圾的并允许方法是原子的。一个简单的测试用例是设计一个可以在二维空间周围移动的宇宙飞船，其位置坐标可以以原子方式读取。每个事务至少需要读取或写入 2 个字段才能使并发有趣。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 与可以移动的船的并发表示的接口 * 一个二维空间，同时执行更新和读取。 *&#x2F;public interface Spaceship&#123;    &#x2F;**     * Read the position of the spaceship into the array of coordinates provided.     *     * @param coordinates into which the x and y coordinates should be read.     * @return the number of attempts made to read the current state.     *&#x2F;    int readPosition(final int[] coordinates);    &#x2F;**     * Move the position of the spaceship by a delta to the x and y coordinates.     *     * @param xDelta delta by which the spaceship should be moved in the x-axis.     * @param yDelta delta by which the spaceship should be moved in the y-axis.     * @return the number of attempts made to write the new coordinates.     *&#x2F;    int move(final int xDelta, final int yDelta);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过分解一个不可变的 Position 对象，上面的 API 会更干净，但我想保持它无垃圾，并创建以最小间接更新多个内部字段的需要。这个 API 可以很容易地扩展到 3 维空间，并且要求实现是原子的。</p><p>为每艘宇宙飞船构建了多个实现，并由测试工具执行。此博客的所有代码和结果都可以在<a href="https://github.com/mjpt777/rw-concurrency">这里</a>找到。<a href="https://github.com/mjpt777/rw-concurrency/blob/master/src/PerfTest.java">测试工具</a></p><p>将依次运行每个实现，方法是使用<a href="http://mechanical-sympathy.blogspot.co.uk/2012/04/invoke-interface-optimisations.html">超态调度</a>模式来尝试并防止在访问并发方法时内联、锁粗化和循环展开。</p><p>每个实现都受到 4 种不同的线程场景的影响，这些场景会导致不同的争用配置文件：</p><ul><li>1 位读者 - 1 位作者</li><li>2 位读者 - 1 位作者</li><li>3 位读者 - 1 位作者</li><li>2 位读者 - 2 位作者</li></ul><p>所有测试均使用 64 位 Java 1.7.0_25、Linux 3.6.30 和四核 2.2GHz Ivy Bridge i7-3632QM 运行。对于每个实施，吞吐量在 5 秒内测量，测试重复 5 次以确保充分预热。下面的结果是 5 次运行的平均每秒吞吐量。为了近似典型的 Java 部署，没有使用线程亲和性或核心隔离，这会显着减少方差。</p><p><strong>注意：</strong>其他 CPU 和操作系统可能会产生非常不同的结果。</p><p><strong>结果</strong></p><div class="table-container"><table><thead><tr><th><a href="https://3.bp.blogspot.com/-OPpjg2SYJNg/Uhsd8wDzwvI/AAAAAAAAAKU/CDFVT_GKKQg/s1600/1-reader-1-writer.png"><img src="https://3.bp.blogspot.com/-OPpjg2SYJNg/Uhsd8wDzwvI/AAAAAAAAAKU/CDFVT_GKKQg/s1600/1-reader-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://4.bp.blogspot.com/-FLfb4NzCfDE/Uhseh8sGtAI/AAAAAAAAAKc/NhTqXc_PgEw/s1600/2-readers-1-writer.png"><img src="https://4.bp.blogspot.com/-FLfb4NzCfDE/Uhseh8sGtAI/AAAAAAAAAKc/NhTqXc_PgEw/s1600/2-readers-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 2。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://3.bp.blogspot.com/-XfxlHbgvM2M/Uhse4umPIcI/AAAAAAAAAKk/WTlZfBFKZMc/s1600/3-readers-1-writer.png"><img src="https://3.bp.blogspot.com/-XfxlHbgvM2M/Uhse4umPIcI/AAAAAAAAAKk/WTlZfBFKZMc/s1600/3-readers-1-writer.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 3。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th><a href="https://1.bp.blogspot.com/-wOEnC0kN-XY/UhsfRf2ld3I/AAAAAAAAAKs/7l9BA5rRTMM/s1600/2-readers-2-writers.png"><img src="https://1.bp.blogspot.com/-wOEnC0kN-XY/UhsfRf2ld3I/AAAAAAAAAKs/7l9BA5rRTMM/s1600/2-readers-2-writers.png" alt="img"></a></th></tr></thead><tbody><tr><td>图 4。</td></tr></tbody></table></div><p>上述图表的原始数据可在<a href="https://github.com/mjpt777/rw-concurrency/tree/master/data">此处</a>找到。</p><p><strong>分析</strong></p><p>结果让我真正吃惊的是 ReentrantReadWriteLock 的性能。除了在读取和写入很少的情况下存在巨大平衡的情况之外，我看不到这种实现的用途。我的主要收获是：</p><ol><li>StampedLock 是对现有锁实现的重大改进，尤其是随着阅读器线程数量的增加。</li><li>StampedLock 有一个复杂的 API。很容易错误地调用错误的锁定操作方法。</li><li>当争用仅来自 2 个线程时，同步是一个很好的通用锁实现。</li><li>ReentrantLock 是一个很好的通用锁实现，当线程数如<a href="http://mechanical-sympathy.blogspot.co.uk/2011/11/java-lock-implementations.html">先前发现</a>的那样增长时。</li><li>选择使用 ReentrantReadWriteLock 应该基于仔细和适当的测量。与所有重大决策一样，根据数据衡量和做出决策。</li><li>与基于锁的算法相比，无锁实现可以提供显着的吞吐量优势。</li></ol><p><strong>结论</strong></p><p>很高兴看到基于锁的算法中出现的无锁技术的影响。在写入器不更新时，读取时采用的乐观策略实际上是一种无锁算法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JSR 166 &lt;a href=&quot;https://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html&quot;&gt;https://gee.cs.oswego.edu</summary>
      
    
    
    
    <category term="concurrent" scheme="https://knowledge-things.github.io/categories/concurrent/"/>
    
    
    <category term="JUC" scheme="https://knowledge-things.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>simple-binary-encoding</title>
    <link href="https://knowledge-things.github.io/2022/09/28/simple-binary-encoding/"/>
    <id>https://knowledge-things.github.io/2022/09/28/simple-binary-encoding/</id>
    <published>2022-09-28T08:59:44.000Z</published>
    <updated>2022-09-28T09:03:48.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html">https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html</a><br>github <a href="https://github.com/real-logic/simple-binary-encoding">https://github.com/real-logic/simple-binary-encoding</a><br>wiki <a href="https://github.com/real-logic/simple-binary-encoding/wiki">https://github.com/real-logic/simple-binary-encoding/wiki</a></p></blockquote><p>金融系统通过以多种不同格式发送和接收大量消息进行通信。当人们使用像“巨大”这样的词时，我通常会想，“真的……有多少？” 因此，让我们量化金融业的“巨大”。来自金融交易所的市场数据馈送通常每秒可发出数万或数十万条消息，而像<a href="http://www.opradata.com/">OPRA</a>这样的聚合馈送峰值可达到每秒超过 1000 万条消息，并且数量逐年增长。此演示文稿提供了一个很好的<a href="https://fif.com/docs/2013_6_fifmd_capacity_stats.pdf">概述</a>。</p><p>在这个疯狂的世界中，我们仍然看到大量使用 ASCII 编码的表示形式，例如<a href="http://en.wikipedia.org/wiki/Financial_Information_eXchange">FIX</a>标签值，以及一些稍微健全的二进制编码表示形式，例如 <a href="http://en.wikipedia.org/wiki/FAST_protocol">FAST</a>. 有些市场甚至犯了将市场数据作为 XML 发送的罪行！好吧，我不能抱怨太多，因为他们有时为我提供了编写超快速 XML 解析器的可观收入。</p><p>去年，作为 FIX<a href="http://www.fixtradingcommunity.org/">社区</a>成员的 CME委托 29West LBM 名气的<a href="https://twitter.com/toddlmontgomery">Todd Montgomery</a>和我自己构建新的 FIX <a href="http://real-logic.github.io/simple-binary-encoding/">简单二进制编码的参考实现</a>(SBE) 标准。SBE 是一种编解码器，旨在解决低延迟交易中的效率问题，特别关注市场数据。CME 在 FIX 社区内工作，在提出如此高效的编码演示方面做得非常出色。对于过去的 FIX 标签值实现的罪恶，也许是一个合适的赎罪。Todd 和我致力于 Java 和 C++ 的实现，后来我们在 .Net 方面得到了<a href="http://weareadaptive.com/">Adaptive出色的</a><a href="https://twitter.com/olivierdeheurle">Olivier Deheurles</a>的帮助。与这样的团队一起解决一个很酷的技术问题是一项梦寐以求的工作。<strong>SBE 概述</strong> SBE 是一种<a href="http://en.wikipedia.org/wiki/OSI_model">OSI</a></p><p>用于以二进制格式编码/解码消息的第 6 层表示，以支持低延迟应用程序。在我描述的存在性能问题的许多应用程序中，消息编码/解码通常是最重要的成本。我见过许多应用程序在解析和转换 XML 和 JSON 上花费的 CPU 时间比执行业务逻辑要多得多。SBE 旨在使系统的这一部分尽可能高效。SBE 遵循许多<a href="https://github.com/real-logic/simple-binary-encoding/wiki/Design-Principles">设计原则</a>来实现这一目标。遵守这些设计原则有时意味着不会提供其他编解码器中可用的功能。例如，许多编解码器允许在消息中的任何字段位置对字符串进行编码；SBE 仅允许可变长度字段（例如字符串）作为在消息末尾分组的字段。</p><p>SBE 参考实现由一个编译器组成，该编译器将消息模式作为输入，然后生成特定于语言的存根。存根用于直接对来自缓冲区的消息进行编码和解码。SBE 工具还可以生成模式的二进制表示，可用于动态环境中消息的动态解码，例如日志查看器或网络嗅探器。</p><p>设计原则推动了编解码器的实现，确保消息通过内存流式传输，而无需回溯、复制或不必要的分配。<a href="http://mechanical-sympathy.blogspot.co.uk/2012/08/memory-access-patterns-are-important.html">内存访问模式</a>在高性能应用程序的设计中不应低估。任何语言的低延迟系统尤其需要考虑所有分配，以避免在回收中产生问题。这适用于托管运行时和本机语言。SBE 在所有三种语言实现中都是完全免费的。</p><p>应用这些设计原则的最终结果是编解码器的吞吐量比 Google 协议缓冲区 (GPB) 高约 16-25 倍，并且延迟非常低且可预测。这已在<a href="https://github.com/real-logic/simple-binary-encoding/tree/master/sbe-benchmarks/src/main">微基准测试</a>和实际应用程序使用中观察到。一个典型的市场数据消息可以在大约 25ns 内进行编码或解码，而在相同硬件上使用 GPB 的相同消息大约需要 1000ns。XML 和 FIX 标记值消息再次慢了几个数量级。</p><p>SBE 的最佳选择是作为结构化数据的编解码器，这些数据主要是固定大小的字段，即数字、位集、枚举和数组。虽然它确实适用于字符串和 blob，但我发现一些限制是可用性问题。这些用户最好使用更适合字符串编码的编解码器。</p><p><strong>消息结构</strong></p><p>消息必须能够按顺序读取或写入，以保持流式访问设计原则，即无需回溯。一些编解码器为必须间接访问的可变长度字段（例如字符串类型）插入位置指针。这种间接的代价是额外的指令加上失去硬件预取器的支持。SBE 的设计允许纯顺序访问和无副本本机访问语义。</p><div class="table-container"><table><thead><tr><th><a href="https://2.bp.blogspot.com/-97WBcDq_Gm8/U2dWpbKU3hI/AAAAAAAAARQ/DV0HAr9kAE8/s1600/SBE-msg-format.png"><img src="https://2.bp.blogspot.com/-97WBcDq_Gm8/U2dWpbKU3hI/AAAAAAAAARQ/DV0HAr9kAE8/s1600/SBE-msg-format.png" alt="img"></a></th></tr></thead><tbody><tr><td>图1</td></tr></tbody></table></div><p>SBE 消息有一个公共标头，用于标识要遵循的消息正文的类型和版本。标头后面是消息的根字段，它们都是固定长度和静态偏移的。根字段与 C 中的结构非常相似。如果消息更复杂，则可以跟随一个或多个类似于根块的重复组。重复组可以嵌套其他重复组结构。最后，可变长度的字符串和 blob 出现在消息的末尾。字段也可以是可选的。可以在 <a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-tool/src/main/resources/fpl/SimpleBinary1-0.xsd">此处</a>找到描述 SBE 表示的 XML 模式。</p><p><strong>SbeTool 和编译器</strong></p><p>要使用 SBE，首先需要为您的消息定义一个模式。SBE 提供了一个独立于语言的类型系统，支持整数、浮点数、字符、数组、常量、枚举、位集、复合、重复的分组结构以及可变长度的字符串和 blob。</p><p>可以将消息模式输入<a href="https://github.com/real-logic/simple-binary-encoding/wiki/Sbe-Tool-Guide">SbeTool</a>并进行编译以生成多种语言的存根，或生成适用于即时解码消息的二进制元数据。</p><pre class="line-numbers language-none"><code class="language-none">java [-Doption&#x3D;value] -jar sbe.jar &lt;message-declarations-file.xml&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>SbeTool 和编译器是用 Java 编写的。该工具目前可以在 Java、C++ 和 C# 中输出存根。</p><p><strong>使用存根编程</strong> 可以在 <a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/java/uk/co/real_logic/sbe/examples/ExampleUsingGeneratedStub.java">此处找到在带有支持代码的</a><a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/resources/example-schema.xml">模式</a></p><p>中定义的消息的完整示例 。生成的存根遵循享元模式，重复使用实例以避免分配。存根在偏移处包装缓冲区，然后按顺序和本机读取它。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 先写消息头MESSAGE_HEADER.wrap(directBuffer, bufferOffset, messageTemplateVersion)               .blockLength(CAR.sbeBlockLength())               .templateId(CAR.sbeTemplateId())               .schemaId(CAR.sbeSchemaId())               .version(CAR.sbeSchemaVersion ()); &#x2F;&#x2F; 然后写入消息体car.wrapForEncode(directBuffer, bufferOffset)    .serialNumber(1234)    .modelYear(2013)    .available(BooleanType.TRUE ) .code    (Model.A)    .putVehicleCode(VEHICLE_CODE, srcOffset);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过生成的存根以流畅的方式编写消息。每个字段显示为一对生成的编码和解码方法。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 读取头部并查找合适的模板来解码MESSAGE_HEADER.wrap(directBuffer, bufferOffset, messageTemplateVersion); final int templateId &#x3D; MESSAGE_HEADER.templateId(); final int actuatorBlockLength &#x3D; MESSAGE_HEADER.blockLength(); final int schemaId &#x3D; MESSAGE_HEADER.schemaId(); 最终 int actingVersion &#x3D; MESSAGE_HEADER.version(); &#x2F;&#x2F; 一旦找到模板，就可以对字段进行解码。car.wrapForDecode（directBuffer，bufferOffset，actingBlockLength，actingVersion）；final StringBuilder sb &#x3D; new StringBuilder(); sb.append(&quot;\ncar.templateId&#x3D;&quot;).append(car.sbeTemplateId()); sb.append(&quot;\ncar.schemaId&#x3D;&quot;).append(schemaId);sb.append(&quot;\ncar.schemaVersion&#x3D;&quot;).append(car.sbeSchemaVersion()); sb.append(&quot;\ncar.serialNumber&#x3D;&quot;).append(car.serialNumber()); sb.append(&quot;\ncar.modelYear&#x3D;&quot;).append(car.modelYear()); sb.append(&quot;\ncar.available&#x3D;&quot;).append(car.available()); sb.append(&quot;\ncar.code&#x3D;&quot;).append(car.code());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在所有语言中生成的代码提供的性能类似于在内存上强制转换 C 结构。</p><p><strong>动态解码</strong></p><p>编译器为输入 XML 消息模式生成中间表示 (IR)。此 IR 可以以 SBE 二进制格式序列化，以用于稍后对已存储的消息进行动态解码。它对于不会与存根一起编译的工具（例如网络嗅探器）也很有用。可以在<a href="https://github.com/real-logic/simple-binary-encoding/blob/master/sbe-samples/src/main/java/uk/co/real_logic/sbe/examples/OtfExample.java">此处</a>找到使用的 IR 的完整示例。</p><p><strong>Direct Buffers</strong></p><p>SBE，通过 Agrona，通过 <a href="https://github.com/real-logic/Agrona/blob/master/src/main/java/org/agrona/MutableDirectBuffer.java">MutableDirectBuffer</a>类为 Java 提供抽象，以使用 byte[]、heap 或直接<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer的缓冲区</a> 缓冲区，以及从<a href="http://www.docjar.com/docs/api/sun/misc/Unsafe.html#allocateMemory(long">Unsafe.allocateMemory(long)</a>)或 JNI 返回的堆外内存地址。在低延迟应用程序中，消息通常通过<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/MappedByteBuffer.html">MappedByteBuffer</a>在内存映射文件中进行编码/解码，因此可以由内核<a href="http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html#transferTo(long, long, java.nio.channels.WritableByteChannel">传输</a>)到网络通道，从而避免用户空间复制。</p><p>C++ 和 C# 具有对直接内存访问的内置支持，并且不需要像 Java 版本那样的抽象。为 C# 添加了 DirectBuffer 抽象以支持 Endianess 并封装不安全的指针访问。</p><p><strong>消息扩展和版本控制</strong></p><p>SBE 模式带有允许消息扩展的版本号。可以通过在块末尾添加字段来扩展消息。为了向后兼容，不能删除或重新排序字段。</p><p>扩展字段必须是可选的，否则读取旧消息的较新模板将不起作用。模板携带 min、max、null、timeunit、字符编码等元数据，这些可通过存根上的静态（类级别）方法访问。</p><p><strong>字节排序和对齐</strong></p><p>消息模式允许通过指定偏移量来精确对齐字段。字段默认以 Little <a href="http://www.ietf.org/rfc/ien/ien137.txt">Endian编码</a>除非在模式中另有说明，否则形式。为了获得最佳性能，应使用字对齐边界上的字段的本机编码。在某些处理器上访问非对齐字段的代价可能非常大。对于对齐，必须考虑帧协议和内存中的缓冲区位置。</p><p><strong>消息协议</strong></p><p>我经常看到人们抱怨编解码器无法支持单个消息中的特定演示。然而，这通常可以通过消息协议来解决。协议是将交互拆分为其组成部分的好方法，这些部分通常可以组合用于系统之间的许多交互。例如，模式元数据的 IR 实现比单个消息的结构所能支持的更复杂。我们通过首先发送一个提供概述的模板消息来编码 IR，然后是一个消息流，每个消息都对来自编译器 IR 的标记进行编码。这允许设计一个非常快速的 OTF 解码器，它可以实现为一个线程解释器，其分支比典型的基于开关的状态机少得多。</p><p>协议设计是大多数开发人员似乎没有机会学习的领域。我觉得这是一个很大的损失。如此多的开发人员将诸如 ASCII 之类的“编码”称为“协议”这一事实非常有说服力。当一个人与像 Todd 这样一生都在成功设计协议的程序员一起工作时，协议的价值就显而易见了。</p><p><strong>存根性能</strong></p><p>与动态 OTF 解码相比，存根提供了显着的性能优势。对于访问原始字段，我们相信性能已达到通用工具所能达到的极限。生成的汇编代码与编译器生成的用于访问 C 结构的代码非常相似，即使是从 Java 中也是如此！</p><p>关于存根的一般性能，我们观察到 C++ 与 Java 相比具有非常小的优势，我们认为这是由于运行时插入的安全点检查。C# 版本稍微落后一点，因为它的运行时没有像 Java 运行时那样积极地使用内联方法。所有三种语言的存根都能够在数十纳秒内对典型的金融消息进行编码或解码。相对于应用程序逻辑的其余部分，这有效地使大多数应用程序的消息编码和解码几乎免费。</p><p><strong>反馈</strong></p><p>这是 SBE 的第一个版本，我们欢迎<a href="https://github.com/real-logic/simple-binary-encoding/issues?state=open">反馈</a>. 参考实现受 FIX 社区规范的约束。可能会影响规范，但请不要期望会接受明显违反<a href="https://github.com/FIXTradingCommunity/fix-simple-binary-encoding">规范</a>的拉取请求。已经讨论了对 Javascript、Python、Erlang 和其他语言的支持，非常受欢迎。</p><p><strong>更新：2014 年 5 月 8 日</strong></p><p>感谢 GPB 的创建者 Kenton Varda 的反馈，我们能够改进基准以从 GPB 中获得最佳性能。以下是 Java 基准测试的更改结果。</p><p>与初始结果相比，有关优化的 C++ GPB 示例显示吞吐量大约翻了一番。应该注意的是，与 C++ 相比，在 Java 中使用 GPB 时，您通常必须做相反的事情才能获得性能改进，例如分配对象而不是重用它们。</p><p><strong>GPB优化前：</strong></p><pre class="line-numbers language-none"><code class="language-none">Mode Thr Cnt Sec Mean Mean error Units      [exec] ucrprotobuf.CarBenchmark.testDecode thrpt 1 30 1 462.817 6.474 ops&#x2F;ms      [exec] ucrprotobuf.CarBenchmark.testEncode thrpt 1 30 1 326.018 2.972 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testDecode thrpt 1 30 1 1148.050 17.194 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testEncode thrpt 1 30 1 1242.252 12.248 ops&#x2F;ms      [exec] ucrsbe.CarBenchmark.testDecode thrpt 1 30 1 10436.476 102ucrsbe.ms      [exec] testEncode thrpt 1 30 1 11657.190 65.168 操作&#x2F;毫秒     [exec] ucrsbe.MarketDataBenchmark.testDecode thrpt 1 30 1 34078.646 261.775 ops&#x2F;ms      [exec] ucrsbe.MarketDataBenchmark.testEncode thrpt 1 30 1 29193.600 443.638 ops&#x2F;ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>GPB优化后：</strong></p><pre class="line-numbers language-none"><code class="language-none">Mode Thr Cnt Sec Mean Mean error Units      [exec] ucrprotobuf.CarBenchmark.testDecode thrpt 1 30 1 619.467 4.429 ops&#x2F;ms      [exec] ucrprotobuf.CarBenchmark.testEncode thrpt 1 30 1 433.711 10.364 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.test thrpt 1 30 1 2088.998 60.619 ops&#x2F;ms      [exec] ucrprotobuf.MarketDataBenchmark.testEncode thrpt 1 30 1 1316.123 19.816 ops&#x2F;ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>吞吐量 msg/ms - 在 GPB 优化之前</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>测试</td><td>协议缓冲区</td><td>SBE</td><td>比率</td></tr><tr><td>汽车编码</td><td>462.817</td><td>10436.476</td><td>22.52</td></tr><tr><td>汽车解码</td><td>326.018</td><td>11657.190</td><td>35.76</td></tr><tr><td>市场数据编码</td><td>1148.050</td><td>34078.646</td><td>29.68</td></tr><tr><td>市场数据解码</td><td>1242.252</td><td>29193.600</td><td>23.50</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>吞吐量 msg/ms - GPB 优化后</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>测试</td><td>协议缓冲区</td><td>SBE</td><td>比率</td></tr><tr><td>汽车编码</td><td>619.467</td><td>10436.476</td><td>16.85</td></tr><tr><td>汽车解码</td><td>433.711</td><td>11657.190</td><td>26.88</td></tr><tr><td>市场数据编码</td><td>2088.998</td><td>34078.646</td><td>16.31</td></tr><tr><td>市场数据解码</td><td>1316.123</td><td>29193.600</td><td>22.18</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://mechanical-sympathy.blogspot.com/2014/05/simple-binary-encoding.html&quot;&gt;https://mechanical-sympathy.blog</summary>
      
    
    
    
    <category term="二进制编码" scheme="https://knowledge-things.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>git如何移除某文件夹的版本控制</title>
    <link href="https://knowledge-things.github.io/2022/09/15/git-ru-he-yi-chu-mou-wen-jian-jia-de-ban-ben-kong-zhi/"/>
    <id>https://knowledge-things.github.io/2022/09/15/git-ru-he-yi-chu-mou-wen-jian-jia-de-ban-ben-kong-zhi/</id>
    <published>2022-09-15T06:37:18.000Z</published>
    <updated>2022-09-15T06:58:33.279Z</updated>
    
    <content type="html"><![CDATA[<p>#目录结构如下</p><pre class="line-numbers language-none"><code class="language-none">project    bin    lib    src    ...... <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#执行如下的操作</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m &quot;add bin&#x2F; lib&#x2F; src&#x2F;&quot;git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>突然发现原来 <code>lib</code> 目录不需要提交到版本库，但是现在远程已经存在该目录，what should I do.（吐出去的东西还能收回来吗）</p><p>万能的 git 啊，help me！</p><p>功夫不负有心人，找到了解决问题的方法，其实就是 <code>git rm</code> 的命令行参数。</p><h2 id="git-rm-命令参数"><a href="#git-rm-命令参数" class="headerlink" title="git rm 命令参数"></a><code>git rm</code> 命令参数</h2><pre class="line-numbers language-none"><code class="language-none">-n --dry-run Don’t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.-r Allow recursive removal when a leading directory name is given. --cached Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#解决方法</p><pre class="line-numbers language-none"><code class="language-none">git rm -r -n --cached &quot;bin&#x2F;&quot; &#x2F;&#x2F;-n：加上这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。git rm -r --cached  &quot;bin&#x2F;&quot;      &#x2F;&#x2F;最终执行命令. git commit -m&quot; remove bin folder all file out of control&quot;    &#x2F;&#x2F;提交git push origin master   &#x2F;&#x2F;提交到远程服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时 <code>git status</code> 看到 bin / 目录状态变为<code>untracked</code> 可以修改<code>.gitignore</code> 文件 添加 <code>bin/</code> 并提交<code>.gitignore</code> 文件到远程服务器，这样就可以不对 bin 目录进行版本管理了。 以后需要的时候，只需要注释<code>.gitignore</code> 里<code>#bin/</code> 内容，重新执行 <code>git bin/</code>, 即可重新纳入版本管理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#目录结构如下&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;project
    bin
    lib
    src
    ...... &lt;span aria-hid</summary>
      
    
    
    
    <category term="git" scheme="https://knowledge-things.github.io/categories/git/"/>
    
    
    <category term="git" scheme="https://knowledge-things.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Docker Restart policies</title>
    <link href="https://knowledge-things.github.io/2022/08/29/docker-restart-policies/"/>
    <id>https://knowledge-things.github.io/2022/08/29/docker-restart-policies/</id>
    <published>2022-08-29T03:04:15.000Z</published>
    <updated>2022-08-29T03:09:46.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker重启策略"><a href="#Docker重启策略" class="headerlink" title="Docker重启策略"></a>Docker重启策略</h2><blockquote><p>参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.docker.com%2Fengine%2Freference%2Frun%2F%23restart-policies---restart">https://docs.docker.com/engine/reference/run/#restart-policies—-restart</a></p></blockquote><p>使用<code>--restart</code>Docker run 上的标志，您可以指定容器在退出时应该或不应该如何重新启动的重新启动策略。当容器上的重启策略处于活动状态时，它将显示为<code>Up</code> 或<code>Restarting</code>。</p><p>Docker 支持以下重启策略：</p><div class="table-container"><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>no</td><td>不自动重启（默认模式）</td></tr><tr><td>on-failure[:max-retries]</td><td>重启因出错停止的容器（非0退出码）。可以通过指定max-retries来限定docker daemon的最大尝试重启次数</td></tr><tr><td>always</td><td>docker daemon会无限尝试重启退出的容器（无论以什么退出码退出）。手动停止容器后，容器策略不再生效。除非重启docker daemon</td></tr><tr><td>unless-stopped</td><td>与<code>always</code>类似，区别在于手动停止容器后，就算重启docker daemon，容器策略也不再生效。</td></tr></tbody></table></div><p>在每次重新启动之前添加一个增加的延迟（是先前延迟的两倍，从 100 毫秒开始），以防止服务器泛滥。这意味着守护进程将等待 100 毫秒，然后等待 200 毫秒、400、800、1600 等等，直到达到<code>on-failure</code>限制、最大延迟 1 分钟，或者当您<code>docker stop</code>或<code>docker rm -f</code>容器时。</p><p>如果容器重新启动成功（<strong>容器启动并运行至少 10 秒</strong>），则延迟将重置为其默认值 100 毫秒。</p><p><strong>您可以指定 Docker 在使用on-failure</strong>策略时尝试重新启动容器的最大次数。默认情况下，Docker 将永远尝试重新启动容器。容器的（尝试）重启次数可以通过<a href="https://docs.docker.com/engine/reference/commandline/inspect/"><code>docker inspect</code></a>. 例如，获取容器“my-container”的重启次数；</p><pre class="line-numbers language-none"><code class="language-none">$ docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; my-container# 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者，获取容器上次（重新）启动的时间；</p><pre class="line-numbers language-none"><code class="language-none">$ docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; my-container# 2015-03-04T23:47:07.691840179Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将<code>--restart</code>(restart policy) 与<code>--rm</code>(clean up) 标志结合使用会导致错误。在容器重新启动时，附加的客户端会断开连接。请参阅本页后面有关使用<a href="https://docs.docker.com/engine/reference/run/#clean-up---rm"><code>--rm</code>(clean up)</a>标志的示例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker重启策略&quot;&gt;&lt;a href=&quot;#Docker重启策略&quot; class=&quot;headerlink&quot; title=&quot;Docker重启策略&quot;&gt;&lt;/a&gt;Docker重启策略&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://links</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://knowledge-things.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Binary Repository</title>
    <link href="https://knowledge-things.github.io/2022/08/24/binary-repository/"/>
    <id>https://knowledge-things.github.io/2022/08/24/binary-repository/</id>
    <published>2022-08-24T02:56:07.000Z</published>
    <updated>2022-08-24T03:01:32.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接 <a href="https://dzone.com/articles/easy-way-to-get-your-own-binary-repository">https://dzone.com/articles/easy-way-to-get-your-own-binary-repository</a></p></blockquote><p>根据<a href="https://en.wikipedia.org/wiki/Software_repository">维基百科</a>，<a href="https://dzone.com/articles/use-a-binary-repository-manager-and-keep-up-with-d">二进制存储库管理器 (BRM)</a>是“一种软件工具，旨在优化软件开发中使用和生成的二进制文件的下载和存储”，例如 .jar、.tar 或 .zip 档案。作为大多数<a href="https://en.wikipedia.org/wiki/DevOps_toolchain">DevOps 工具链</a>的关键组件，BRM 位于构建管道之后。这就是为什么它有时被称为“构建存储库”、“工件存储库”或“管道状态存储库”的原因。</p><p>传统的<a href="https://dzone.com/articles/devops-pipeline-end-to-end-with-pcf">DevOps 管道</a>需要自动验证、测试、打包和版本化到工件（二进制文件）中的源代码。然后，工件必须存储在源代码存储库之外，并可供持续交付管道的后续阶段使用。作为管理二进制文件和依赖项的中心点，以及用于构建内部开发软件促销的集成库，BRM 应该托管这些工件。</p><p><img src="https://dz2cdn1.dzone.com/storage/temp/16097179-1pipeline.jpg" alt="img"></p><p>几乎任何规模的软件项目都需要将其二进制工件保存在存储库中，以便程序员或确保<a href="https://dzone.com/articles/learn-how-to-setup-a-cicd-pipeline-from-scratch">持续集成 (CI)、交付 (CD) 和部署 (CD)</a>的工具能够访问它们。由于管理存储库的软件质量很重要，因此 BRM 应满足以下要求：</p><ul><li>可集成性——每种编程语言都有大量的构建自动化工具，例如用于 Java 的 Maven、用于 JavaScript 的 Npm 或用于 Ruby 的 Rake。还有很多持续集成工具，比如 Jenkins 或 Travis。由于自动化是 DevOps 最重要的方面，因此预计每个或大部分都有插件，从而能够与 BRM 无缝集成。</li><li>可用性——工件是软件开发过程的重要组成部分，它们必须在需要时立即可供程序员或构建工具使用，甚至没有微小的延迟，并以尽可能快的速度交付。</li><li>可扩展性——大多数构建工件都是大型二进制文件；其中一些可能大于 1Gb，例如 Docker 映像或 .war（生产就绪的 Java 档案）。BRM 必须能够维护大型数据集，几乎没有大小限制。</li><li>可靠性——必须尽可能排除因软件或硬件故障而损坏数据的能力。</li></ul><h3 id="Artipie"><a href="#Artipie" class="headerlink" title="Artipie"></a>Artipie</h3><p><a href="https://github.com/artipie">Artipie </a>是一个免费的二进制工件管理工具。Artipie 不仅仅是一个二进制工件 Web 服务器——它是一个工件管理构造函数，它包含许多内置在服务器组件中的组件。这是一个开源项目，始于 2020 年，并且正在积极发展。</p><h3 id="Artipie-HTTP-引擎"><a href="#Artipie-HTTP-引擎" class="headerlink" title="Artipie HTTP 引擎"></a><strong>Artipie HTTP 引擎</strong></h3><p>Artipie 引擎是一个 Java 应用程序，它公开了一个用于存储库访问和管理操作的 HTTP 端点。它将 HTTP 请求路由到存储库适配器并提供身份验证机制。Artipie HTTP 引擎基于<a href="https://dzone.com/articles/introduce-to-eclicpse-vertx">Vert.x</a>和<a href="https://dzone.com/articles/go-reactive-with-rx-java">RxJava</a>框架构建，通过异步、反应式和非阻塞操作为项目提供轻量级的灵活性和可扩展性。</p><p>Artipie 上传操作最常见的数据流如下：客户端正在向服务器发送一些二进制工件，服务器会找到负责的存储库适配器来处理请求；存储库适配器将流保存到存储；完成后，它会更新存储库的元数据（某些存储库的工作方式不同，例如，Docker 使用元数据作为路径）。</p><p><img src="https://dz2cdn1.dzone.com/storage/temp/16097192-3uploadaction.jpg" alt="img"></p><p>图 3. 使用 S3 实现存储的 Artipie Maven 存储库的上传操作</p><h3 id="存储库适配器"><a href="#存储库适配器" class="headerlink" title="存储库适配器"></a><strong>存储库适配器</strong></h3><p>存储库适配器是独立项目，旨在实现 API 以与特定包类型（npm、maven 等）的存储库客户端和元信息生成层进行交互。Artipie 引擎使用适配器来提供 BRM 功能。每个存储库适配器都封装存储 API 以访问二进制 blob 和元数据文件。</p><p>Artipie 支持以下类型的存储库：</p><ul><li>Docker - 用于镜像的私有 Docker 注册表。</li><li>Maven - Java、Kotlin、Groovy、Scala、Clojure 工件和各种类型的依赖项，如 .jar、.war、.klib 等。</li><li>NPM - JavaScript 代码共享和包存储。</li><li>PyPI - Python 包索引。</li><li>Anaconda - 为 Python、R、Lua、C、C++ 等构建数据科学包。</li><li>RPM - 用于 RHEL、PCLinuxOS、Fedora、AlmaLinux、CentOS、openSUSE、OpenMandriva、Oracle Linux 等的 .rpm 软件包存储库。</li><li>Gem - Ruby 的 RubyGem 托管服务.</li><li>Go - Go 包裹存储。</li><li>文件（二进制）存储 - 托管您喜欢的任何文件。</li><li>Helm - Helm 图表存储库。</li><li>NuGet - .NET 包的托管服务。</li><li>Debian - 基于 Debian 的 Linux 发行版的软件包存储库：Ubuntu、MX Linux、Mint、Raspberry Pi OS、Parrot OS 等。</li><li>Composer - PHP 包的包源。</li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>存储库适配器将上传和创建的二进制文件放置在存储中。Artipie 具有抽象存储，它提供了对物理数据存储系统的抽象。简单性使得为几乎任何数据存储系统实现接口变得容易。它有两个主要操作：从存储中放入和获取项目以及一些附加功能，例如检查项目是否存在、列出存储项目或获取项目元数据。</p><p>目前，有以下存储实现：</p><ol><li>文件系统存储</li><li>Redis 存储</li><li>基于 S3 的存储</li></ol><p>抽象存储还提供了一个接口，可以实现该接口以支持您需要的任何类型的存储。</p><h2 id="开始使用-Artipie"><a href="#开始使用-Artipie" class="headerlink" title="开始使用 Artipie"></a><strong>开始使用 Artipie</strong></h2><p>使用 Artipie 有两种选择： </p><ul><li><a href="https://github.com/artipie/artipie#quickstart">使用 Docker Compose 运行 Artipie Docker 映像</a></li><li><a href="https://github.com/artipie/artipie/wiki">在 JVM 上运行 Artipie jar 存档</a></li></ul><h3 id="准备中"><a href="#准备中" class="headerlink" title="准备中"></a>准备中</h3><p>要运行 Artipie，您需要<a href="https://docker.com/get-started">安装 Docker</a>，然后您可以简单地克隆此存储库，并在路径上使用示例<code>C:\</code>，或按照以下步骤操作：</p><ol><li>为 Artipie 项目创建一个文件夹（例如<code>C:\artipie</code>）</li><li>为 Artipie 配置创建一个文件夹（例如<code>C:\artipie\config</code>），并将包含 Artipie 服务器配置的 yml 文件放在该文件夹中。在我的示例中，该文件称为<code>artipie.yml</code>. 您必须指定 Artipie 将找到所有存储库配置的路径。我将 Docker 存储库的配置路径指定为，因为在第 4 步中进行设置时<code>var/artipie/repo</code>，我将文件夹从本地 Windows 机器安装<code>C:\artipie\repo</code>到 Artipie Docker 容器中的目录。<code>/var/artipie/repo``docker-compose.yml</code></li></ol><pre class="line-numbers language-none"><code class="language-none">meta:  storage:    type: fs    path: &#x2F;var&#x2F;artipie&#x2F;repo #path to repository configurations  layout: flat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>为存储库配置文件（例如<code>C:\artipie\repo</code>）创建一个文件夹，然后将包含存储库配置的 yml 文件放入该文件夹。此文件的名称将是要创建的存储库的名称。例如，文件将被命名<code>my-docker.yml</code>，存储库将相应地命名为<strong>my-docker</strong>。要配置具有 FileStorage 类型的存储，设置 Artipie 将存储所有项目的路径就足够了。系统必须具有读写权限才能在此路径上创建文件。在我的示例中，路径将是<code>/var/artipie/images</code>.</li></ol><pre class="line-numbers language-none"><code class="language-none">repo:  type: docker  storage:    type: fs   #type &#x3D; FileStorage    path: &#x2F;var&#x2F;artipie&#x2F;images   #place where the data will be stored<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>使用以下说明创建文件<code>docker-compose.yml</code>：</li></ol><pre class="line-numbers language-none"><code class="language-none">version: &quot;3.3&quot;services:  artipie:    image: artipie&#x2F;artipie:latest    container_name: artipie    restart: unless-stopped    ports:      - &quot;8080:8080&quot;    volumes:      - &#x2F;C&#x2F;artipie&#x2F;repo:&#x2F;var&#x2F;artipie&#x2F;repo # mount folder with repository configuration      - &#x2F;C&#x2F;artipie&#x2F;config:&#x2F;etc&#x2F;artipie&#x2F; # mount folder with Artipie server configuration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接 &lt;a href=&quot;https://dzone.com/articles/easy-way-to-get-your-own-binary-repository&quot;&gt;https://dzone.com/articles/easy-way-to-</summary>
      
    
    
    
    <category term="binary-repo" scheme="https://knowledge-things.github.io/categories/binary-repo/"/>
    
    <category term="DevOps" scheme="https://knowledge-things.github.io/categories/binary-repo/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://knowledge-things.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Micrometer自定义业务监控指标</title>
    <link href="https://knowledge-things.github.io/2022/08/18/micrometer-zi-ding-yi-ye-wu-jian-kong-zhi-biao/"/>
    <id>https://knowledge-things.github.io/2022/08/18/micrometer-zi-ding-yi-ye-wu-jian-kong-zhi-biao/</id>
    <published>2022-08-18T05:30:46.000Z</published>
    <updated>2022-08-18T05:42:42.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[原文链接] <a href="https://github.com/TFdream/blog/issues/340">https://github.com/TFdream/blog/issues/340</a></p><h1 id="SpringBoot-2-0-Micrometer-自定义业务指标监控"><a href="#SpringBoot-2-0-Micrometer-自定义业务指标监控" class="headerlink" title="SpringBoot 2.0 Micrometer 自定义业务指标监控"></a>SpringBoot 2.0 Micrometer 自定义业务指标监控</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2></blockquote><p>Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，它提供了多种度量指标类型（Timers、Guauges、Counters等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus 等。我们可以通过 Micrometer 收集 Java 性能数据，配合 Prometheus 监控系统实时获取数据，并最终在 Grafana 上展示出来，从而很容易实现应用的监控。</p><h3 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h3><p>Micrometer 中有两个最核心的概念，分别是计量器（Meter）和计量器注册表（MeterRegistry）。计量器用来收集不同类型的性能指标信息，Micrometer 提供了如下几种不同类型的计量器：</p><ul><li>计数器（Counter）: 表示收集的数据是按照某个趋势（增加／减少）一直变化的，也是最常用的一种计量器，例如接口请求总数、请求错误总数、队列数量变化等。</li><li>计量仪（Gauge）: 表示搜集的瞬时的数据，可以任意变化的，例如常用的 CPU Load、Mem 使用量、Network 使用量、实时在线人数统计等，</li><li>计时器（Timer）: 用来记录事件的持续时间，这个用的比较少。</li><li>分布概要（Distribution summary）: 用来记录事件的分布情况，表示一段时间范围内对数据进行采样，可以用于统计网络请求平均延迟、请求延迟占比等。</li></ul><h3 id="1-2-MeterRegistry"><a href="#1-2-MeterRegistry" class="headerlink" title="1.2 MeterRegistry"></a>1.2 MeterRegistry</h3><p>Meter是收集关于你的应用的一系列指标的接口。Meter是由MeterRegistry创建的。每个支持的监控系统都必须实现MeterRegistry。Micrometer中包含一个SimpleMeterRegistry，它在内存中维护每个meter的最新值，并且不支持将数据导出到任何地方，主要用来进行本地开发和测试。<br>Micrometer 支持多个不同的监控系统。通过计量器注册表实现类 CompositeMeterRegistry 可以把多个计量器注册表组合起来，从而允许同时发布数据到多个监控系统。对于由这个类创建的计量器，它们所产生的数据会对 CompositeMeterRegistry中包含的所有计量器注册表都产生影响。</p><h3 id="1-3-Actuator"><a href="#1-3-Actuator" class="headerlink" title="1.3 Actuator"></a>1.3 Actuator</h3><p>你可以通过文末的参考文章获取它的详细概念和具体使用方法。这里只是简述下他的概念和使用方式，本文重点在micrometer。</p><p>Spring Boot Actuator是Spring Boot的一个组件，可以帮助你监控和管理Spring Boot应用，比如健康检查、审计、统计和HTTP追踪等。所有的这些特性可以通过JMX或者HTTP endpoints来获得。<br>你可以访问 <a href="http://ip:端口/actuator">http://ip:端口/actuator</a> 查看系统中暴露的endpoint信息，也可以加上具体的 endpoint 查看他们的详细情况，例如 <a href="http://127.0.0.1:7001/actuator/health">http://127.0.0.1:7001/actuator/health</a> 查看健康信息。Spring Boot 2中的依赖actuator中集成的度量统计API使用的框架是Micrometer。官网</p><p>本文重点介绍/actuator/metrics，其他的就属于抛砖了。</p><h3 id="1-4-metrics"><a href="#1-4-metrics" class="headerlink" title="1.4 metrics"></a>1.4 metrics</h3><p>打开 ip:端口/actuator/metrics 网址就可以看到当前微服务的所有metrics，每一个metric都相当于influx数据库的一个measurement，也就是传统数据库的数据表的概念。</p><h2 id="2、自定义metrics"><a href="#2、自定义metrics" class="headerlink" title="2、自定义metrics"></a>2、自定义metrics</h2><p>本篇以监控线程池中的待执行任务数量监控为例</p><p>首先，添加以下依赖：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 微服务运行监控  --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;micrometer-core&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;micrometer.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- 统计信息输出到 prometheus --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;micrometer-registry-prometheus&lt;&#x2F;artifactId&gt;    &lt;version&gt;$&#123;micrometer.version&#125;&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-两种常用指标类型-Metric-Type"><a href="#2-两种常用指标类型-Metric-Type" class="headerlink" title="2. 两种常用指标类型(Metric Type)"></a>2. 两种常用指标类型(Metric Type)</h3><p>gauge: 可增可减计数器，反应某值当前一刻状态。比如称重传感器的当前重量，温度传感器的当前温度。<br>方式一:</p><pre class="line-numbers language-none"><code class="language-none">Gauge.builder(&quot;lego.thread-pool.pending_task&quot;, new AtomicInteger(37), AtomicInteger::get)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><pre class="line-numbers language-none"><code class="language-none">registry.gauge(&quot;lego.thread-pool.pending_task&quot;, Tags.of(&quot;site&quot;, &quot;SiteA&quot;, &quot;cab&quot;, &quot;cab01&quot;), new AtomicInteger(37));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>两者等价</p><h3 id="3-接入到系统的方式"><a href="#3-接入到系统的方式" class="headerlink" title="3. 接入到系统的方式"></a>3. 接入到系统的方式</h3><p>方式一，业务系统埋点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class SampleBean &#123;    private final Counter counter;    public SampleBean(MeterRegistry registry) &#123;        this.counter &#x3D; registry.counter(&quot;request.counter&quot;);    &#125;    public void handleMessage(String message) &#123;        this.counter.increment();        &#x2F;&#x2F; handle message implementation    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方式二：MeterBinder</p><p>SpringBoot中提供了MeterBinder接口用于申明与注册meterRegistry。自定义Metrics只需要实现MeterBinder接口，Spring会自动发现并完成后续的杂活。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * @author Ricky Fung *&#x2F;public class DynamicThreadPoolExecutorMetrics implements MeterBinder &#123;    private final Logger LOG &#x3D; LoggerFactory.getLogger(this.getClass());    @Autowired(required &#x3D; false)    private List&lt;DynamicThreadPoolExecutor&gt; executors &#x3D; Collections.EMPTY_LIST;    @Override    public void bindTo(MeterRegistry meterRegistry) &#123;        String localIp &#x3D; IpUtils.getLocalIp();        LOG.info(&quot;动态线程池-监控自动装配开始, localIp:&#123;&#125;, meterRegistry:&#123;&#125;&quot;, localIp, meterRegistry.getClass());        for (DynamicThreadPoolExecutor executor : executors) &#123;            String name &#x3D; executor.getName();            AtomicInteger pendingTask &#x3D; new AtomicInteger(0);            Gauge.builder(&quot;lego.thread-pool.pending_task&quot;, pendingTask, AtomicInteger::get)                    .tag(&quot;name&quot;, name)                    .tag(&quot;IP&quot;, localIp)                    .description(&quot;动态线程池待执行任务数&quot;)                    .register(meterRegistry);            Counter totalTask &#x3D; Counter.builder(&quot;lego.thread-pool.total_task&quot;)                    .tag(&quot;name&quot;, name)                    .tag(&quot;IP&quot;, localIp)                    .description(&quot;动态线程池累计提交任务数&quot;)                    .register(meterRegistry);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://dzone.com/articles/using-micrometer-with-spring-boot-2">Dzone - Using Micrometer With Spring Boot 2</a></li><li><a href="https://blog.autsoft.hu/defining-custom-metrics-in-a-spring-boot-application-using-micrometer/">Defining custom metrics in a Spring Boot application using Micrometer</a></li><li>[Monitoring Spring Boot Application With Micrometer, Prometheus And Grafana Using Custom Metrics](</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[原文链接] &lt;a href=&quot;https://github.com/TFdream/blog/issues/340&quot;&gt;https://github.com/TFdream/blog/issues/340&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Sprin</summary>
      
    
    
    
    <category term="spring" scheme="https://knowledge-things.github.io/categories/spring/"/>
    
    <category term="micrometer" scheme="https://knowledge-things.github.io/categories/spring/micrometer/"/>
    
    
    <category term="系统监控" scheme="https://knowledge-things.github.io/tags/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Telegraf安装部署</title>
    <link href="https://knowledge-things.github.io/2022/06/30/telegraf-an-zhuang-bu-shu/"/>
    <id>https://knowledge-things.github.io/2022/06/30/telegraf-an-zhuang-bu-shu/</id>
    <published>2022-06-30T08:31:00.000Z</published>
    <updated>2022-06-30T08:42:33.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu-和-Debian"><a href="#Ubuntu-和-Debian" class="headerlink" title="Ubuntu 和 Debian"></a><a href="https://docs.influxdata.com/telegraf/v1.23/install/#ubuntu--debian">Ubuntu 和 Debian</a></h3><p>使用以下命令从 InfluxData 存储库安装 Telegraf：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># influxdb.key GPG Fingerprint: 05CE15085FC09D18E99EFB22684A14CF2582E0C5wget -q https:&#x2F;&#x2F;repos.influxdata.com&#x2F;influxdb.keyecho &#39;23a1c8836f0afc5ed24e0486339d7cc8f6790b83886c4c96995b88a061c5bb5d influxdb.key&#39; | sha256sum -c &amp;&amp; cat influxdb.key | gpg --dearmor | sudo tee &#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;influxdb.gpg &gt; &#x2F;dev&#x2F;nullecho &#39;deb [signed-by&#x3D;&#x2F;etc&#x2F;apt&#x2F;trusted.gpg.d&#x2F;influxdb.gpg] https:&#x2F;&#x2F;repos.influxdata.com&#x2F;debian stable main&#39; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;influxdata.listsudo apt-get update &amp;&amp; sudo apt-get install telegraf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>从<code>.deb</code>文件</strong>安装：</p><p>从<code>.deb</code>文件手动安装 Debian 软件包：</p><ol><li><p><a href="https://influxdata.com/downloads/">从下载页面</a><code>.deb</code>的 Telegraf 部分下载最新的 Telegraf版本。</p></li><li><p>运行以下命令（确保为下载的文件提供正确的版本号）：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo dpkg -i telegraf_1.23.0-1_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="配置Telegraf"><a href="#配置Telegraf" class="headerlink" title="配置Telegraf"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#configure-telegraf">配置Telegraf</a></h2><p>定义 Telegraf 将在配置文件中使用哪些插件。每个配置文件都需要至少一个启用的<a href="https://docs.influxdata.com/telegraf/v1.23/plugins/inputs/">输入插件</a>（指标来自哪里）和至少一个启用的<a href="https://docs.influxdata.com/telegraf/v1.23/plugins/outputs/">输出插件</a>（指标去哪里）。</p><p>以下示例生成包含所有可用插件的示例配置文件，然后使用<code>filter</code>标志启用特定插件。</p><p>有关<code>filter</code>其他标志的详细信息，请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/commands/">Telegraf 命令和标志</a>。</p><ol><li><p>运行以下命令创建配置文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --sample-config &gt; telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>找到配置文件。位置因您的系统而异：</p><ul><li>macOS<a href="http://brew.sh/">自制软件</a>：<code>/usr/local/etc/telegraf.conf</code></li><li>Linux debian 和 RPM 软件包：<code>/etc/telegraf/telegraf.conf</code></li><li>独立二进制文件：请参阅下一节了解如何创建配置文件</li></ul><blockquote><p><strong>注意：</strong>您还可以指定一个远程 URL 端点以从中提取配置文件。请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/configuration/#configuration-file-locations">配置文件位置</a>。</p></blockquote></li><li><p><code>vim</code>使用或 文本编辑器编辑配置文件。因为此示例使用<a href="https://github.com/influxdata/telegraf/blob/release-1.21/plugins/outputs/influxdb_v2/README.md">InfluxDB V2 输出插件</a>，我们需要将 InfluxDB URL、身份验证令牌、组织和存储桶详细信息添加到配置文件的这一部分。</p></li></ol><blockquote><p><strong>注意：</strong>有关更多配置文件选项，请参阅<a href="https://docs.influxdata.com/telegraf/v1.23/configuration/">配置选项</a>。</p></blockquote><ol><li>对于此示例，使用标志指定两个输入 (<code>cpu</code>和<code>mem</code>) 。<code>--input-filter</code>将 InfluxDB 指定为带有<code>--output-filter</code>标志的输出。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --sample-config --input-filter cpu:mem --output-filter influxdb_v2 &gt; telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的配置将收集 CPU 和内存数据并将其发送到 InfluxDB V2。</p><h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#set-environment-variables">设置环境变量</a></h2><p>在配置文件的任何位置添加环境变量，方法是在它们前面加上<code>$</code>. 对于字符串，变量必须用引号引起来（例如，<code>&quot;$STR_VAR&quot;</code>）。对于数字和布尔值，变量必须不加引号（例如<code>$INT_VAR</code>，, <code>$BOOL_VAR</code>）。</p><p>您还可以使用 Linux<code>export</code>命令设置环境变量：<code>export password=mypassword</code></p><blockquote><p><strong>注意：</strong>我们建议对敏感信息使用环境变量。</p></blockquote><h3 id="示例：Telegraf-环境变量"><a href="#示例：Telegraf-环境变量" class="headerlink" title="示例：Telegraf 环境变量"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#example-telegraf-environment-variables">示例：Telegraf 环境变量</a></h3><p>在 Telegraf 环境变量文件 ( <code>/etc/default/telegraf</code>) 中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">USER&#x3D;&quot;alice&quot;INFLUX_URL&#x3D;&quot;https:&#x2F;&#x2F;us-west-2-1.aws.cloud2.influxdata.com&quot;INFLUX_SKIP_DATABASE_CREATION&#x3D;&quot;true&quot;INFLUX_PASSWORD&#x3D;&quot;monkey123&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#">InfluxDB 云还是 OSS？</a></p><p>在 Telegraf 配置文件 ( <code>/etc/telegraf.conf</code>) 中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[global_tags]  user &#x3D; &quot;$&#123;USER&#125;&quot;[[inputs.mem]][[outputs.influxdb]]  urls &#x3D; [&quot;$&#123;INFLUX_URL&#125;&quot;]  skip_database_creation &#x3D; $&#123;INFLUX_SKIP_DATABASE_CREATION&#125;  password &#x3D; &quot;$&#123;INFLUX_PASSWORD&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的环境变量将以下配置设置添加到 Telegraf：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[global_tags]  user &#x3D; &quot;alice&quot;[[outputs.influxdb]]  urls &#x3D; &quot;https:&#x2F;&#x2F;us-west-2-1.aws.cloud2.influxdata.com&quot;  skip_database_creation &#x3D; true  password &#x3D; &quot;monkey123&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#">InfluxDB 云还是 OSS？</a></p><h2 id="启动电报"><a href="#启动电报" class="headerlink" title="启动电报"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#start-telegraf">启动电报</a></h2><p>接下来，您需要启动 Telegraf 服务并将其定向到您的配置文件：</p><h3 id="macOS自制软件"><a href="#macOS自制软件" class="headerlink" title="macOS自制软件"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#macos-homebrewhttpbrewsh">macOS</a><a href="http://brew.sh/">自制软件</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">telegraf --config telegraf.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux（sysvinit-和-upstart-安装）"><a href="#Linux（sysvinit-和-upstart-安装）" class="headerlink" title="Linux（sysvinit 和 upstart 安装）"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#linux-sysvinit-and-upstart-installations">Linux（sysvinit 和 upstart 安装）</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo service telegraf start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Linux（系统安装）"><a href="#Linux（系统安装）" class="headerlink" title="Linux（系统安装）"></a><a href="https://docs.influxdata.com/telegraf/v1.23/get_started/#linux-systemd-installations">Linux（系统安装）</a></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start telegraf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Ubuntu-和-Debian&quot;&gt;&lt;a href=&quot;#Ubuntu-和-Debian&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 和 Debian&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.influxdata.com/tele</summary>
      
    
    
    
    <category term="系统监控" scheme="https://knowledge-things.github.io/categories/%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
    
    
    <category term="Telegraf" scheme="https://knowledge-things.github.io/tags/Telegraf/"/>
    
  </entry>
  
  <entry>
    <title>Java 基本数据类型</title>
    <link href="https://knowledge-things.github.io/2022/06/21/java-ji-ben-shu-ju-lei-xing/"/>
    <id>https://knowledge-things.github.io/2022/06/21/java-ji-ben-shu-ju-lei-xing/</id>
    <published>2022-06-21T04:00:00.000Z</published>
    <updated>2022-06-21T04:03:45.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p><p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/2020-10-27-code-mem.png" alt="img"></p><p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p><p>Java 的两大数据类型:</p><ul><li>内置数据类型</li><li>引用数据类型</li></ul><hr><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 <strong>-128（-2^7）</strong>；</li><li>最大值是 <strong>127（2^7-1）</strong>；</li><li>默认值是 <strong>0</strong>；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a = 100，byte b = -50。</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 <strong>-32768（-2^15）</strong>；</li><li>最大值是 <strong>32767（2^15 - 1）</strong>；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 <strong>0</strong>；</li><li>例子：short s = 1000，short r = -20000。</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li><li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 <strong>0</strong> ；</li><li>例子：int a = 100000, int b = -200000。</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li><li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 <strong>0L</strong>；</li><li>例子： <strong>long a = 100000L</strong>，<strong>long b = -200000L</strong>。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 <strong>0.0f</strong>；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f。</li></ul><p><strong>double：</strong></p><ul><li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p></li><li><p>浮点数的默认类型为 double 类型；</p></li><li><p>double类型同样不能表示精确的值，如货币；</p></li><li><p>默认值是 <strong>0.0d</strong>；</p></li><li><p>例子：</p><pre class="line-numbers language-none"><code class="language-none">double   d1  &#x3D; 7D ;double   d2  &#x3D; 7.; double   d3  &#x3D;  8.0; double   d4  &#x3D;  8.D; double   d5  &#x3D;  12.9867; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p></li></ul><p><strong>boolean：</strong></p><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 <strong>false</strong>；</li><li>例子：boolean one = true。</li></ul><p><strong>char：</strong></p><ul><li>char 类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 <strong>\u0000</strong>（十进制等效值为 0）；</li><li>最大值是 <strong>\uffff</strong>（即为 65535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter = ‘A’;。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>对于数值类型的基本类型的取值范围，我们无需强制去记忆，因为它们的值都已经以常量的形式定义在对应的包装类中了。请看下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrimitiveTypeTest &#123;        public static void main(String[] args) &#123;              &#x2F;&#x2F; byte              System.out.println(&quot;基本类型：byte 二进制位数：&quot; + Byte.SIZE);              System.out.println(&quot;包装类：java.lang.Byte&quot;);              System.out.println(&quot;最小值：Byte.MIN_VALUE&#x3D;&quot; + Byte.MIN_VALUE);              System.out.println(&quot;最大值：Byte.MAX_VALUE&#x3D;&quot; + Byte.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; short              System.out.println(&quot;基本类型：short 二进制位数：&quot; + Short.SIZE);              System.out.println(&quot;包装类：java.lang.Short&quot;);              System.out.println(&quot;最小值：Short.MIN_VALUE&#x3D;&quot; + Short.MIN_VALUE);              System.out.println(&quot;最大值：Short.MAX_VALUE&#x3D;&quot; + Short.MAX_VALUE);              System.out.println();                 &#x2F;&#x2F; int              System.out.println(&quot;基本类型：int 二进制位数：&quot; + Integer.SIZE);              System.out.println(&quot;包装类：java.lang.Integer&quot;);              System.out.println(&quot;最小值：Integer.MIN_VALUE&#x3D;&quot; + Integer.MIN_VALUE);              System.out.println(&quot;最大值：Integer.MAX_VALUE&#x3D;&quot; + Integer.MAX_VALUE);              System.out.println();              &#x2F;&#x2F; long              System.out.println(&quot;基本类型：long 二进制位数：&quot; + Long.SIZE);              System.out.println(&quot;包装类：java.lang.Long&quot;);              System.out.println(&quot;最小值：Long.MIN_VALUE&#x3D;&quot; + Long.MIN_VALUE);              System.out.println(&quot;最大值：Long.MAX_VALUE&#x3D;&quot; + Long.MAX_VALUE);              System.out.println();            &#x2F;&#x2F; float              System.out.println(&quot;基本类型：float 二进制位数：&quot; + Float.SIZE);              System.out.println(&quot;包装类：java.lang.Float&quot;);              System.out.println(&quot;最小值：Float.MIN_VALUE&#x3D;&quot; + Float.MIN_VALUE);              System.out.println(&quot;最大值：Float.MAX_VALUE&#x3D;&quot; + Float.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; double              System.out.println(&quot;基本类型：double 二进制位数：&quot; + Double.SIZE);              System.out.println(&quot;包装类：java.lang.Double&quot;);              System.out.println(&quot;最小值：Double.MIN_VALUE&#x3D;&quot; + Double.MIN_VALUE);              System.out.println(&quot;最大值：Double.MAX_VALUE&#x3D;&quot; + Double.MAX_VALUE);              System.out.println();                    &#x2F;&#x2F; char              System.out.println(&quot;基本类型：char 二进制位数：&quot; + Character.SIZE);              System.out.println(&quot;包装类：java.lang.Character&quot;);                  &#x2F;&#x2F; 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台              System.out.println(&quot;最小值：Character.MIN_VALUE&#x3D;&quot; + (int) Character.MIN_VALUE);              &#x2F;&#x2F; 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台              System.out.println(&quot;最大值：Character.MAX_VALUE&#x3D;&quot; + (int) Character.MAX_VALUE);       &#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译以上代码输出结果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">基本类型：byte 二进制位数：8包装类：java.lang.Byte最小值：Byte.MIN_VALUE&#x3D;-128最大值：Byte.MAX_VALUE&#x3D;127基本类型：short 二进制位数：16包装类：java.lang.Short最小值：Short.MIN_VALUE&#x3D;-32768最大值：Short.MAX_VALUE&#x3D;32767基本类型：int 二进制位数：32包装类：java.lang.Integer最小值：Integer.MIN_VALUE&#x3D;-2147483648最大值：Integer.MAX_VALUE&#x3D;2147483647基本类型：long 二进制位数：64包装类：java.lang.Long最小值：Long.MIN_VALUE&#x3D;-9223372036854775808最大值：Long.MAX_VALUE&#x3D;9223372036854775807基本类型：float 二进制位数：32包装类：java.lang.Float最小值：Float.MIN_VALUE&#x3D;1.4E-45最大值：Float.MAX_VALUE&#x3D;3.4028235E38基本类型：double 二进制位数：64包装类：java.lang.Double最小值：Double.MIN_VALUE&#x3D;4.9E-324最大值：Double.MAX_VALUE&#x3D;1.7976931348623157E308基本类型：char 二进制位数：16包装类：java.lang.Character最小值：Character.MIN_VALUE&#x3D;0最大值：Character.MAX_VALUE&#x3D;65535<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Float和Double的最小值和最大值都是以科学记数法的形式输出的，结尾的”E+数字”表示E之前的数字要乘以10的多少次方。比如3.14E3就是3.14 × 103 =3140，3.14E-3 就是 3.14 x 10-3 =0.00314。</p><p>实际上，JAVA中还存在另外一种基本类型 void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p>下表列出了 Java 各个类型的默认值：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>数据类型</strong></th><th style="text-align:left"><strong>默认值</strong></th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">0L</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">0.0f</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">0.0d</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">‘u0000’</td></tr><tr><td style="text-align:left">String (or any object)</td><td style="text-align:left">null</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">false</td></tr></tbody></table></div><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>public class Test {    static boolean bool;    static byte by;    static char ch;    static double d;    static float f;    static int i;    static long l;    static short sh;    static String str;     public static void main(String[] args) {        System.out.println(“Bool :” + bool);        System.out.println(“Byte :” + by);        System.out.println(“Character:” + ch);        System.out.println(“Double :” + d);        System.out.println(“Float :” + f);        System.out.println(“Integer :” + i);        System.out.println(“Long :” + l);        System.out.println(“Short :” + sh);        System.out.println(“String :” + str);    } }</p><p>实例输出结果为：</p><pre class="line-numbers language-none"><code class="language-none">Bool     :falseByte     :0Character:Double   :0.0Float    :0.0Integer  :0Long     :0Short    :0String   :null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li><li>对象、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li><li>例子：Site site = new Site(“Runoob”)。</li></ul><hr><h2 id="Java-常量"><a href="#Java-常量" class="headerlink" title="Java 常量"></a>Java 常量</h2><p>常量在程序运行时是不能被修改的。</p><p>在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：</p><pre class="line-numbers language-none"><code class="language-none">final double PI &#x3D; 3.1415927;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p><p>字面量可以赋给任何内置类型的变量。例如：</p><pre class="line-numbers language-none"><code class="language-none">byte a &#x3D; 68;char a &#x3D; &#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>byte、int、long、和short都可以用十进制、16进制以及8进制的方式来表示。</p><p>当使用字面量的时候，前缀 <strong>0</strong> 表示 8 进制，而前缀 <strong>0x</strong> 代表 16 进制, 例如：</p><pre class="line-numbers language-none"><code class="language-none">int decimal &#x3D; 100;int octal &#x3D; 0144;int hexa &#x3D;  0x64;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>和其他语言一样，Java的字符串常量也是包含在两个引号之间的字符序列。下面是字符串型字面量的例子：</p><pre class="line-numbers language-none"><code class="language-none">&quot;Hello World&quot;&quot;two\nlines&quot;&quot;\&quot;This is in quotes\&quot;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>字符串常量和字符变量都可以包含任何 Unicode 字符。例如：</p><pre class="line-numbers language-none"><code class="language-none">char a &#x3D; &#39;\u0001&#39;;String a &#x3D; &quot;\u0001&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Java语言支持一些特殊的转义字符序列。</p><div class="table-container"><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">字符含义</th></tr></thead><tbody><tr><td style="text-align:left">\n</td><td style="text-align:left">换行 (0x0a)</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车 (0x0d)</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页符(0x0c)</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">退格 (0x08)</td></tr><tr><td style="text-align:left">\0</td><td style="text-align:left">空字符 (0x0)</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">空格 (0x20)</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">制表符</td></tr><tr><td style="text-align:left">\”</td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left">\’</td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left">\\</td><td style="text-align:left">反斜杠</td></tr><tr><td style="text-align:left">\ddd</td><td style="text-align:left">八进制字符 (ddd)</td></tr><tr><td style="text-align:left">\uxxxx</td><td style="text-align:left">16进制Unicode字符 (xxxx)</td></tr></tbody></table></div><hr><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p><p>转换从低级到高级。</p><pre class="line-numbers language-none"><code class="language-none">低  ------------------------------------&gt;  高byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据类型转换必须满足如下规则：</p><ul><li><p>\1. 不能对boolean类型进行类型转换。</p></li><li><p>\2. 不能把对象类型转换成不相关类的对象。</p></li><li><p>\3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>\4. 转换过程中可能导致溢出或损失精度，例如：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D;128;   byte b &#x3D; (byte)i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p></li><li><p>\5. 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><pre class="line-numbers language-none"><code class="language-none">(int)23.7 &#x3D;&#x3D; 23;        (int)-45.89f &#x3D;&#x3D; -45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>public class ZiDongLeiZhuan{        public static void main(String[] args){            char c1=’a’;//定义一个char类型            int i1 = c1;//char自动类型转换为int            System.out.println(“char自动类型转换为int后的值等于”+i1);            char c2 = ‘A’;//定义一个char类型            int i2 = c2+1;//char 类型和 int 类型计算            System.out.println(“char类型和int计算后的值等于”+i2);        } }</p><p>运行结果为:</p><pre class="line-numbers language-none"><code class="language-none">char自动类型转换为int后的值等于97char类型和int计算后的值等于66<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>解析：</strong>c1 的值为字符 <strong>a</strong> ,查 ASCII 码表可知对应的 int 类型值为 97， A 对应值为 65，所以 <strong>i2=65+1=66</strong>。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li><p>\1. 条件是转换的数据类型必须是兼容的。</p></li><li><p>\2. 格式：(type)value type是要强制类型转换后的数据类型 实例：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><p>public class QiangZhiZhuanHuan{    public static void main(String[] args){        int i1 = 123;        byte b = (byte)i1;//强制类型转换为byte        System.out.println(“int强制类型转换为byte后的值等于”+b);    } }</p><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">int强制类型转换为byte后的值等于123<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ul><li>1、 整数的默认类型是 int。</li><li>\2. 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li></ul><p>这一节讲解了 Java 的基本数据类型。下一节将探讨不同的变量类型以及它们的用法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-基本数据类型&quot;&gt;&lt;a href=&quot;#Java-基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;Java 基本数据类型&quot;&gt;&lt;/a&gt;Java 基本数据类型&lt;/h1&gt;&lt;p&gt;变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申</summary>
      
    
    
    
    <category term="java基本数据类型" scheme="https://knowledge-things.github.io/categories/java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
  </entry>
  
</feed>
